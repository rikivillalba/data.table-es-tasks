msgid ""
msgstr ""
"Project-Id-Version: data.table 1.15.99\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-28 21:08+0000\n"
"PO-Revision-Date: 2024-09-10 21:18-0300MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n!=1);\n"

#: data.table.R:2789
#, c-format
msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, :=, `:=`(...) and let(...) "
"are defined for use in j, once only and in particular ways. Note that "
"namespace-qualification like data.table::`:=`(...) is not supported. See "
"help(\":=\")."
msgstr ""
"Compruebe que is.data.table(DT) == TRUE. De lo contrario, :=, `:=`(...) y "
"let(...) se definen para su uso en j, una sola vez y de manera particular. "
"Note que la calificación de espacio de nombre (data.table::`:=`(...) no está "
"soportada. Ver help(\":=\")."

#: fread.R:115
#, c-format
msgid ""
"To read %s files directly, fread() requires 'R.utils' package which cannot "
"be found. Please install 'R.utils' using 'install.packages('R.utils')'."
msgstr ""
"Para leer archivos %s directamente, fread() requiere el paquete 'R.utils' "
"que no se puede encontrar. Instale 'R.utils' usando 'install.packages('R."
"utils')'."

#: AllS4.R:2
#, c-format
msgid "data.table package loaded. When developing don't load package"
msgstr "paquete data.table cargado. En desarrollo, no cargue el paquete."

#: IDateTime.R:107
#, c-format
msgid "binary + is not defined for \"IDate\" objects"
msgstr "operador binario `+` no está definido para objetos \"IDate\""

#: IDateTime.R:114
#, c-format
msgid "can only subtract from \"IDate\" objects"
msgstr "sólo se puede restar de objetos \"IDate\""

#: IDateTime.R:119
#, c-format
msgid "unary - is not defined for \"IDate\" objects"
msgstr "operador unario `-` no está definido para objetos \"IDate\""

#: IDateTime.R:309
#, c-format
msgid "Valid options for ms are 'truncate', 'nearest', and 'ceil'."
msgstr "Las opciones válidas para ms son 'truncate', 'nearest' y 'ceil'."

#: as.data.table.R:86
#, c-format
msgid ""
"as.data.table.array method should only be called for arrays with 3+ "
"dimensions; use the matrix method for 2-dimensional arrays"
msgstr ""
"El método as.data.table.array solo debe llamarse para matrices con más de 3 "
"dimensiones; utilizar el método matricial para matrices bidimensionales"

#: as.data.table.R:88
#, c-format
msgid ""
"Argument 'value.name' must be scalar character, non-NA and at least one "
"character"
msgstr ""
"El argumento 'value.name' debe ser un carácter escalar, no NA y al menos un "
"carácter"

#: as.data.table.R:90
#, c-format
msgid "Argument 'sorted' must be scalar logical and non-NA"
msgstr "El argumento 'sorted' debe ser lógico escalar y no NA"

#: as.data.table.R:92
#, c-format
msgid "Argument 'na.rm' must be scalar logical and non-NA"
msgstr "El argumento 'na.rm' debe ser lógico escalar y no NA"

#: as.data.table.R:94
#, c-format
msgid "Please provide either 'key' or 'sorted', but not both."
msgstr "Proporcione 'key' o 'sorted', pero no ambos."

#: as.data.table.R:108
#, c-format
msgid ""
"Argument 'value.name' should not overlap with column names in result: %s"
msgstr ""
"El argumento 'value.name' no debe superponerse con los nombres de las "
"columnas en el resultado: %s"

#: as.data.table.R:140
#, c-format
msgid ""
"POSIXlt column type detected and converted to POSIXct. We do not recommend "
"use of POSIXlt at all because it uses 40 bytes to store one date."
msgstr ""
"Tipo de columna POSIXlt detectado y convertido a POSIXct. No recomendamos el "
"uso de POSIXlt porque utiliza 40 bytes para almacenar una fecha."

#: as.data.table.R:181
#, c-format
msgid "Item %d has %d rows but longest item has %d; recycled with remainder."
msgstr ""
"El elemento %d tiene %d filas pero el artículo más largo tiene %d; Reciclado "
"con resto."

#: as.data.table.R:196
#, c-format
msgid "A column may not be called .SD. That has special meaning."
msgstr "Una columna no puede llamarse .SD. Eso tiene un significado especial."

#: as.data.table.R:210
#, c-format
msgid "class must be length 1"
msgstr "la clase debe tener una longitud de 1"

#: between.R:3
#, c-format
msgid "between has been passed an argument x of type logical"
msgstr "entre se ha pasado un argumento x de tipo lógico"

#: between.R:13 between.R:15
#, c-format
msgid ""
"'between' function the 'x' argument is a POSIX class while '%s' was not, "
"coercion to POSIX failed with: %s"
msgstr ""
"'between' función el argumento 'x' es una clase POSIX mientras que '%s' no "
"lo era, la coerción a POSIX falló con: %s"

#: between.R:27
#, c-format
msgid ""
"'between' lower= and upper= are both POSIXct but have different tzone "
"attributes: %s. Please align their time zones."
msgstr ""
"'between' lower= y Upper= son ambos POSIXct pero tienen diferentes atributos "
"de tzone: %s. Por favor alinee las zonas horarias."

#: between.R:31
#, c-format
msgid ""
"'between' arguments are all POSIXct but have mismatched tzone attributes: "
"%s. The UTC times will be compared."
msgstr ""
"Los argumentos >>'between' son todos POSIXct pero tienen atributos de tzone "
"que no coinciden: %s. Se compararán las fechas-hora UTC."

#: between.R:36
#, c-format
msgid "trying to use integer64 class when 'bit64' package is not installed"
msgstr ""
"Se intentó utilizar la clase integer64 cuando el paquete 'bit64' no está "
"instalado"

#: between.R:48
#, c-format
msgid ""
"Not yet implemented NAbounds=TRUE for this non-numeric and non-character type"
msgstr ""
"Aún no se ha implementado NAbounds=TRUE para este tipo no numérico ni de "
"caracteres"

#: between.R:49
#, c-format
msgid "Some lower>upper for this non-numeric and non-character type"
msgstr ""
"Algunos valores 'lower' (inferior) son mayores que 'upper' (superior) para "
"este tipo que no es numérico ni de caracteres"

#: between.R:63
#, c-format
msgid "Perhaps you meant %s?"
msgstr "¿Quizás se refiere a %s?"

#: between.R:64
#, c-format
msgid ""
"RHS has length() %d; expecting length 2. %sThe first element should be the "
"lower bound(s); the second element should be the upper bound(s)."
msgstr ""
"RHS tiene longitud %d; se esparaba longitud 2. %s El primer elemento debe "
"ser el límite inferior; el segundo elemento debe ser el límite superior."

#: bmerge.R:48 bmerge.R:49
#, c-format
msgid "%s is type %s which is not supported by data.table join"
msgstr "%s es de tipo %s que no es compatible con data.table join"

#: bmerge.R:52
#, c-format
msgid ""
"Attempting roll join on factor column when joining %s to %s. Only integer, "
"double or character columns may be roll joined."
msgstr ""
"Se intentó hacer un roll join en una columna de factor al unir %s con %s. "
"Sólo se puede hacer roll join en columnas de números enteros, dobles o de "
"caracteres."

#: bmerge.R:71
#, c-format
msgid ""
"Incompatible join types: %s (%s) and %s (%s). Factor columns must join to "
"factor or character columns."
msgstr ""
"Tipos de unión incompatibles: %s (%s) y %s (%s). Las columnas de factores "
"deben unirse a columnas de factores o caracteres."

#: bmerge.R:90
#, c-format
msgid "Incompatible join types: %s (%s) and %s (%s)"
msgstr "Tipos de unión incompatibles: %s (%s) y %s (%s)"

#: bmerge.R:98
#, c-format
msgid ""
"Incompatible join types: %s is type integer64 but %s is type double and "
"contains fractions"
msgstr ""
"Tipos de unión incompatibles: %s es de tipo entero64 pero %s es de tipo "
"doble y contiene fracciones"

#: bmerge.R:150
#, c-format
msgid "roll is not implemented for non-equi joins yet."
msgstr "roll aún no está implementado para non-equi joins"

#: bmerge.R:170
#, c-format
msgid "Column name '_nqgrp_' is reserved for non-equi joins."
msgstr "El nombre de columna '_nqgrp_' está reservado para non-equi joins"

#: data.table.R:55
#, c-format
msgid "key argument of data.table() must be character"
msgstr "el argumento 'key' de data.table() debe ser tipo carácter"

#: data.table.R:121
#, c-format
msgid "Object '%s' not found. Perhaps you intended %s"
msgstr "Objeto '%s' no encontrado. Quizás buscaba %s"

#: data.table.R:123
#, c-format
msgid "Object '%s' not found amongst %s"
msgstr "Objeto '%s' no encontrado entre %s"

#: data.table.R:139
#, c-format
msgid ""
"[ was called on a data.table in an environment that is not data.table-aware "
"(i.e. cedta()), but '%s' was used, implying the owner of this call really "
"intended for data.table methods to be called. See vignette('datatable-"
"importing') for details on properly importing data.table."
msgstr ""
"`[` fue llamado en un data.table en un entorno que no está al tanto de la "
"presencia de data.table (es decir, cedta()), pero se usó '%s', lo que "
"implica que el propietario de esta llamada realmente tenía la intención de "
"llamar a métodos de data.table. Consulte vignette('datatable-importing') "
"para obtener detalles sobre la importación correcta de data.table."

#: data.table.R:150
#, c-format
msgid "verbose must be logical or integer"
msgstr "'verbose' debe ser lógico o entero"

#: data.table.R:151
#, c-format
msgid "verbose must be length 1 non-NA"
msgstr "'verbose' debe tener longitud 1 no NA"

#: data.table.R:159
#, c-format
msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr "Ignorando by/keyby porque no se proporciona 'j'"

#: data.table.R:173
#, c-format
msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr "Cuando se proporcionan by y keyby, keyby debe ser TRUE o FALSE"

#: data.table.R:185
#, c-format
msgid ""
"When on= is provided but not i=, on= must be a named list or data.table|"
"frame, and a natural join (i.e. join on common names) is invoked. Ignoring "
"on= which is '%s'."
msgstr ""
"Cuando se proporciona on= pero no i=, on= debe ser una lista con nombre o "
"data.table|frame, y se invoca un «natural join» (es decir, unión en nombres "
"comunes). Ignorando on= que es '%s'."

#: data.table.R:198
#, c-format
msgid ""
"i and j are both missing so ignoring the other arguments. This warning will "
"be upgraded to error in future."
msgstr ""
"Faltan i y j, por lo que se ignoran los otros argumentos. Esta advertencia "
"se actualizará a error en el futuro."

#: data.table.R:202
#, c-format
msgid "mult argument can only be 'first', 'last' or 'all'"
msgstr "el argumento múltiple sólo puede ser 'first', 'last' o 'all'"

#: data.table.R:204
#, c-format
msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double "
"including +Inf and -Inf or 'nearest'"
msgstr ""
"'roll' debe ser un único valor lógico TRUE/FALSE, número entero/doble "
"positivo o negativo incluyendo +Inf y -Inf, o 'nearest'"

#: data.table.R:206
#, c-format
msgid "roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr ""
"roll es '%s' (tipo carácter). El único valor de carácter válido es 'nearest'."

#: data.table.R:211
#, c-format
msgid "rollends must be a logical vector"
msgstr "'rollends' debe ser un vector lógico"

#: data.table.R:212
#, c-format
msgid "rollends must be length 1 or 2"
msgstr "'rollends' deben tener una longitud de 1 o 2"

#: data.table.R:220
#, c-format
msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which "
"is the same as NULL but please use NULL)"
msgstr ""
"nomatch= debe ser NA o NULL (o 0 para compatibilidad con versiones "
"anteriores, que es lo mismo que NULL, pero por favor utilice NULL)"

#: data.table.R:223
#, c-format
msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr ""
"which= debe ser un vector lógico de longitud 1. Ya sea FALSE, TRUE o NA."

#: data.table.R:224
#, c-format
msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you "
"need row numbers or the result of j, but only one type of result can be "
"returned."
msgstr ""
"which==%s (que significa que se devolverán los números de fila) pero también "
"se proporciona j. O bien necesita números de fila o el resultado de j, pero "
"solo se puede devolver un tipo de resultado."

#: data.table.R:225
#, c-format
msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""
"which=NA con nomatch=0|NULL siempre devolvería un vector vacío. Cambie o "
"elimine o bien which o nomatch."

#: data.table.R:226
#, c-format
msgid "j must be provided when with=FALSE"
msgstr "j debe proporcionarse cuando with=FALSE"

#: data.table.R:227
msgid "%s must be TRUE or FALSE"
msgstr "%s debe ser TRUE o FALSE"

#: data.table.R:267
#, c-format
msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr ""
"El símbolo .. no es válido. El prefijo .. debe ir seguido de al menos un "
"carácter."

#: data.table.R:270
#, c-format
msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr ""
"Sin embargo, la variable '..%s' existe en el ámbito de la llamada, así que "
"elimine el prefijo .. de ese nombre de variable en el ámbito de llamada."

#: data.table.R:274
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you used the .. prefix.%s"
msgstr ""
"La variable '%s' no se encuentra en el ámbito de la llamada. Buscando en el "
"ámbito de la llamada porque se utilizó el prefijo ..%s"

#: data.table.R:276
#, c-format
msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr ""
"Tanto '%1$s' como '..%1$s' existen en el ámbito de llamada. Elimine la "
"variable '..%1$s' al llamar al ámbito para mayor claridad."

#: data.table.R:284
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you set with=FALSE. Also, please use .. symbol prefix and remove "
"with=FALSE."
msgstr ""
"La variable '%s' no se encuentra en el ámbito de la llamada. Buscando en el "
"ámbito de la llamada porque se proporcionó with = FALSE. Además, por favor "
"utilice el prefijo de símbolo .. y elimine with=FALSE."

#: data.table.R:292
#, c-format
msgid ""
"You have wrapped := with {} which is ok but then := must be the only thing "
"inside {}. You have something else inside {} as well. Consider placing the "
"{} on the RHS of := instead; e.g. DT[,someCol:={tmpVar1<-...;tmpVar2<-...;"
"tmpVar1*tmpVar2}"
msgstr ""
"Ha rodeado := con {} lo cual está bien, pero entonces := debe ser lo único "
"dentro de {}. También tiene algo más dentro de {}. Considere colocar {} en "
"el lado derecho de := en su lugar; p.ej. DT[,someCol:={tmpVar1<-...;"
"tmpVar2<-...;tmpVar1*tmpVar2}"

#: data.table.R:310
#, c-format
msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey "
"on a subset of rows. Either change keyby to by or remove i"
msgstr ""
":= con keyby solo es posible cuando no se proporciona i ya que no se puede "
"configurar la clave en un subconjunto de filas. Cambie keyby a by o elimine i"

#: data.table.R:312
#, c-format
msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr "nomatch no es relevante junto con :=, ignorando nomatch"

#: data.table.R:368
#, c-format
msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""
"not-join '!' El prefijo está presente en i pero no se proporciona ninguna "
"coincidencia. Por favor elimine nomatch."

#: data.table.R:396
#, c-format
msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting "
"the first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). "
"Please double-check the syntax. Run traceback(), and debugger() to get a "
"line number."
msgstr ""
"Operador := detectado en i, el primer argumento dentro de DT[...], pero sólo "
"es válido en el segundo argumento, j. La mayoría de las veces, esto sucede "
"cuando se olvida la primera coma (por ejemplo, DT[newvar := 5] en lugar de "
"DT[ , new_var := 5]). Vuelva a verificar la sintaxis. Ejecute traceback() y "
"debugger() para obtener un número de línea."

#: data.table.R:406
#, c-format
msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr ""
"'%s' no se encuentra en el ámbito de llamada y tampoco es un nombre de "
"columna"

#: data.table.R:409
#, c-format
msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you "
"wish to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE} is particularly clear and is optimized"
msgstr ""
"'%s' no se encuentra en el ámbito de llamada, pero es una columna de tipo "
"%s. Si desea seleccionar filas donde esa columna contiene TRUE, o tal vez "
"esa columna contiene números de fila para seleccionar, intente con "
"DT[(col)], DT[DT$col] o DT[col==TRUE} es particularmente claro. y está "
"optimizado"

#: data.table.R:412
#, c-format
msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. "
"DT[var]), data.table looks for var in calling scope."
msgstr ""
"%s. Cuando el primer argumento dentro de DT[...] es un símbolo único (por "
"ejemplo, DT[var]), data.table busca var en el ámbito de llamada."

#: data.table.R:424
#, c-format
msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return "
"a list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report "
"to data.table issue tracker if you'd like this, or add your comments to FR "
"#657."
msgstr ""
"i es un tipo no válido (matriz). Quizás en el futuro una matriz de 2 "
"columnas podría devolver una lista de elementos de DT (en el espíritu de "
"A[B] en la pregunta frecuente 2.14). Informe al rastreador de problemas de "
"data.table si desea esto o agregue sus comentarios al FR #657."

#: data.table.R:447
#, c-format
msgid ""
"When i is a data.table (or character vector), the columns to join by must be "
"specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted, "
"and, marked as sorted, see ?setkey), or by sharing column names between x "
"and i (i.e., a natural join). Keyed joins might have further speed benefits "
"on very large data due to x being sorted in RAM."
msgstr ""
"Cuando i es una tabla de datos (o un vector de caracteres), las columnas "
"para unir deben especificarse usando el argumento 'on=' (ver ?data.table), "
"ingresando x (es decir, ordenadas y marcadas como ordenadas, consulte ?"
"setkey), o compartiendo nombres de columnas entre xey (es decir, una unión "
"natural). Las uniones por clave pueden tener mayores beneficios de velocidad "
"en datos muy grandes debido a que x se ordena en la RAM."

#: data.table.R:455
#, c-format
msgid "Attempting to do natural join but no common columns in provided tables"
msgstr ""
"Intentando realizar una unión natural pero sin columnas comunes en las "
"tablas proporcionadas"

#: data.table.R:587
#, c-format
msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr ""
"error lógico. i no es data.table, pero se proporciona el argumento 'on'."

#: data.table.R:591
#, c-format
msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr "i fue evaluado como tipo %s. Se esperaba lógico, entero o doble."

#: data.table.R:613
#, c-format
msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling "
"of logical i is no longer allowed as it hides more bugs than is worth the "
"rare convenience. Explicitly use rep(...,length=.N) if you really need to "
"recycle."
msgstr ""
"i se evalúa como vector lógico de longitud %d pero hay %d filas. Ya no se "
"permite el reciclaje de i lógico, ya que esto oculta más errores de los que "
"su rara conveniencia merece. Utilice explícitamente rep(...,length=.N) si "
"realmente necesita reciclar."

#: data.table.R:616
#, c-format
msgid ""
"Please use nomatch=NULL instead of nomatch=0; see news item 5 in v1.12.0 "
"(Jan 2019)"
msgstr ""
"Utilice nomatch=NULL en lugar de nomatch=0; ver novedades ítem 5 en v1.12.0 "
"(ene 2019)"

#: data.table.R:688
#, c-format
msgid ""
"with=FALSE together with := was deprecated in v1.9.4 released Oct 2014. "
"Please wrap the LHS of := with parentheses; e.g., DT[,(myVar):=sum(b),by=a] "
"to assign to column name(s) held in variable myVar. See ?':=' for other "
"examples. As warned in 2014, this is now a warning."
msgstr ""
"with=FALSE junto con := quedó obsoleto en la versión 1.9.4 lanzada en "
"octubre de 2014. Envuelva el LHS de := entre paréntesis; por ejemplo, DT[,"
"(myVar):=sum(b),by=a] para asignar a los nombres de las columnas contenidas "
"en la variable myVar. Consulte ?':=' para ver otros ejemplos. Como se "
"advirtió en 2014, esto ahora es una advertencia."

#: data.table.R:691
#, c-format
msgid ""
"with=FALSE ignored, it isn't needed when using :=. See ?':=' for examples."
msgstr ""
"with=FALSE ignorado, no es necesario cuando se usa :=. Consulte ?':=' para "
"ver ejemplos."

#: data.table.R:715
#, c-format
msgid "column(s) not removed because not found: %s"
msgstr "columnas no eliminadas porque no se encontraron: %s"

#: data.table.R:729
#, c-format
msgid "column(s) not found: %s"
msgstr "columnas no encontradas: %s"

#: data.table.R:735
#, c-format
msgid "Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr ""
"El elemento %d de j es %d que está fuera del rango de números de columna [1,"
"ncol=%d]"

#: data.table.R:738
#, c-format
msgid "j mixes positives and negatives"
msgstr "j mezcla índices positivos y negativos"

#: data.table.R:746
#, c-format
msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr ""
"Cuando with=FALSE, el argumento j debe ser de tipo lógico/carácter/entero "
"indicando las columnas a seleccionar."

#: data.table.R:760
#, c-format
msgid ""
"'by' contains .I but only the following are currently supported: by=.I, by=."
"(.I), by=c(.I), by=list(.I)"
msgstr ""
"'by' contiene .I, pero actualmente solo se admiten los siguientes: by=.I, "
"by=.(.I), by=c(.I), by=list(.I)"

#: data.table.R:784
#, c-format
msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr "by=c(...), key(...) o names(...) deben evaluarse como carácter"

#: data.table.R:794
#, c-format
msgid ""
"'by' is a character vector length %d but one or more items include a comma. "
"Either pass a vector of column names (which can contain spaces, but no "
"commas), or pass a vector length 1 containing comma separated column names. "
"See ?data.table for other possibilities."
msgstr ""
"'by' es un vector de caracteres de longitud %d, pero uno o más elementos "
"incluyen una coma. O bien proporcione un vector de nombres de columna (que "
"pueden contener espacios, pero no comas), o bien un vecctor de longitud 1 "
"que contenga los nombres de columna separados por coma. Vea ?data.table para "
"más posibilidades."

#: data.table.R:801
#, c-format
msgid "At least one entry of by is empty"
msgstr "Al menos una entrada de by está vacía"

#: data.table.R:876
#, c-format
msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""
"'by' parece evaluar los nombres de las columnas pero no es c() o key(). "
"Utilice by=list(...) si puede. De lo contrario, by=eval%s debería funcionar. "
"Esto es por eficiencia para que data.table pueda detectar qué columnas son "
"necesarias."

#: data.table.R:887
#, c-format
msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list' "
"includes data.table and data.frame which are lists, too)"
msgstr ""
"'by' o 'keyby' deben evaluarse como un vector o una lista de vectores (donde "
"'list' incluye data.table y data. frame que también son listas)"

#: data.table.R:891
#, c-format
msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not "
"currently supported. If you have a compelling use case, please add it to "
"https://github.com/Rdatatable/data.table/issues/1597. As a workaround, "
"consider converting the column to a supported type, e.g. by=sapply(list_col, "
"toString), whilst taking care to maintain distinctness in the process."
msgstr ""
"La columna o expresión %d de 'by' o 'keyby' es de tipo '%s' que no se admite "
"actualmente. Si tiene un caso de uso convincente, agréguelo a https://github."
"com/Rdatatable/data.table/issues/1597. Como solución alternativa, considere "
"convertir la columna a un tipo admitido, p. by=sapply(list_col, toString), "
"teniendo cuidado de mantener la distinción en el proceso."

#: data.table.R:895
#, c-format
msgid ""
"The items in the 'by' or 'keyby' list are length(s) %s. Each must be length "
"%d; the same length as there are rows in x (after subsetting if i is "
"provided)."
msgstr ""
"Los elementos en la lista 'by' o 'keyby' tienen length(es) %s. Cada uno debe "
"tener una length %d; la misma length que filas en x (después del subconjunto "
"si se proporciona i)."

#: data.table.R:948
#, c-format
msgid "Item %d of the .() or list() passed to j is missing"
msgstr "Falta el elemento %d de .() o list() pasado a j"

#: data.table.R:954
#, c-format
msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of "
"[ for efficiency"
msgstr ""
"j puede no estar evaluando el mismo número de columnas para cada grupo; Si "
"está seguro de que esta advertencia es un error, coloque la lógica de "
"bifurcación fuera de [ para mayor eficiencia"

#: data.table.R:956
#, c-format
msgid ""
"Different branches of j expression produced different auto-named columns: "
"%s; using the most \"last\" names. If this was intentional (e.g., you know "
"only one branch will ever be used in a given query because the branch is "
"controlled by a function argument), please (1) pull this branch out of the "
"call; (2) explicitly provide missing defaults for each branch in all cases; "
"or (3) use the same name for each branch and re-name it in a follow-up call."
msgstr ""
"Diferentes ramas de la expresión j produjeron diferentes columnas con nombre "
"automático: %s; usando la mayoría de los nombres \"last\". Si esto fue "
"intencional (por ejemplo, sabe que solo se usará una rama en una consulta "
"determinada porque la rama está controlada por un argumento de función), (1) "
"retire esta rama de la llamada; (2) proporcione explícitamente los valores "
"predeterminados faltantes para cada rama en todos los casos; o (3) use el "
"mismo nombre para cada rama y cambie el nombre en una llamada de terminación."

#: data.table.R:1026
#, c-format
msgid ""
"When .SDcols is a function, it is applied to each column; the output of this "
"function must be a non-missing boolean scalar signalling inclusion/exclusion "
"of the column. However, these conditions were not met for: %s"
msgstr ""
"Cuando .SDcols es una función, se aplica a cada columna; la salida de esta "
"función debe ser un escalar booleano no faltante que indique la inclusión/"
"exclusión de la columna. Sin embargo, estas condiciones no se cumplieron "
"para: %s"

#: data.table.R:1032
#, c-format
msgid ".SDcols missing at the following indices: %s"
msgstr ".SDcols faltantes en los siguientes índices: %s"

#: data.table.R:1034
#, c-format
msgid ".SDcols is a logical vector length %d but there are %d columns"
msgstr ".SDcols es un vector lógico de longitud %d pero hay %d columnas"

#: data.table.R:1040
#, c-format
msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ".SDcols es numérico pero tiene índices tanto positivos como negativos"

#: data.table.R:1042
#, c-format
msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ".SDcols es numérico pero está fuera de los límites [1, %d] en: %s"

#: data.table.R:1046
#, c-format
msgid ".SDcols should be column numbers or names"
msgstr ".SDcols debe ser números o nombres de columnas"

#: data.table.R:1048
#, c-format
msgid "Some items of .SDcols are not column names: %s"
msgstr "Algunos elementos de .SDcols no son nombres de columnas: %s"

#: data.table.R:1090
#, c-format
msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See ?"
"data.table."
msgstr ""
"Este j no usa .SD pero se ha proporcionado .SDcols. Ignorando .SDcols. "
"Consulte ?data.table."

#: data.table.R:1106
#, c-format
msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify "
"by group by reference."
msgstr ""
".SD está bloqueado. El uso := en .SD's j está reservado para un posible uso "
"futuro; una forma tortuosamente flexible de modificar por grupo. Utilice := "
"en j directamente para modificar por grupo por referencia."

#: data.table.R:1114
#, c-format
msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr ""
"En la forma %s(col1=val1, col2=val2, ...), todos los argumentos deben tener "
"nombre."

#: data.table.R:1136
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but the "
"last argument has no name. Did you forget a trailing comma?"
msgstr ""
"En el formato %s(col1=val1, col2=val2, ...), todos los argumentos deben "
"tener nombre, pero el último argumento no tiene nombre. ¿Olvidó una coma "
"final?"

#: data.table.R:1138
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but "
"these arguments lack names: %s."
msgstr ""
"En el formato %s(col1=val1, col2=val2, ...), todos los argumentos deben "
"tener nombre, pero estos argumentos carecen de nombre: %s."

#: data.table.R:1145
#, c-format
msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ""
"LHS de := debe ser un símbolo o un vector atómico (nombres o posiciones de "
"columnas)."

#: data.table.R:1150
#, c-format
msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New "
"columns can only be added by name."
msgstr ""
"LHS de := parecen ser posiciones de columna pero están fuera del rango [1,"
"ncol]. Solo se pueden agregar nuevas columnas por nombre."

#: data.table.R:1153
#, c-format
msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ""
"LHS de := no son nombres de columnas ('character') ni posiciones ('integer' "
"o 'numeric')"

#: data.table.R:1184
#, c-format
msgid ""
"Invalid .internal.selfref detected and fixed by taking a (shallow) copy of "
"the data.table so that := can add this new column by reference. At an "
"earlier point, this data.table has been copied by R (or was created manually "
"using structure() or similar). Avoid names<- and attr<- which in R currently "
"(and oddly) may copy the whole data.table. Use set* syntax instead to avoid "
"copying: ?set, ?setnames and ?setattr. If this message doesn't help, please "
"report your use case to the data.table issue tracker so the root cause can "
"be fixed or this message improved."
msgstr ""
" .internal.selfref no válido detectado y solucionado tomando una copia "
"(superficial) de data.table para que := pueda agregar esta nueva columna por "
"referencia. En un momento anterior, R copió esta data.table (o se creó "
"manualmente usando structure() o similar). Evite names<- y attr<- que en R "
"actualmente (y curiosamente) pueden copiar toda la data.table. Utilice la "
"sintaxis set* en su lugar para evitar copiar: ?set, ?setnames y ?setattr. Si "
"este mensaje no ayuda, informe su caso de uso al rastreador de problemas de "
"data.table para que se pueda solucionar la causa raíz o mejorar este mensaje."

#: data.table.R:1215
#, c-format
msgid ""
"Cannot assign to an under-allocated recursively indexed list -- L[[i]][,:=] "
"syntax is only valid when i is length 1, but its length is %d"
msgstr ""
"No se puede asignar a una lista indexada recursiva con  espacio sub-"
"asignado: la sintaxis L[[i]][,:=] solo es válida cuando i tiene una longitud "
"de 1, pero su longitud es %d"

#: data.table.R:1284
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because this symbol was prefixed with .. in the j= parameter."
msgstr ""
"La variable '%s' no se encuentra en el ámbito de la llamada. Se busca en el "
"ámbito de la llamada porque este símbolo tenía el prefijo .. en el parámetro "
"j=."

#: data.table.R:1370
#, c-format
msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' "
"is not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar "
"to a file system path."
msgstr ""
"j (el segundo argumento dentro de [...]) es un símbolo único pero no se "
"encuentra el nombre de la columna '%1$s'. Si tenía la intención de "
"seleccionar columnas usando una variable al llamar al ámbito, intente con "
"DT[, ..%1$s]. El prefijo .. transmite un nivel superior similar a la ruta de "
"un sistema de archivos."

#: data.table.R:1454
#, c-format
msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""
"La columna '.N' no se puede agrupar porque entra en conflicto con la "
"variable especial .N. Pruebe setnames(DT,'.N','N') primero."

#: data.table.R:1455
#, c-format
msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""
"La columna '.I' no se puede agrupar porque entra en conflicto con la "
"variable especial .I. Pruebe setnames(DT,'.I','I') primero."

#: data.table.R:1483
#, c-format
msgid "logical error. i is not data.table, but mult='all' and 'by'=.EACHI"
msgstr "error lógico. i no es data.table, pero mult='all' y 'by'=.EACHI"

#: data.table.R:1804
#, c-format
msgid ""
"Unable to optimize call to mean() and could be very slow. You must name 'na."
"rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean "
"'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""
"No se puede optimizar la llamada a mean() y podría ser muy lento. Debe "
"nombrar 'na.rm' así; de lo contrario, si quiere decir (x, TRUE), se "
"considera que TRUE significa 'trim', que es el segundo argumento de la "
"media. 'trim' aún no está optimizado."

#: data.table.R:1950
#, c-format
msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide "
"existing column names to keyby=."
msgstr ""
"El setkey() normalmente realizado por keyby= se ha omitido (como si se usara "
"by=) porque := se usa junto con keyby= pero keyby= contiene algunas "
"expresiones. Para evitar esta advertencia, utilice by= en su lugar o "
"proporcione nombres de columnas existentes a keyby=."

#: data.table.R:2039
#, c-format
msgid "rownames and rownames.value cannot both be used at the same time"
msgstr "rownames y rownames.value no se pueden usar al mismo tiempo"

#: data.table.R:2044
#, c-format
msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr ""
"length(rownames)==%d pero nrow(DT)==%d. El argumento rownames especifica un "
"único nombre o número de columna. Considere rownames.value= en su lugar."

#: data.table.R:2048
#, c-format
msgid ""
"length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""
"length(rownames)==0 pero debe ser un nombre o número de columna única, o NULL"

#: data.table.R:2052
#, c-format
msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] "
"as rownames"
msgstr ""
"rownames es TRUE pero la clave tiene varias columnas %s; tomando la primera "
"columna x[,1] como nombres de fila"

#: data.table.R:2062
#, c-format
msgid "'%s' is not a column of x"
msgstr "'%s' no es una columna de x"

#: data.table.R:2068
#, c-format
msgid ""
"as.integer(rownames)==%d which is outside the column number range [1,"
"ncol=%d]."
msgstr ""
"as.integer(rownames)==%d que está fuera del rango de números de columna [1,"
"ncol=%d]."

#: data.table.R:2073
#, c-format
msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr "length(rownames.value)==%d pero debería ser nrow(x)==%d"

#: data.table.R:2169
#, c-format
msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide j"
msgstr ""
"Cuando i es una matriz en DT[i]<-sintaxis de valor, no tiene sentido "
"proporcionar j"

#: data.table.R:2179
#, c-format
msgid "j must be an atomic vector, see ?is.atomic"
msgstr "j debe ser un vector atómico, ver ?is.atomic"

#: data.table.R:2180
#, c-format
msgid "NA in j"
msgstr "NA en j"

#: data.table.R:2186
#, c-format
msgid "j must be vector of column name or positions"
msgstr "j debe ser un vector del nombre de la columna o de las posiciones"

#: data.table.R:2187
#, c-format
msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column "
"by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""
"intento de asignar una posición de columna mayor que ncol(x). En su lugar, "
"cree la columna por nombre. Esta lógica pretende detectar (los que "
"probablemente sean) errores de usuario."

#: data.table.R:2254
#, c-format
msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does "
"not. Has it been created manually (e.g. by using 'structure' rather than "
"'data.table') or saved to disk using a prior version of data.table?"
msgstr ""
"data.table hereda de data.frame (de v1.5), pero este data.table no. ¿Se ha "
"creado manualmente (por ejemplo, utilizando 'structure' en lugar de 'data."
"table') o se ha guardado en el disco utilizando una versión anterior de data."
"table?"

#: data.table.R:2263
#, c-format
msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr ""
"intento de asignar un objeto no válido a los nombres tenues de una data.table"

#: data.table.R:2264
#, c-format
msgid "data.tables do not have rownames"
msgstr "las data.tables no tienen nombres de fila"

#: data.table.R:2265 data.table.R:2634
#, c-format
msgid "Can't assign %d names to a %d-column data.table"
msgstr "No se pueden asignar %d nombres a una data.table de %d columnas"

#: data.table.R:2329
#, c-format
msgid "'subset' must evaluate to logical"
msgstr "'subset' debe evaluarse como lógico"

#: data.table.R:2372
#, c-format
msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr "El argumento 'invert' debe ser lógico TRUE/FALSE"

#: data.table.R:2413
#, c-format
msgid "x argument must be a data.table"
msgstr "x argumento debe ser una data.table"

#: data.table.R:2418
#, c-format
msgid "group length is 0 but data nrow > 0"
msgstr "la longitud del grupo es 0 pero los datos son > 0"

#: data.table.R:2420
#, c-format
msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split "
"by column in data.table and 'f' when split by external factor"
msgstr ""
"no se permite pasar el argumento 'f' junto con 'by', utilice 'by' cuando se "
"divida por columna en data.table y 'f' cuando se divida por factor externo"

#: data.table.R:2428
#, c-format
msgid "Either 'by' or 'f' argument must be supplied"
msgstr "Se debe proporcionar el argumento 'by' o 'f'"

#: data.table.R:2430
#, c-format
msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr ""
"La columna '.ll.tech.split' está reservada para el procesamiento de split."
"data.table"

#: data.table.R:2431
#, c-format
msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr ""
"La columna '.nm.tech.split' está reservada para el procesamiento de split."
"data.table"

#: data.table.R:2432
#, c-format
msgid "Argument 'by' must refer to column names in x"
msgstr ""
"El argumento 'by' debe hacer referencia a los nombres de las columnas en x"

#: data.table.R:2433
#, c-format
msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr ""
"El argumento 'by' debe hacer referencia solo a columnas de tipo atómico, "
"pero las siguientes columnas no son atómicas: %s"

#: data.table.R:2565
#, c-format
msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""
"x no es data.frame o data.table. La copia superficial es una copia del "
"vector de punteros de columna (únicamente), por lo que solo tiene sentido "
"para data.table o data.frame"

#: data.table.R:2574
#, c-format
msgid "setalloccol attempting to modify `*tmp*`"
msgstr "setalloccol intenta modificar `*tmp*`"

#: data.table.R:2609
#, c-format
msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue #1281."
msgstr ""
"La entrada es un vector lógico de longitud=1 que apunta a la misma dirección "
"que el valor global de R. Por lo tanto el atributo no ha sido establecido "
"por referencia, sino sobre una copia. Deberá volver a asignar el resultado a "
"una variable. Consulte el issue #1281."

#: data.table.R:2624
#, c-format
msgid "x is not a data.table or data.frame"
msgstr "x no es una data.table o un data.frame"

#: data.table.R:2626
#, c-format
msgid "x has %d columns but its names are length %d"
msgstr "x tiene %d columnas pero sus nombres tienen una longitud %d"

#: data.table.R:2633
#, c-format
msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr "Se pasó un vector de tipo '%s'. Debe escribirse 'character'."

#: data.table.R:2646
#, c-format
msgid "'new' is not a character vector or a function"
msgstr "'new' no es un vector de caracteres ni una función"

#: data.table.R:2648
#, c-format
msgid "NA in 'new' at positions %s"
msgstr "NA en 'new' en las posiciones %s"

#: data.table.R:2649
#, c-format
msgid "Some duplicates exist in 'old': %s"
msgstr "Existen algunos duplicados en 'old': %s"

#: data.table.R:2651
#, c-format
msgid "'old' is type %s but should be integer, double or character"
msgstr "'old' es de tipo %s pero debe ser un número entero, doble o carácter"

#: data.table.R:2652
#, c-format
msgid "'old' is length %d but 'new' is length %d"
msgstr "'old' tiene una longitud %d pero 'new' tiene una longitud %d"

#: data.table.R:2653
#, c-format
msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr "NA (o fuera de límites) en 'old' en las posiciones %s"

#: data.table.R:2656
#, c-format
msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just "
"the first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr ""
"El elemento %d de 'old' es '%s' que aparece varias veces en los nombres de "
"las columnas. Sólo se cambiará el primero. Hay %d otros elementos en 'old' "
"que también están duplicados en los nombres de las columnas."

#: data.table.R:2664
#, c-format
msgid ""
"Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr ""
"Elementos de 'old' no encontrados en los nombres de las columnas: %s. "
"Considere skip_absent=TRUE."

#: data.table.R:2703
#, c-format
msgid ""
"x has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr ""
"x tiene algunos nombres de columna duplicados: %s. Elimine o cambie el "
"nombre de los duplicados e inténtelo de nuevo."

#: data.table.R:2705
#, c-format
msgid "Provide either before= or after= but not both"
msgstr "Proporcione before= o after= pero no ambos"

#: data.table.R:2707
#, c-format
msgid "before=/after= accept a single column name or number, not more than one"
msgstr ""
"before=/after= aceptar un solo nombre de columna o número, no más de uno"

#: data.table.R:2763
#, c-format
msgid "Input is %s but should be a plain list of items to be stacked"
msgstr ""
"La entrada es %s pero debería ser una lista simple de elementos a apilar"

#: data.table.R:2767
#, c-format
msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the "
"id column will named '.id'."
msgstr ""
"idcol debe ser un vector lógico o de caracteres de longitud 1. Si es TRUE "
"lógico, la columna de identificación se llamará '.id'."

#: data.table.R:2772
#, c-format
msgid "use.names=NA invalid"
msgstr "use.names=NA no válido"

#: data.table.R:2774
#, c-format
msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new "
"in v1.12.2 and subject to change. It is just meant to convey default "
"behavior. See ?rbindlist."
msgstr ""
"use.names='check' no se puede usar explícitamente porque el valor 'check' es "
"nuevo en v1.12.2 y está sujeto a cambios. Simplemente está destinado a "
"transmitir un comportamiento predeterminado. Consulte ?rbindlist."

#: data.table.R:2806
#, c-format
msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr ""
"setDF solo acepta data.table, data.frame o lista de igual longitud como "
"entrada"

#: data.table.R:2807
#, c-format
msgid "rownames contains duplicates"
msgstr "rownames contiene duplicados"

#: data.table.R:2814 data.table.R:2825 data.table.R:2848
#, c-format
msgid "rownames incorrect length; expected %d names, got %d"
msgstr ""
"rownames de longitud incorrecta; %d nombres esperados, se obtuvieron %d"

#: data.table.R:2833
#, c-format
msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr ""
"Todos los elementos del argumento 'x' a 'setDF' deben tener la misma longitud"

#: data.table.R:2862
#, c-format
msgid "Cannot find symbol %s"
msgstr "No se puede encontrar el símbolo %s"

#: data.table.R:2869
#, c-format
msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. "
"It is very likely that '%1$s' resides within a package (or an environment) "
"that is locked to prevent modifying its variable bindings. Try copying the "
"object to your current environment, ex: var <- copy(var) and then using "
"setDT again."
msgstr ""
"No se puede convertir '%1$s' a data.table por referencia porque el "
"vinculación (binding) está bloqueado. Es muy probable que '%1$s' resida "
"dentro de un paquete (o entorno) que esté bloqueado para evitar modificar "
"sus vinculaciones de nombres de variables. Intente copiar el objeto a su "
"entorno actual, por ejemplo: var <- copy(var) y luego use setDT nuevamente."

#: data.table.R:2922
#, c-format
msgid ""
"Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""
"El argumento 'x' a 'setDT' debe ser 'list', 'data.frame' o 'data.table'"

#: data.table.R:2937
#, c-format
msgid "Item '%s' not found in names of input list"
msgstr "El elemento '%s' no se encuentra en los nombres de la lista de entrada"

#: data.table.R:2962 data.table.R:2987
#, c-format
msgid "'prefix' must be NULL or a character vector of length 1."
msgstr "'prefix' debe ser NULL o un vector de caracteres de longitud 1."

#: data.table.R:2965 data.table.R:2990
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr "x es un vector único, 'cols' no NULL no tiene sentido."

#: data.table.R:2969 data.table.R:2994
#, c-format
msgid "x is a list, 'cols' cannot be 0-length."
msgstr "x es una lista, 'cols' no puede tener una longitud de 0."

#: data.table.R:3185
#, c-format
msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""
"RHS de %s tiene una longitud %d que no es 1 ni nrow (%d). Por razones de "
"robustez, no se permite ningún reciclaje (excepto el de longitud 1 RHS). "
"Considere %%in%% en su lugar."

#: data.table.R:3300
#, c-format
msgid ""
"'on' argument should be a named atomic vector of column names indicating "
"which columns in 'i' should be joined with which columns in 'x'."
msgstr ""
"El argumento >>'on' debe ser un vector atómico con nombre de nombres de "
"columnas que indique qué columnas en 'i' deben unirse con qué columnas en "
"'x'."

#: data.table.R:3341
#, c-format
msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr ""
"Se encontró más de un operador en una declaración 'on': %s. Por favor "
"especifique un solo operador."

#: data.table.R:3364
#, c-format
msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr ""
"'on' no contiene ningún nombre de columna: %s. Cada cláusula 'on' debe "
"contener uno o dos nombres de columna."

#: data.table.R:3366
#, c-format
msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain "
"one or two column names."
msgstr ""
"'on' contiene más de 2 nombres de columnas: %s. Cada cláusula 'on' debe "
"contener uno o dos nombres de columna."

#: data.table.R:3371
#, c-format
msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr ""
"Operadores de unión no válidos %s. Los únicos operadores permitidos son %s."

#: devel.R:16
#, c-format
msgid "There is no package %s in provided repository."
msgstr "No hay ningún paquete %s en el repositorio proporcionado."

#: duplicated.R:7
#, c-format
msgid "'fromLast' must be TRUE or FALSE"
msgstr "'fromLast' debe ser TRUE o FALSE"

#: duplicated.R:105
#, c-format
msgid "x must be an atomic vector or data.frames/data.tables"
msgstr "x debe ser un vector atómico o data.frames/data.tables"

#: fcast.R:7
#, c-format
msgid "Using '%s' as value column. Use 'value.var' to override"
msgstr "Usando '%s' como columna de valor. Utilice 'value.var' para anular"

#: fcast.R:20 fmelt.R:16
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s, but data.table::%1$s "
"currently only has a method for data.tables. Please confirm your input is a "
"data.table, with setDT(%3$s) or as.data.table(%3$s). If you intend to use a "
"method from reshape2, try installing that package first, but do note that "
"reshape2 is superseded and is no longer actively developed."
msgstr ""
"Al %1$s genérico en data.table se le ha pasado %2$s, pero data.table::%1$s "
"actualmente solo tiene un método para data.tables. Confirme que su entrada "
"es data.table, con setDT(%3$s) o as.data.table(%3$s). Si tiene la intención "
"de utilizar un método de reshape2, intente instalar ese paquete primero, "
"pero tenga en cuenta que reshape2 ha sido reemplazado y ya no se desarrolla "
"activamente."

#: fcast.R:21
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. Please do this redirection yourself like reshape2::%1$s(%3$s). "
"In the next version, this warning will become an error."
msgstr ""
"Al %1$s genérico en data.table se le ha pasado un %2$s e intentará redirigir "
"al método reshape2 relevante; tenga en cuenta que reshape2 ha sido "
"reemplazado y ya no se desarrolla activamente, y esta redirección ahora está "
"obsoleta. Realice esta redirección usted mismo como reshape2::%1$s(%3$s). En "
"la próxima versión, esta advertencia se convertirá en un error."

#: fcast.R:31
#, c-format
msgid ""
"Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + "
"b ~ c."
msgstr ""
"Fórmula no válida. La fórmula moldeada debe tener la forma LHS ~ RHS, por "
"ejemplo, a + b ~ c."

#: fcast.R:38
#, c-format
msgid "data.table to cast must have unique column names"
msgstr "data.table para transmitir debe tener nombres de columna únicos"

#: fcast.R:83
#, c-format
msgid "value.var values %s are not found in 'data'."
msgstr "valores de value.var %s no se encuentran en 'data'."

#: fcast.R:99
#, c-format
msgid ""
"When 'fun.aggregate' and 'value.var' are both lists, 'value.var' must be "
"either of length =1 or =length(fun.aggregate)."
msgstr ""
"Cuando 'fun.aggregate' y 'value.var' son listas, 'value.var' debe tener "
"length =1 o =length(fun.aggregate)."

#: fcast.R:132
#, c-format
msgid "'data' must be a data.table."
msgstr "'data' debe ser una data.table."

#: fcast.R:134
#, c-format
msgid "'drop' must be logical TRUE/FALSE"
msgstr "'drop' debe ser lógico TRUE/FALSE"

#: fcast.R:136
#, c-format
msgid "Argument 'value.var.in.dots' should be logical TRUE/FALSE"
msgstr "El argumento 'value.var.in.dots' debe ser TRUE/FALSE lógico"

#: fcast.R:138
#, c-format
msgid ""
"Arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' should be logical "
"TRUE/FALSE"
msgstr ""
"Los argumentos 'value.var.in.LHSdots', 'value.var.in.RHSdots' deben ser TRUE/"
"FALSE lógico"

#: fcast.R:155
#, c-format
msgid "Column [%s] not found or of unknown type."
msgstr "Columna [%s] no encontrada o de tipo desconocido."

#: fcast.R:170
#, c-format
msgid "Columns specified in formula can not be of type list"
msgstr "Las columnas especificadas en la fórmula no pueden ser de tipo lista"

#: fcast.R:185
#, c-format
msgid ""
"'fun.aggregate' is NULL, but found duplicate row/column combinations, so "
"defaulting to length(). That is, the variables %s used in 'formula' do not "
"uniquely identify rows in the input 'data'. In such cases, 'fun.aggregate' "
"is used to derive a single representative value for each combination in the "
"output data.table, for example by summing or averaging (fun.aggregate=sum or "
"fun.aggregate=mean, respectively). Check the resulting table for values "
"larger than 1 to see which combinations were not unique. See ?dcast.data."
"table for more details."
msgstr ""
"'fun.aggregate' es NULL, pero encontró combinaciones de fila/columna "
"duplicadas, por lo que se usa length() de manera predeterminada. Es decir, "
"las variables %s utilizadas en 'formula' no identifican de manera única las "
"filas en la entrada 'data'. En tales casos, 'fun.aggregate' se utiliza para "
"derivar un único valor representativo para cada combinación en la tabla de "
"datos de salida, por ejemplo, sumando o promediando (fun.aggregate=sum o fun."
"aggregate=mean, respectivamente). Verifique la tabla resultante para ver si "
"hay valores mayores que 1 para ver qué combinaciones no fueron únicas. "
"Consulte ?dcast.data.table para obtener más detalles."

#: fcast.R:195
msgid ""
"Aggregating function(s) should take a vector as input and return a single "
"value (length=1), but they do not, so the result is undefined. Please fix by "
"modifying your function so that a single value is always returned."
msgstr ""
"Las funciones de agregación deberían tomar un vector como entrada y devolver "
"un único valor (longitud 1) pero no lo hacen, por lo tanto el resultado no "
"está definido. Por favor, corrija modificando su función, de modo que "
"siempre devuelva un único valor."

#: fdroplevels.R:13
#, c-format
msgid ""
"droplevels() with in.place=TRUE is deprecated. Use setdroplevels() instead."
msgstr ""
"droplevels() con in.place=TRUE es obsoleto. Use setdroplevels() en su lugar."

#: fmelt.R:17
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. To continue using melt methods from reshape2 while both "
"libraries are attached, e.g. melt.list, you can prepend the namespace, i.e. "
"reshape2::%1$s(%3$s). In the next version, this warning will become an error."
msgstr ""
"Al %1$s genérico en data.table se le ha pasado un %2$s e intentará redirigir "
"al método reshape2 relevante; tenga en cuenta que reshape2 ha sido "
"reemplazado y ya no se desarrolla activamente, y esta redirección ahora está "
"obsoleta. Para continuar usando métodos de fusión de reshape2 mientras ambas "
"bibliotecas están adjuntas, p. melt.list, puede anteponer el espacio de "
"nombres, es decir, reshape2::%1$s(%3$s). En la próxima versión, esta "
"advertencia se convertirá en un error."

#: fmelt.R:28
#, c-format
msgid "Input patterns must be of type character."
msgstr "Los patrones de entrada deben ser de tipo carácter."

#: fmelt.R:31
#, c-format
msgid "Pattern(s) not found: [%s]"
msgstr "Patrones no encontrados: [%s]"

#: fmelt.R:46
#, c-format
msgid ""
"each ... argument to measure must be either a symbol without argument name, "
"or a function with argument name, problems: %s"
msgstr ""
"cada... argumento a medir debe ser un símbolo sin nombre de argumento, o una "
"función con nombre de argumento, problemas: %s"

#: fmelt.R:54
#, c-format
msgid ""
"group names specified in ... conflict with measure argument names; please "
"fix by changing group names: %s"
msgstr ""
"los nombres de grupo especificados en ... entran en conflicto con los "
"nombres de los argumentos de medida; por favor solucione cambiando los "
"nombres de los grupos: %s"

#: fmelt.R:60
#, c-format
msgid ""
"each ... argument to measure must be a function with at least one argument, "
"problem: %s"
msgstr ""
"cada... argumento a medir debe ser una función con al menos un argumento, "
"problema: %s"

#: fmelt.R:74
#, c-format
msgid ""
"both sep and pattern arguments used; must use either sep or pattern (not "
"both)"
msgstr "se utilizan argumentos sep y patrón; debe usar sep o patrón (no ambos)"

#: fmelt.R:77
#, c-format
msgid "multiple.keyword must be a character string with nchar>0"
msgstr "multiple.keyword debe ser una cadena de caracteres con nchar>0"

#: fmelt.R:80
#, c-format
msgid "cols must be a character vector of column names"
msgstr "cols debe ser un vector de caracteres de nombres de columnas"

#: fmelt.R:88
#, c-format
msgid "in measurev, %s must be named, problems: %s"
msgstr "en medidav, se debe nombrar %s, problemas: %s"

#: fmelt.R:94
#, c-format
msgid "%s should be uniquely named, problems: %s"
msgstr "%s debe tener un nombre único, problemas: %s"

#: fmelt.R:99
#, c-format
msgid "number of %s =%d must be same as %s =%d"
msgstr "el número de %s =%d debe ser el mismo que %s =%d"

#: fmelt.R:106
#, c-format
msgid "pattern must be character string"
msgstr "el patrón debe ser una cadena de caracteres"

#: fmelt.R:111
#, c-format
msgid ""
"pattern did not match any cols, so nothing would be melted; fix by changing "
"pattern"
msgstr ""
"el patrón no coincidía con ninguna columna, por lo que no se remodelará "
"nada; arreglar cambiando el patrón"

#: fmelt.R:115
#, c-format
msgid ""
"pattern must contain at least one capture group (parenthesized sub-pattern)"
msgstr ""
"el patrón debe contener al menos un grupo de captura (subpatrón entre "
"paréntesis)"

#: fmelt.R:124
#, c-format
msgid "sep must be character string"
msgstr "sep debe ser una cadena de caracteres"

#: fmelt.R:130
#, c-format
msgid ""
"each column name results in only one item after splitting using sep, which "
"means that all columns would be melted; to fix please either specify melt on "
"all columns directly without using measure, or use a different sep/pattern "
"specification"
msgstr ""
"cada nombre de columna da como resultado solo un elemento después de dividir "
"usando sep, lo que significa que todas las columnas se fusionarían; Para "
"solucionarlo, especifique la fusión en todas las columnas directamente sin "
"usar la medida o use una especificación de patrón/separador diferente."

#: fmelt.R:140
#, c-format
msgid ""
"number of unique column IDs =%d is less than number of melted columns =%d; "
"fix by changing pattern/sep"
msgstr ""
"el número de ID de columna únicos =%d es menor que el número de columnas "
"remodeladas =%d; arreglar cambiando patrón/sep"

#: fmelt.R:150
#, c-format
msgid ""
"in the measurev fun.list, each non-NULL element must be a function with at "
"least one argument, problem: %s"
msgstr ""
"en fun.list de measurev, cada elemento no NULL debe ser una función con al "
"menos un argumento, problema: %s"

#: fmelt.R:154
#, c-format
msgid ""
"each conversion function must return an atomic vector with same length as "
"its first argument, problem: %s"
msgstr ""
"cada función de conversión debe devolver un vector atómico con la misma "
"longitud que su primer argumento, problema: %s"

#: fmelt.R:157
#, c-format
msgid "%s conversion function returned vector of all NA"
msgstr "La función de conversión %s devolvió el vector de todos los NA"

#: fmelt.R:163
#, c-format
msgid ""
"number of unique groups after applying type conversion functions less than "
"number of groups, change type conversion"
msgstr ""
"número de grupos únicos después de aplicar funciones de conversión de tipo "
"menor que el número de grupos, cambiar la conversión de tipo"

#: fmelt.R:168
#, c-format
msgid ""
"%s column class=%s after applying conversion function, but must be character"
msgstr ""
"columna %s de clase=%s después de aplicar la función de conversión, pero "
"debe ser de carácter"

#: fmelt.R:172
#, c-format
msgid "%s is the only group; fix by creating at least one more group"
msgstr "%s es el único grupo; arréglelo creando al menos un grupo más"

#: fmelt.R:195
#, c-format
msgid "'data' must be a data.table"
msgstr "'data' debe ser una data.table"

#: fmelt.R:214
#, c-format
msgid ""
"'value.name' provided in both 'measure.vars' and 'value.name argument'; "
"value provided in 'measure.vars' is given precedence."
msgstr ""
"'value.name' proporcionado tanto en 'measure.vars' como en argumento 'value."
"name'; el valor proporcionado en 'measure.vars' tiene prioridad."

#: fmelt.R:217
#, c-format
msgid "Please provide a name to each element of 'measure.vars'."
msgstr "Proporcione un nombre para cada elemento de 'measure.vars'."

#: foverlaps.R:3
#, c-format
msgid ""
"y and x must both be data.tables. Use `setDT()` to convert list/data.frames "
"to data.tables by reference or as.data.table() to convert to data.tables by "
"copying."
msgstr ""
"'y' y 'x' deben ser tablas de datos. Utilice `setDT()` para convertir list/"
"data.frames a data.tables por referencia o as.data.table() para convertir a "
"data.tables copiando."

#: foverlaps.R:9
#, c-format
msgid "maxgap must be a non-negative integer value of length 1"
msgstr "maxgap debe ser un valor entero no negativo de longitud 1"

#: foverlaps.R:11
#, c-format
msgid "minoverlap must be a positive integer value of length 1"
msgstr "minoverlap debe ser un valor entero positivo de longitud 1"

#: foverlaps.R:13
#, c-format
msgid "which must be a logical vector of length 1. Either TRUE/FALSE"
msgstr "que debe ser un vector lógico de longitud 1. Ya sea TRUE/FALSE"

#: foverlaps.R:15
#, c-format
msgid "nomatch must either be NA or NULL"
msgstr "nomatch debe ser NA o NULL"

#: foverlaps.R:20
#, c-format
msgid "maxgap and minoverlap arguments are not yet implemented."
msgstr "Los argumentos maxgap y minoverlap aún no se han implementado."

#: foverlaps.R:22
#, c-format
msgid ""
"y must be keyed (i.e., sorted, and, marked as sorted). Call setkey(y, ...) "
"first, see ?setkey. Also check the examples in ?foverlaps."
msgstr ""
"'y' debe tener una clave (es decir, ordenada y marcada como ordenada). Llame "
"primero a setkey(y, ...), consulte ?setkey. Consulte también los ejemplos "
"en ?foverlaps."

#: foverlaps.R:24
#, c-format
msgid ""
"'by.x' and 'by.y' should contain at least two column names (or numbers) each "
"- corresponding to 'start' and 'end' points of intervals. Please see ?"
"foverlaps and examples for more info."
msgstr ""
"'by.x' y 'by.y' deben contener al menos dos nombres de columna (o números) "
"cada uno, correspondientes a los puntos 'start' y 'end' de intervalos. "
"Consulte Foverlaps y ejemplos para obtener más información."

#: foverlaps.R:27
#, c-format
msgid ""
"Invalid numeric value for 'by.x'; it should be a vector with values 1 <= by."
"x <= length(x)"
msgstr ""
"Valor numérico no válido para 'by.x'; debería ser un vector con valores 1 <= "
"by.x <= length(x)"

#: foverlaps.R:32
#, c-format
msgid ""
"Invalid numeric value for 'by.y'; it should be a vector with values 1 <= by."
"y <= length(y)"
msgstr ""
"Valor numérico no válido para 'by.y'; debería ser un vector con valores 1 <= "
"by.y <= length(y)"

#: foverlaps.R:36
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.x"
msgstr ""
"Se requiere un vector no vacío de nombres de columnas o números para by.x"

#: foverlaps.R:38
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.y"
msgstr ""
"Se requiere un vector no vacío de nombres de columnas o números para by.y"

#: foverlaps.R:40
#, c-format
msgid ""
"The first %d columns of y's key must be identical to the columns specified "
"in by.y."
msgstr ""
"Las primeras %d columnas de la clave de y deben ser idénticas a las columnas "
"especificadas en by.y."

#: foverlaps.R:42
#, c-format
msgid "Elements listed in 'by.x' must be valid names in data.table x"
msgstr ""
"Los elementos enumerados en 'by.x' deben ser nombres válidos en data.table x"

#: foverlaps.R:44
#, c-format
msgid ""
"Duplicate columns are not allowed in overlap joins. This may change in the "
"future."
msgstr ""
"No se permiten columnas duplicadas en uniones superpuestas. Esto puede "
"cambiar en el futuro."

#: foverlaps.R:46
#, c-format
msgid ""
"length(by.x) != length(by.y). Columns specified in by.x should correspond to "
"columns specified in by.y and should be of same lengths."
msgstr ""
"length(por.x) != length(por.y). Las columnas especificadas en by.x deben "
"corresponder a las columnas especificadas en by.y y deben tener la misma "
"length."

#: foverlaps.R:48 foverlaps.R:50 merge.R:26 merge.R:27
#, c-format
msgid ""
"%s has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr ""
"%s tiene algunos nombres de columna duplicados: %s. Elimine o cambie el "
"nombre de los duplicados e inténtelo de nuevo."

#: foverlaps.R:56
#, c-format
msgid ""
"The last two columns in by.x should correspond to the 'start' and 'end' "
"intervals in data.table x and must be integer/numeric type."
msgstr ""
"Las dos últimas columnas en by.x deben corresponder a los intervalos 'start' "
"y 'end' en data.table x y deben ser de tipo entero/numérico."

#: foverlaps.R:60 foverlaps.R:62 foverlaps.R:69 foverlaps.R:71
#, c-format
msgid ""
"NA values in data.table %s '%s' column: '%s'. All rows with NA values in the "
"range columns must be removed for foverlaps() to work."
msgstr ""
"Valores NA en la columna data.table %s '%s': '%s'. Todas las filas con "
"valores NA en las columnas de rango deben eliminarse para que funcione "
"foverlaps()."

#: foverlaps.R:63
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table x."
msgstr ""
"Todas las entradas en la columna '%s' deben ser <= entradas correspondientes "
"en la columna '%s' en data.table x."

#: foverlaps.R:66
#, c-format
msgid ""
"The last two columns in by.y should correspond to the 'start' and 'end' "
"intervals in data.table y and must be integer/numeric type."
msgstr ""
"Las dos últimas columnas en by.y deben corresponder a los intervalos 'start' "
"y 'end' en data.table y y deben ser de tipo entero/numérico."

#: foverlaps.R:72
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table y."
msgstr ""
"Todas las entradas en la columna '%s' edeben ser <= a las entradas "
"correspondientes en las columnas '%s' en la data.table y."

#: foverlaps.R:77
#, c-format
msgid ""
"Some interval cols are of type POSIXct while others are not. Please ensure "
"all interval cols are (or are not) of POSIXct type"
msgstr ""
"Algunas columnas de intervalo son de tipo POSIXct mientras que otras no. "
"Asegúrese de que todas las columnas de intervalo sean (o no sean) de tipo "
"POSIXct"

#: foverlaps.R:83
#, c-format
msgid ""
"POSIXct interval cols have mixed timezones. Overlaps are performed on the "
"internal numerical representation of POSIXct objects (always in UTC epoch "
"time), therefore printed values may give the impression that values don't "
"overlap but their internal representations do Please ensure that POSIXct "
"type interval cols have identical 'tzone' attributes to avoid confusion."
msgstr ""
"Las columnas de intervalo POSIXct tienen zonas horarias mixtas. Las "
"superposiciones se realizan en la representación numérica interna de los "
"objetos POSIXct (siempre en la época UTC), por lo tanto, los valores "
"impresos pueden dar la impresión de que los valores no se superponen, pero "
"sus representaciones internas sí. Asegúrese de que las columnas de intervalo "
"de tipo POSIXct tengan atributos 'tzone' idénticos, para evitar confusiones."

#: foverlaps.R:164 foverlaps.R:166 foverlaps.R:170
#, c-format
msgid "Not yet implemented"
msgstr "Aún no implementado"

#: foverlaps.R:169
#, c-format
msgid "maxgap > minoverlap. maxgap will have no effect here."
msgstr "maxgap > minoverlap. maxgap no tendrá ningún efecto aquí."

#: frank.R:3
#, c-format
msgid "length(na.last) = 0"
msgstr "length(na.last) = 0"

#: frank.R:5
#, c-format
msgid "length(na.last) > 1, only the first element will be used"
msgstr "length(na.last) > 1, sólo se utilizará el primer elemento"

#: frank.R:17
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense"
msgstr "x es un vector único, 'cols' no NULL no tiene sentido"

#: frank.R:23
#, c-format
msgid "x is a list, 'cols' can not be 0-length"
msgstr "x es una lista, 'cols' no puede tener longitud 0"

#: frank.R:31
#, c-format
msgid ""
"Input column '..na_prefix..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"La columna de entrada '..na_prefix..' entra en conflicto con el uso interno "
"de data.table; por favor cambie el nombre"

#: frank.R:46
#, c-format
msgid ""
"Input column '..stats_runif..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"La columna de entrada '..stats_runif..' entra en conflicto con el uso "
"interno de data.table; por favor cambie el nombre"

#: fread.R:10
#, c-format
msgid "Used more than one of the arguments input=, file=, text= and cmd=."
msgstr "Utilizó más de uno de los argumentos input=, file=, text= y cmd=."

#: fread.R:23
#, c-format
msgid "Argument 'encoding' must be 'unknown', 'UTF-8' or 'Latin-1'."
msgstr "El argumento 'encoding' debe ser 'unknown', 'UTF-8' o 'Latin-1 '."

#: fread.R:42
#, c-format
msgid "'text=' is type %s but must be character."
msgstr "'text=' es de tipo %s pero debe ser un carácter."

#: fread.R:55
#, c-format
msgid ""
"input= must be a single character string containing a file name, a system "
"command containing at least one space, a URL starting 'http[s]://', "
"'ftp[s]://' or 'file://', or, the input data itself containing at least one "
"\\n or \\r"
msgstr ""
"input= debe ser una cadena de un solo carácter que contenga un nombre de "
"archivo, un comando del sistema que contenga al menos un espacio, una URL "
"que comience con 'http[s]://', ​​'ftp[s]://' o 'file: //', o los datos de "
"entrada que contienen al menos un \\n o \\r"

#: fread.R:60
#, c-format
msgid ""
"input= contains no \\n or \\r, but starts with a space. Please remove the "
"leading space, or use text=, file= or cmd="
msgstr ""
"input= no contiene \\n o \\r, pero comienza con un espacio. Elimine el "
"espacio inicial o utilice text=, file= o cmd="

#: fread.R:64
#, c-format
msgid ""
"Taking input= as a system command because it contains a space ('%s'). If "
"it's a filename please remove the space, or use file= explicitly. A variable "
"is being passed to input= and when this is taken as a system command there "
"is a security concern if you are creating an app, the app could have a "
"malicious user, and the app is not running in a secure environment; e.g. the "
"app is running as root. Please read item 5 in the NEWS file for v1.11.6 for "
"more information and for the option to suppress this message."
msgstr ""
"Tomando input= como comando del sistema porque contiene un espacio ('%s'). "
"Si es un nombre de archivo, elimine el espacio o use file= explícitamente. "
"Se pasa una variable a input= y cuando se toma como un comando del sistema, "
"existe un problema de seguridad si está creando una aplicación, la "
"aplicación podría tener un usuario malintencionado y la aplicación no se "
"ejecuta en un entorno seguro; p.ej. la aplicación se ejecuta como root. Lea "
"el elemento 5 en el archivo NEWS de v1.11.6 para obtener más información y "
"conocer la opción de suprimir este mensaje."

#: fread.R:77
#, c-format
msgid ""
"file= must be a single character string containing a filename, or URL "
"starting 'http[s]://', 'ftp[s]://' or 'file://'"
msgstr ""
"file= debe ser una cadena de un solo carácter que contenga un nombre de "
"archivo o una URL que comience con 'http[s]://', ​​'ftp[s]://' o 'file://'"

#: fread.R:90
#, c-format
msgid "File '%s' does not exist or is non-readable. getwd()=='%s'"
msgstr "El archivo '%s' no existe o no es legible. getwd()=='%s'"

#: fread.R:91
#, c-format
msgid "File '%s' is a directory. Not yet implemented."
msgstr "El archivo '%s' es un directorio. Aun no implementado."

#: fread.R:93
#, c-format
msgid "File '%s' has size 0. Returning a NULL %s."
msgstr "El archivo '%s' tiene tamaño 0. Devolviendo un %s NULL."

#: fread.R:105
#, c-format
msgid ""
"Compressed files containing more than 1 file are currently not supported."
msgstr ""
"Actualmente no se admiten archivos comprimidos que contengan más de 1 "
"archivo."

#: fread.R:125
#, c-format
msgid ""
"'autostart' is now deprecated and ignored. Consider skip='string' or skip=n"
msgstr ""
"'autostart' ahora está obsoleto y se ignora. Considere skip='string' o skip=n"

#: fread.R:127
#, c-format
msgid ""
"colClasses is type 'logical' which is ok if all NA but it has some TRUE or "
"FALSE values in it which is not allowed. Please consider the drop= or "
"select= argument instead. See ?fread."
msgstr ""
"colClasses es de tipo 'logical', lo cual está bien si todo es NA, pero tiene "
"algunos valores TRUE o FALSE, lo que no está permitido. Considere el "
"argumento drop= o select= en su lugar. Ver ?fread."

#: fread.R:131
#, c-format
msgid "colClasses is not type list or character vector"
msgstr "colClasses no es una lista de tipos ni un vector de caracteres"

#: fread.R:136
#, c-format
msgid ""
"colClasses=\"NULL\" (quoted) is interpreted as colClasses=NULL (the default) "
"as opposed to dropping every column."
msgstr ""
"colClasses=\"NULL\" (entre comillas) se interpreta como colClasses=NULL (el "
"valor predeterminado) en lugar de eliminar todas las columnas."

#: fread.R:148
#, c-format
msgid "na.strings[%d]==\"%s\" consists only of whitespace, ignoring"
msgstr "na.strings[%d]==\"%s\" consta solo de espacios en blanco, ignorando"

#: fread.R:151
#, c-format
msgid ""
"%s. Since strip.white=TRUE (default), use na.strings=\"\" to specify that "
"any number of spaces in a string column should be read as <NA>."
msgstr ""
"%s. Dado que strip.white=TRUE (predeterminado), use na.strings=\"\" para "
"especificar que cualquier número de espacios en una columna de cadena debe "
"leerse como <NA>."

#: fread.R:153
#, c-format
msgid ""
"%s. strip.white==TRUE (default) and \"\" is present in na.strings, so any "
"number of spaces in string columns will already be read as <NA>."
msgstr ""
"%s. strip.white==TRUE (predeterminado) y \"\" está presente en na.strings, "
"por lo que cualquier número de espacios en las columnas de cadena ya se "
"leerán como <NA>."

#: fread.R:157
#, c-format
msgid ""
"%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with na."
"strings=\"\" to turn any number of spaces in string columns into <NA>"
msgstr ""
"%s. Pero strip.white=FALSE. Utilice strip.white=TRUE (predeterminado) junto "
"con na.strings=\"\" para convertir cualquier número de espacios en columnas "
"de cadena en <NA>"

#: fread.R:163
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to parse the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' se basa en el paquete 'yaml' para analizar el encabezado del "
"archivo; agréguelo a su biblioteca con install.packages('yaml') e inténtelo "
"de nuevo."

#: fread.R:167
#, c-format
msgid ""
"Combining a search string as 'skip' and reading a YAML header may not work "
"as expected -- currently, reading will proceed to search for 'skip' from the "
"beginning of the file, NOT from the end of the metadata; please file an "
"issue on GitHub if you'd like to see more intuitive behavior supported."
msgstr ""
"Combinar una cadena de búsqueda como 'skip' y leer un encabezado YAML puede "
"no funcionar como se esperaba; actualmente, la lectura procederá a buscar "
"'skip' desde el principio. del archivo, NO desde el final de los metadatos; "
"Presente un problema en GitHub si desea que se admita un comportamiento más "
"intuitivo."

#: fread.R:177
#, c-format
msgid ""
"Encountered <%s%s> at the first unskipped line (%d), which does not "
"constitute the start to a valid YAML header (expecting something matching "
"regex \"%s\"); please check your input and try again."
msgstr ""
"Se encontró <%s%s> en la primera línea no omitida (%d), que no constituye el "
"inicio de un encabezado YAML válido (se esperaba algo que coincida con la "
"expresión regular \"%s\"); por favor verifique su entrada e inténtelo "
"nuevamente."

#: fread.R:189
#, c-format
msgid ""
"Reached the end of the file before finding a completion to the YAML header. "
"A valid YAML header is bookended by lines matching the regex \"%s\". Please "
"double check the input file is a valid csvy."
msgstr ""
"Se llegó al final del archivo antes de encontrar una finalización del "
"encabezado YAML. Un encabezado YAML válido está delimitado por líneas que "
"coinciden con la expresión regular \"%s\". Verifique que el archivo de "
"entrada sea un csvy válido."

#: fread.R:203
#, c-format
msgid "User-supplied 'header' will override that found in metadata."
msgstr ""
"'header' proporcionado por el usuario reemplazará al que se encuentra en los "
"metadatos."

#: fread.R:221
#, c-format
msgid ""
"User-supplied column names in 'col.names' will override those found in YAML "
"metadata."
msgstr ""
"Los nombres de columnas proporcionados por el usuario en 'col.names' "
"reemplazarán los que se encuentran en los metadatos YAML."

#: fread.R:230
#, c-format
msgid ""
"colClasses dictated by user input and those read from YAML header are in "
"conflict (specifically, for column(s) [%s]); the proceeding assumes the user "
"input was an intentional override and will ignore the type(s) implied by the "
"YAML header; please exclude the column(s) from colClasses if this was "
"unintentional."
msgstr ""
"colClasses dictadas por la entrada del usuario y las leídas del encabezado "
"YAML están en conflicto (específicamente, para las columnas [%s]); el "
"procedimiento supone que la entrada del usuario fue un reemplazo intencional "
"e ignorará los tipos implícitos en el encabezado YAML; excluya las columnas "
"de colClasses si esto no fue intencional."

#: fread.R:251
#, c-format
msgid "User-supplied 'sep' will override that found in metadata."
msgstr ""
"'sep' proporcionado por el usuario reemplazará el que se encuentra en los "
"metadatos."

#: fread.R:256
#, c-format
msgid "User-supplied 'quote' will override that found in metadata."
msgstr ""
"'quote' proporcionado por el usuario reemplazará el que se encuentra en los "
"metadatos."

#: fread.R:261
#, c-format
msgid "User-supplied 'dec' will override that found in metadata."
msgstr ""
"'dec' proporcionado por el usuario reemplazará el que se encuentra en los "
"metadatos."

#: fread.R:265
#, c-format
msgid "User-supplied 'na.strings' will override that found in metadata."
msgstr ""
"'na.strings' proporcionado por el usuario reemplazará el que se encuentra en "
"los metadatos."

#: fread.R:314
#, c-format
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"%s:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"Se solicitó que la columna '%s' fuera '%s' pero fread encontró el siguiente "
"%s:\n"
"\t%s\n"
"por lo que la columna se dejó como tipo '%s'"

#: fread.R:337
#, c-format
msgid ""
"key argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""
"el argumento key de data.table() debe ser un vector de caracteres que nombra "
"las columnas (nótese que col.names se aplica antes de esto)"

#: fread.R:345
#, c-format
msgid ""
"index argument of data.table() must be a character vector naming columns "
"(NB: col.names are applied before this)"
msgstr ""
"el argumento de índice de data.table() debe ser un vector de caracteres que "
"nombra columnas (nótese que col.names se aplican antes de esto)"

#: fwrite.R:19
#, c-format
msgid "Argument 'encoding' must be '', 'UTF-8' or 'native'."
msgstr "El argumento 'encoding' debe ser '', 'UTF-8' o 'native'."

#: fwrite.R:24
#, c-format
msgid "dateTimeAs must be a single string"
msgstr "dateTimeAs debe ser una sola cadena"

#: fwrite.R:26
#, c-format
msgid "dateTimeAs must be 'ISO','squash','epoch' or 'write.csv'"
msgstr "dateTimeAs debe ser 'ISO','squash','epoch' o 'write.csv'"

#: fwrite.R:28
#, c-format
msgid "logicalAsInt has been renamed logical01. Use logical01 only, not both."
msgstr ""
"logicAsInt ha pasado a llamarse logic01. Utilice sólo logic01, no ambos."

#: fwrite.R:30
#, c-format
msgid ""
"logicalAsInt has been renamed logical01 for consistency with fread. It works "
"fine for now but please change to logical01 at your convenience so we can "
"remove logicalAsInt in future."
msgstr ""
"logicAsInt ha sido renombrado como logic01 para mantener la coherencia con "
"fread. Funciona bien por ahora, pero cámbielo a logic01 cuando le resulte "
"conveniente para que podamos eliminar logicAsInt en el futuro."

#: fwrite.R:40
#, c-format
msgid "x being coerced from class: matrix to data.table"
msgstr "x siendo forzado de clase: matrix a data.table"

#: fwrite.R:85
#, c-format
msgid ""
"If you intended to overwrite the file at %s with an empty one, please use "
"file.remove first."
msgstr ""
"Si tenía la intención de sobrescribir el archivo en %s con uno vacío, use "
"file.remove primero."

#: fwrite.R:86
#, c-format
msgid "Input has no columns; doing nothing.%s"
msgstr "La entrada no tiene columnas; sin hacer nada.%s"

#: fwrite.R:89
#, c-format
msgid "Input has no columns; creating an empty file at '%s' and exiting."
msgstr ""
"La entrada no tiene columnas; creando un archivo vacío en '%s' y saliendo."

#: fwrite.R:96
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to write the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' se basa en el paquete 'yaml' para escribir el encabezado del "
"archivo; agregue esto a su biblioteca con install.packages('yaml') e "
"inténtelo nuevamente."

#: groupingsets.R:7 groupingsets.R:25 groupingsets.R:47
#, c-format
msgid "Argument 'x' must be a data.table object"
msgstr "El argumento 'x' debe ser un objeto data.table"

#: groupingsets.R:9 groupingsets.R:27 groupingsets.R:53
#, c-format
msgid ""
"Argument 'by' must be a character vector of column names used in grouping."
msgstr ""
"El argumento 'by' debe ser un vector de caracteres de los nombres de las "
"columnas utilizadas en la agrupación."

#: groupingsets.R:11 groupingsets.R:29 groupingsets.R:59
#, c-format
msgid "Argument 'id' must be a logical scalar."
msgstr "El argumento 'id' debe ser un escalar lógico."

#: groupingsets.R:31
#, c-format
msgid "Argument 'j' is required"
msgstr "Se requiere el argumento 'j'"

#: groupingsets.R:49
#, c-format
msgid ""
"Argument 'x' is a 0-column data.table; no measure to apply grouping over."
msgstr ""
"El argumento 'x' es una data.table de 0 columnas; no hay medida para aplicar "
"la agrupación."

#: groupingsets.R:51
#, c-format
msgid "Input data.table must not contain duplicate column names."
msgstr ""
"La data.table de entrada no debe contener nombres de columnas duplicados."

#: groupingsets.R:55
#, c-format
msgid "Argument 'by' must have unique column names for grouping."
msgstr ""
"El argumento 'by' debe tener nombres de columna únicos para la agrupación."

#: groupingsets.R:57
#, c-format
msgid "Argument 'sets' must be a list of character vectors."
msgstr "El argumento 'sets' debe ser una lista de vectores de caracteres."

#: groupingsets.R:62
#, c-format
msgid ""
"All columns used in 'sets' argument must be in 'by' too. Columns used in "
"'sets' but not present in 'by': %s"
msgstr ""
"Todas las columnas utilizadas en el argumento 'sets' también deben estar en "
"'by'. Columnas utilizadas en 'sets' pero no presentes en 'by': %s"

#: groupingsets.R:64
#, c-format
msgid ""
"When using `id=TRUE` the 'x' data.table must not have a column named "
"'grouping'."
msgstr ""
"Cuando se usa `id=TRUE`, la data.table 'x' no debe tener una columna llamada "
"'grouping'."

#: groupingsets.R:66
#, c-format
msgid ""
"Character vectors in 'sets' list must not have duplicated column names "
"within a single grouping set."
msgstr ""
"Los vectores de caracteres en la lista 'sets' no deben tener nombres de "
"columnas duplicados dentro de un único conjunto de agrupación."

#: groupingsets.R:68
#, c-format
msgid ""
"'sets' contains a duplicate (i.e., equivalent up to sorting) element at "
"index %d; as such, there will be duplicate rows in the output -- note that "
"grouping by A,B and B,A will produce the same aggregations. Use "
"`sets=unique(lapply(sets, sort))` to eliminate duplicates."
msgstr ""
"'sets' contiene un elemento duplicado (es decir, equivalente hasta la "
"clasificación) en el índice %d; como tal, habrá filas duplicadas en la "
"salida; tenga en cuenta que agrupar por A,B y B,A producirá las mismas "
"agregaciones. Utilice `sets=unique(lapply(sets, sort))` para eliminar "
"duplicados."

#: groupingsets.R:73
#, c-format
msgid ""
"Expression passed to grouping sets function must not update by reference. "
"Use ':=' on results of your grouping function."
msgstr ""
"La expresión pasada a la función groupingsets no debe actualizarse por "
"referencia. Utilice ':=' en los resultados de su función de agrupación."

#: groupingsets.R:80
#, c-format
msgid ""
"When using `id=TRUE` the 'j' expression must not evaluate to a column named "
"'grouping'."
msgstr ""
"Cuando se usa `id=TRUE`, la expresión 'j' no debe evaluarse como una columna "
"llamada 'grouping'."

#: groupingsets.R:82
#, c-format
msgid ""
"There exists duplicated column names in the results, ensure the column "
"passed/evaluated in `j` and those in `by` are not overlapping."
msgstr ""
"Existen nombres de columnas duplicados en los resultados, asegúrese de que "
"la columna aprobada/evaluada en `j` y las de `by` no se superpongan."

#: groupingsets.R:92
#, c-format
msgid ""
"Using integer64 class columns require to have 'bit64' package installed."
msgstr ""
"El uso de columnas de clase integer64 requiere tener instalado el paquete "
"'bit64'."

#: last.R:38 last.R:79
#, c-format
msgid ""
"'xts' class passed to %s function but 'xts' is not available, you should "
"have 'xts' installed already"
msgstr ""
"La clase 'xts' pasó a la función %s pero 'xts' no está disponible, ya "
"deberías tener 'xts' instalado"

#: merge.R:4
#, c-format
msgid "Argument 'sort' should be logical TRUE/FALSE"
msgstr "El argumento 'sort' debe ser lógico TRUE/FALSE"

#: merge.R:6
#, c-format
msgid "Argument 'no.dups' should be logical TRUE/FALSE"
msgstr "El argumento 'no.dups' debe ser lógico TRUE/FALSE"

#: merge.R:18
#, c-format
msgid "Neither of the input data.tables to join have columns."
msgstr "Ninguna de las data.tables de entrada para unir tiene columnas."

#: merge.R:20 merge.R:22
#, c-format
msgid "Input data.table '%s' has no columns."
msgstr "La data.table de entrada '%s' no tiene columnas."

#: merge.R:31
#, c-format
msgid "`by.x` and `by.y` must be of same length."
msgstr "`by.x` y `by.y` deben tener la misma longitud."

#: merge.R:33
#, c-format
msgid "Supplied both `by` and `by.x/by.y`. `by` argument will be ignored."
msgstr ""
"Se suministra tanto `by` como `by.x/by.y`. El argumento `by` será ignorado."

#: merge.R:36
#, c-format
msgid "A non-empty vector of column names is required for `by.x` and `by.y`."
msgstr ""
"Se requiere un vector no vacío de nombres de columnas para `by.x` y `by.y`."

#: merge.R:38
#, c-format
msgid "Elements listed in `by.x` must be valid column names in x."
msgstr ""
"Los elementos enumerados en `by.x` deben ser nombres de columna válidos en x."

#: merge.R:40
#, c-format
msgid "Elements listed in `by.y` must be valid column names in y."
msgstr ""
"Los elementos enumerados en `by.y` deben ser nombres de columna válidos en y."

#: merge.R:51
#, c-format
msgid "A non-empty vector of column names for `by` is required."
msgstr "Se requiere un vector no vacío de nombres de columnas para `por`."

#: merge.R:53
#, c-format
msgid "Elements listed in `by` must be valid column names in x and y"
msgstr ""
"Los elementos enumerados en `by` deben ser nombres de columna válidos en xey"

#: merge.R:61
#, c-format
msgid "Unknown argument '%s' has been passed."
msgstr "Se pasó el argumento desconocido '%s'."

#: merge.R:64
#, c-format
msgid "Passed %d unknown and unnamed arguments."
msgstr "Se aprobaron %d argumentos desconocidos y sin nombre."

#: merge.R:114
#, c-format
msgid "column names %s are duplicated in the result"
msgstr "los nombres de las columnas %s están duplicados en el resultado"

#: onAttach.R:23
#, c-format
msgid ""
"data.table %s IN DEVELOPMENT built %s%s using %d threads (see ?getDTthreads)."
msgstr ""
"data.table %s EN DESARROLLO compilación %s%s usando %d hilos (ver ?"
"getDTthreads)."

#: onAttach.R:25
#, c-format
msgid "data.table %s using %d threads (see ?getDTthreads)."
msgstr "data.table %s usando %d hilos (ver ?getDTthreads)."

#: onAttach.R:26
#, c-format
msgid "Latest news: r-datatable.com"
msgstr "Últimas novedades: r-datatable.com"

#: onAttach.R:27
msgid "TRANSLATION CHECK"
msgstr "VERIFICACIÓN DE TRADUCCIÓN"

#: onAttach.R:28
#, c-format
msgid ""
"**********\n"
"Running data.table in English; package support is available in English only. "
"When searching for online help, be sure to also check for the English error "
"message. This can be obtained by looking at the po/R-<locale>.po and po/"
"<locale>.po files in the package source, where the native language and "
"English error messages can be found side-by-side\n"
"**********"
msgstr ""
"**********\n"
"Ejecutando data.table en Español; El soporte del paquete está disponible "
"solo en inglés. Cuando busque ayuda en línea, asegúrese de comprobar también "
"el mensaje de error en inglés. Esto se puede obtener mirando los archivos po/"
"R-<locale>.po y po/<locale>.po en el código fuente del paquete, donde se "
"pueden encontrar los mensajes de error en el idioma nativo y en inglés uno "
"al lado del otro\n"
"* *********"

#: onAttach.R:30
#, c-format
msgid ""
"**********\n"
"This development version of data.table was built more than 4 weeks ago. "
"Please update: data.table::update_dev_pkg()\n"
"**********"
msgstr ""
"**********\n"
"Esta versión de desarrollo de data.table se creó hace más de 4 semanas. "
"Actualice: data.table::update_dev_pkg()\n"
"**********"

#: onAttach.R:32
#, c-format
msgid ""
"**********\n"
"This installation of data.table has not detected OpenMP support. It should "
"still work but in single-threaded mode."
msgstr ""
"************\n"
"Esta instalación de data.table no ha detectado compatibilidad con OpenMP. "
"Aún debería funcionar pero en modo de un solo hilo."

#: onAttach.R:34
#, c-format
msgid ""
"This is a Mac. Please read https://mac.r-project.org/openmp/. Please engage "
"with Apple and ask them for support. Check r-datatable.com for updates, and "
"our Mac instructions here: https://github.com/Rdatatable/data.table/wiki/"
"Installation. After several years of many reports of installation problems "
"on Mac, it's time to gingerly point out that there have been no similar "
"problems on Windows or Linux.\n"
"**********"
msgstr ""
"Esta es una Mac. Lea https://mac.r-project.org/openmp/. Comuníquese con "
"Apple y pídales ayuda. Consulte r-datatable.com para obtener actualizaciones "
"y nuestras instrucciones para Mac aquí: https://github.com/Rdatatable/data."
"table/wiki/Installation. Después de varios años de muchos informes de "
"problemas de instalación en Mac, es hora de señalar con cautela que no ha "
"habido problemas similares en Windows o Linux.\n"
"**********"

#: onAttach.R:36
#, c-format
msgid ""
"This is %s. This warning should not normally occur on Windows or Linux where "
"OpenMP is turned on by data.table's configure script by passing -fopenmp to "
"the compiler. If you see this warning on Windows or Linux, please file a "
"GitHub issue.\n"
"**********"
msgstr ""
"Esto es %s. Esta advertencia normalmente no debería aparecer en Windows o "
"Linux donde OpenMP se activa mediante el script de configuración de data."
"table pasando -fopenmp al compilador. Si ve esta advertencia en Windows o "
"Linux, presente un problema en GitHub.\n"
"**********"

#: onAttach.R:40
#, c-format
msgid ""
"**********\n"
"This data.table installation was compiled for R < 3.4.0 (Apr 2017) and is "
"known to leak memory. Please upgrade R and reinstall data.table to fix the "
"leak. Maintaining and testing code branches to support very old versions "
"increases development time so please do upgrade R. We intend to bump data."
"table's dependency from 8 year old R 3.1.0 (Apr 2014) to 5 year old R 3.4.0 "
"(Apr 2017).\n"
"**********"
msgstr ""
"**********\n"
"Esta instalación de data.table se compiló para R < 3.4.0 (abril de 2017) y "
"se sabe que tiene fugas de memoria. Actualice R y reinstale data.table para "
"solucionar la fuga. Mantener y probar ramas de código para admitir versiones "
"muy antiguas aumenta el tiempo de desarrollo, así que actualice R. Tenemos "
"la intención de aumentar la dependencia de data.table de R 3.1.0 de 8 años "
"(abril de 2014) a R 3.4.0 de 5 años (abril de 2017). ).\n"
"orte**********"

#: onLoad.R:9
#, c-format
msgid ""
"Option 'datatable.nomatch' is defined but is now ignored. Please see note 11 "
"in v1.12.4 NEWS (Oct 2019), and note 14 in v1.14.2."
msgstr ""
"La opción 'datatable.nomatch' está definida pero ahora se ignora. Consulte "
"la nota 11 en v1.12.4 NEWS (octubre de 2019) y la nota 14 en v1.14.2."

#: onLoad.R:27
#, c-format
msgid ""
"The data_table.%s version (%s) does not match the package (%s). Please close "
"all R sessions to release the old %s and reinstall data.table in a fresh R "
"session. The root cause is that R's package installer can in some "
"unconfirmed circumstances leave a package in a state that is apparently "
"functional but where new R code is calling old C code silently: https://bugs."
"r-project.org/bugzilla/show_bug.cgi?id=17478. Once a package is in this "
"mismatch state it may produce wrong results silently until you next upgrade "
"the package. Please help by adding precise circumstances to 17478 to move "
"the status to confirmed. This mismatch between R and C code can happen with "
"any package not just data.table. It is just that data.table has added this "
"check."
msgstr ""
"La versión data_table.%s (%s) no coincide con el paquete (%s). Cierre todas "
"las sesiones de R para liberar el %s anterior y reinstale data.table en una "
"nueva sesión de R. La causa principal es que el instalador del paquete de R "
"puede, en algunas circunstancias no confirmadas, dejar un paquete en un "
"estado que aparentemente es funcional pero donde el nuevo código de R llama "
"al código C antiguo de forma silenciosa: https://bugs.r-project.org/bugzilla/"
"show_bug .cgi?id=17478. Una vez que un paquete se encuentra en este estado "
"de discrepancia, puede producir resultados incorrectos de forma silenciosa "
"hasta la próxima actualización del paquete. Ayúdenos agregando "
"circunstancias precisas a 17478 para pasar el estado a confirmado. Esta "
"discrepancia entre el código R y C puede ocurrir con cualquier paquete, no "
"solo con data.table. Es solo que data.table ha agregado esta verificación."

#: onLoad.R:31
#, c-format
msgid ""
"This is R %s but data.table has been installed using R %s. The major version "
"must match. Please reinstall data.table."
msgstr ""
"Esto es R %s pero data.table se instaló usando R %s. La versión principal "
"debe coincidir. Vuelva a instalar data.table."

#: onLoad.R:98
#, c-format
msgid "Unexpected base R behaviour: list(x) has copied x"
msgstr " Comportamiento inesperado en R base: list(x) ha copiado x"

#: onLoad.R:106
#, c-format
msgid "Unexpected base R behaviour: names<- has copied column contents"
msgstr ""
"Comportamiento inesperado de la base R: names<- ha copiado el contenido de "
"la columna"

#: onLoad.R:116
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- did not copy column 2 which was "
"assigned to"
msgstr ""
"Comportamiento inesperado de la base R: DF[2,2]<- no copió la columna 2 a la "
"cual algo le fue asignado"

#: onLoad.R:117
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- copied the first column which was not "
"assigned to, too"
msgstr ""
"Comportamiento inesperado de la base R: DF[2,2]<- también copió la primera "
"columna a la que nada fue asignado"

#: onLoad.R:119
#, c-format
msgid "Unexpected base R behaviour: DF[2,2]<- has not copied address(DF)"
msgstr ""
"Comportamiento inesperado de la base R: DF[2,2]<- no ha copiado la dirección "
"`address(DF)`"

#: openmp-utils.R:3
#, c-format
msgid "Provide either threads= or percent= but not both"
msgstr "Proporcione threads= o percent= pero no ambos"

#: openmp-utils.R:4
#, c-format
msgid "percent= is provided but is length %d"
msgstr "percent= se proporciona pero tiene una longitud %d"

#: openmp-utils.R:6
#, c-format
msgid "percent==%d but should be a number between 2 and 100"
msgstr "percent==%d pero debe ser un número entre 2 y 100"

#: print.data.table.R:19
#, c-format
msgid "Valid options for col.names are 'auto', 'top', and 'none'"
msgstr ""
"Las opciones válidas para nombres de columnas son 'auto', 'top' y 'none'"

#: print.data.table.R:21
#, c-format
msgid "Valid options for trunc.cols are TRUE and FALSE"
msgstr "Las opciones válidas para trunc.cols son TRUE y FALSE"

#: print.data.table.R:23
#, c-format
msgid "Column classes will be suppressed when col.names is 'none'"
msgstr "Las clases de columnas se suprimirán cuando col.names sea 'none'"

#: print.data.table.R:156
#, c-format
msgid ""
"Internal structure doesn't seem to be a list. Possibly corrupt data.table."
msgstr ""
"La estructura interna no parece ser una lista. Posiblemente sea una data."
"table corrupta."

#: programming.R:14 programming.R:40
#, c-format
msgid "'x' must be a list"
msgstr "'x' debe ser una lista"

#: programming.R:22
#, c-format
msgid ""
"Character objects provided in the input are not scalar objects, if you need "
"them as character vector rather than a name, then wrap each into 'I' call: %s"
msgstr ""
"Los objetos de caracteres proporcionados en la entrada no son objetos "
"escalares, si los necesita como un vector de caracteres en lugar de un "
"nombre, envuelva cada uno en la llamada 'I': %s"

#: programming.R:50
#, c-format
msgid "'env' must not be missing"
msgstr "'env' no puede ser faltante"

#: programming.R:56
#, c-format
msgid "'env' must be a list or an environment"
msgstr "'env' debe ser una lista o un entorno"

#: programming.R:63
#, c-format
msgid "'env' argument does not have names"
msgstr "'env' argumento no tiene nombres"

#: programming.R:65
#, c-format
msgid "'env' argument has zero char names"
msgstr "'env' argumento tiene nombres de cero caracteres"

#: programming.R:67
#, c-format
msgid "'env' argument has NA names"
msgstr "'env' argumento tiene nombres NA"

#: programming.R:69
#, c-format
msgid "'env' argument has duplicated names"
msgstr "'env' argumento tiene nombres duplicados"

#: setkey.R:3
#, c-format
msgid ""
"x may no longer be the character name of the data.table. The possibility was "
"undocumented and has been removed."
msgstr ""
"x puede que ya no sea el nombre del carácter de la data.table. La "
"posibilidad no estaba documentada y ha sido eliminada."

#: setkey.R:23
#, c-format
msgid ""
"key(x)<-value is deprecated and not supported. Please change to use setkey() "
"with perhaps copy(). Has been warning since 2012."
msgstr ""
"key(x)<-value está obsoleto y no está soportado. Por favor cambie a "
"setkey(), quizás con copy(). Ha sido una advertencia desde 2012."

#: setkey.R:39
#, c-format
msgid "x is not a data.table"
msgstr "x no es una data.table"

#: setkey.R:40
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setkey."
msgstr ""
"cols no es un vector de caracteres. Consulte más información en ?setkey."

#: setkey.R:41
#, c-format
msgid ""
"Setting a physical key on .SD is reserved for possible future use; to modify "
"the original data's order by group. Try setindex() instead. Or, set*(copy(."
"SD)) as a (slow) last resort."
msgstr ""
"La configuración de una clave física en .SD está reservada para un posible "
"uso futuro; para modificar el orden de los datos originales por grupo. "
"Pruebe con setindex() en su lugar. O set*(copy(.SD)) como último recurso "
"(lento)."

#: setkey.R:43
#, c-format
msgid ""
"cols is a character vector of zero length. Removed the key, but use NULL "
"instead, or wrap with suppressWarnings() to avoid this warning."
msgstr ""
"cols es un vector de caracteres de longitud cero. Se eliminó la clave, pero "
"use NULL en su lugar o ajuste con suprimirWarnings() para evitar esta "
"advertencia."

#: setkey.R:47
#, c-format
msgid "cols is the empty string. Use NULL to remove the key."
msgstr "cols es la cadena vacía. Utilice NULL para eliminar la clave."

#: setkey.R:48 setkey.R:262
#, c-format
msgid "cols contains some blanks."
msgstr "cols contiene algunos espacios en blanco."

#: setkey.R:51 setkey.R:266
#, c-format
msgid "some columns are not in the data.table: %s"
msgstr "algunas columnas no están en la data.table: %s"

#: setkey.R:59 setkey.R:267
#, c-format
msgid ""
"x contains a column called '.xi'. Conflicts with internal use by data.table."
msgstr ""
"x contiene una columna llamada '.xi'. Conflictos con el uso interno de data."
"table."

#: setkey.R:62
#, c-format
msgid ""
"Column '%s' is type '%s' which is not supported as a key column type, "
"currently."
msgstr ""
"La columna '%s' es de tipo '%s' que actualmente no se admite como tipo de "
"columna clave."

#: setkey.R:137
#, c-format
msgid "x is vector but 'by' is supplied"
msgstr "x es un vector pero se proporciona 'by'"

#: setkey.R:153
#, c-format
msgid "x is a single vector, non-NULL 'by' doesn't make sense"
msgstr "x es un vector único, 'by' no NULL no tiene sentido"

#: setkey.R:184
#, c-format
msgid "Attempting to order a 0-column data.table or data.frame."
msgstr "Intentando ordenar una data.table o un data.frame de 0 columnas."

#: setkey.R:189
#, c-format
msgid ""
"The first item passed to [f]order is a plain list but there are more items. "
"It should be a data.table or data.frame."
msgstr ""
"El primer elemento pasado a [f]order es una lista simple pero hay más "
"elementos. Debería ser una data.table o un data.frame."

#: setkey.R:206
#, c-format
msgid "Internal code should not be being called on type double"
msgstr "El código interno no debería estar siendo llamado en un tipo doble"

#: setkey.R:214
#, c-format
msgid ""
"Input is not a vector of type double. New parallel sort has only been done "
"for double vectors so far. Using one thread."
msgstr ""
"La entrada no es un vector de tipo doble. Hasta ahora solo se ha realizado "
"una nueva clasificación paralela para vectores dobles. Usando un hilo."

#: setkey.R:215
#, c-format
msgid ""
"New parallel sort has not been implemented for decreasing=TRUE so far. Using "
"one thread."
msgstr ""
"Hasta ahora no se ha implementado una nueva clasificación en paralelo para "
"decreasing=TRUE. Usando un hilo."

#: setkey.R:216
#, c-format
msgid ""
"New parallel sort has not been implemented for vectors containing NA values "
"so far. Using one thread."
msgstr ""
"Hasta ahora no se ha implementado una nueva clasificación en paralelo para "
"los vectores que contienen valores NA. Usando un hilo."

#: setkey.R:228 setkey.R:254
#, c-format
msgid "x must be a data.frame or data.table"
msgstr "x debe ser un data.frame o data.table"

#: setkey.R:256
#, c-format
msgid "na.last must be logical TRUE/FALSE"
msgstr "na.last debe ser lógico TRUE/FALSE"

#: setkey.R:257
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setorder."
msgstr ""
"cols no es un vector de caracteres. Consulte más información en ?setorder."

#: setkey.R:259
#, c-format
msgid ""
"cols is a character vector of zero length. Use NULL instead, or wrap with "
"suppressWarnings() to avoid this warning."
msgstr ""
"cols es un vector de caracteres de longitud cero. Utilice NULL en su lugar o "
"ajuste con suppressWarnings() para evitar esta advertencia."

#: setkey.R:270
#, c-format
msgid "Column '%s' is type '%s' which is not supported for ordering currently."
msgstr ""
"La columna '%s' es de tipo '%s' que no se admite para ordenamiento "
"actualmente."

#: setkey.R:314
#, c-format
msgid ""
"'sorted' is TRUE but element %d is non-atomic, which can't be sorted; try "
"setting sorted = FALSE"
msgstr ""
"'sorted' es TRUE pero el elemento %d no es atómico, por lo que no se puede "
"ordenar; intente configurar sorted = FALSE"

#: setkey.R:329
#, c-format
msgid ""
"Cross product of elements provided to CJ() would result in %.0f rows which "
"exceeds .Machine$integer.max == %d"
msgstr ""
"El producto cruzado de los elementos proporcionados a CJ() daría como "
"resultado %.0f filas que exceden .Machine$integer.max == %d"

#: setops.R:3 setops.R:40
#, c-format
msgid "x and y must both be data.tables"
msgstr "x e y deben ser data.table"

#: setops.R:9
#, c-format
msgid "length(by.x) != length(by.y)"
msgstr "length(by.x) != length(by.y)"

#: setops.R:17
#, c-format
msgid ""
"When x's column ('%s') is character, the corresponding column in y ('%s') "
"should be factor or character, but found incompatible type '%s'."
msgstr ""
"Cuando la columna de x ('%s') es un carácter, la columna correspondiente en "
"y ('%s') debe ser un factor o un carácter, pero se encontró el tipo "
"incompatible '%s'."

#: setops.R:19
#, c-format
msgid ""
"When x's column ('%s') is factor, the corresponding column in y ('%s') "
"should be character or factor, but found incompatible type '%s'."
msgstr ""
"Cuando la columna de x ('%s') es factor, la columna correspondiente en y "
"('%s') debe ser carácter o factor, pero se encontró que el tipo '%s' es "
"incompatible."

#: setops.R:21
#, c-format
msgid ""
"When x's column ('%s') is integer or numeric, the corresponding column in y "
"('%s') can not be character or logical types, but found incompatible type "
"'%s'."
msgstr ""
"Cuando la columna de x ('%s') es entera o numérica, la columna "
"correspondiente en y ('%s') no puede ser de caracteres o de tipos lógicos, "
"pero se encontró que el tipo '%s' es incompatible."

#: setops.R:39
#, c-format
msgid "argument 'all' should be logical of length one"
msgstr "el argumento 'all' debe ser lógico de longitud uno"

#: setops.R:41
#, c-format
msgid "x and y must have the same column names"
msgstr "x e y deben tener los mismos nombres de columna"

#: setops.R:42
#, c-format
msgid "x and y must have the same column order"
msgstr "x e y deben tener el mismo orden de columnas"

#: setops.R:45
#, c-format
msgid "unsupported column type(s) found in x or y: %s"
msgstr "tipo(s) de columna no admitidos encontrados en x o y: %s"

#: setops.R:53
#, c-format
msgid "Item %d of x is '%s' but the corresponding item of y is '%s'."
msgstr ""
"El elemento %d de x es '%s' pero el elemento correspondiente de y es '%s'."

#: setops.R:55
#, c-format
msgid "None of the datasets should contain a column named '.seqn'"
msgstr ""
"Ninguno de los conjuntos de datos debe contener una columna denominada '."
"seqn'"

#: setops.R:159 setops.R:170
#, c-format
msgid "Datasets have different %s. 'target': %s. 'current': %s."
msgstr ""
"Los conjuntos de datos tienen %s diferentes. 'target': %s. 'current': %s."

#: setops.R:161 setops.R:162
#, c-format
msgid "has no key"
msgstr "no tiene clave (key)"

#: setops.R:172 setops.R:173
#, c-format
msgid "has no index"
msgstr "no tiene índice"

#: setops.R:190
#, c-format
msgid "None of the datasets to compare should contain a column named '.seqn'"
msgstr ""
"Ninguno de los conjuntos de datos a comparar debe contener una columna "
"denominada '.seqn'"

#: setops.R:193
#, c-format
msgid ""
"Datasets to compare with 'ignore.row.order' must not have unsupported column "
"types: %s"
msgstr ""
"Los conjuntos de datos a comparar con 'ignore.row.order' no deben tener "
"tipos de columnas no admitidas: %s"

#: setops.R:195
#, c-format
msgid ""
"Argument 'tolerance' was forced to lowest accepted value `sqrt(."
"Machine$double.eps)` from provided %s"
msgstr ""
"El argumento 'tolerance' fue forzado al valor más bajo aceptado `sqrt(."
"Machine$double.eps)` del %s proporcionado"

#: setops.R:208
#, c-format
msgid ""
"Duplicate rows in datasets, numeric columns and ignore.row.order cannot be "
"used with non 0 tolerance argument"
msgstr ""
"Las filas duplicadas en conjuntos de datos, columnas numéricas e ignore.row."
"order no se pueden usar con un argumento tolerance que no sea 0"

#: setops.R:222
#, c-format
msgid ""
"Factor columns and ignore.row.order cannot be used with non 0 tolerance "
"argument"
msgstr ""
"Las columnas de factor e ignore.row.order no se pueden usar con un argumento "
"tolerance que no sea 0"

#: shift.R:3
#, c-format
msgid "Provided argument fill=%s will be ignored since type='cyclic'."
msgstr "El argumento proporcionado fill=%s será ignorado ya que type='cyclic'."

#: tables.R:46
#, c-format
msgid "order.col='%s' not a column name of info"
msgstr "order.col='%s' no es un nombre de columna de información"

#: test.data.table.R:17
#, c-format
msgid "data.table package is loaded. Unload or start a fresh R session."
msgstr ""
"El paquete data.table está cargado. Descargue o inicie una nueva sesión de R."

#: test.data.table.R:33
#, c-format
msgid ""
"script must end with '.Rraw'. If a file ending '.Rraw.bz2' exists, that will "
"be found and used."
msgstr ""
"el script debe terminar con '.Rraw'. Si existe un archivo que termina en '."
"Rraw.bz2', se encontrará y se utilizará."

#: test.data.table.R:63
#, c-format
msgid "Neither %s nor %s exist in %s"
msgstr "Ni %s ni %s existen en %s"

#: test.data.table.R:118
msgid "object '%s' not found"
msgstr "objeto '%s' no encontrado"

#: test.data.table.R:142
#, c-format
msgid ""
"memtest intended for Linux. Step through data.table:::rss() to see what went "
"wrong."
msgstr ""
"memtest destinado a Linux. Revise data.table:::rss() para ver qué salió mal."

#: test.data.table.R:196
#, c-format
msgid "Attempt to subset to %d tests matching '%s' failed, running full suite."
msgstr ""
"El intento de crear un subconjunto de %d pruebas que coincidan con '%s' "
"falló; se ejecutó el conjunto completo."

#: test.data.table.R:245
#, c-format
msgid "Failed in %s after test %s before the next test() call in %s"
msgstr ""
"Error en %s después de la prueba %s antes de la siguiente llamada de "
"prueba() en %s"

#: test.data.table.R:255
#, c-format
msgid "%d error(s) out of %d. Search %s for test number(s) %s. Duration: %s."
msgstr ""
"%d error(es) de %d. Busque en %s los números de prueba %s. Duración: %s."

#: test.data.table.R:268
#, c-format
msgid "Timings count mismatch: %d vs %d"
msgstr "El recuento de tiempos no coincide: %d vs %d"

#: test.data.table.R:399
#, c-format
msgid ""
"Test %s is invalid: when error= is provided it does not make sense to pass y "
"as well"
msgstr ""
"La prueba %s no es válida: cuando se proporciona error= no tiene sentido "
"pasar 'y' también"

#: timetaken.R:3
#, c-format
msgid "Use started.at=proc.time() not Sys.time() (POSIXt and slow)"
msgstr "Utilice start.at=proc.time(), no Sys.time() (POSIXt y lento)"

#: transpose.R:7
#, c-format
msgid "make.names='%s' not found in names of input"
msgstr "make.names='%s' no encontrado en los nombres de entrada"

#: transpose.R:12
#, c-format
msgid "make.names=%d is out of range [1,ncol=%d]"
msgstr "make.names=%d está fuera de rango [1,ncol=%d]"

#: transpose.R:28
#, c-format
msgid "'names' must be TRUE/FALSE or a character vector."
msgstr "'names' debe ser TRUE/FALSE o un vector de caracteres."

#: transpose.R:34
#, c-format
msgid "'keep' should contain integer values between %d and %d."
msgstr "'keep' debe contener valores enteros entre %d y %d."

#: transpose.R:51
#, c-format
msgid "The argument 'type.convert' does not support empty list."
msgstr "El argumento 'type.convert' no admite listas vacías."

#: transpose.R:57
#, c-format
msgid ""
"When the argument 'type.convert' contains an unnamed element, it is expected "
"to be the last element and should be a function. More than one unnamed "
"element is not allowed unless all elements are functions with length equal "
"to %d (the length of the transpose list or 'keep' argument if it is "
"specified)."
msgstr ""
"Cuando el argumento 'type.convert' contiene un elemento sin nombre, se "
"espera que sea el último elemento y debería ser una función. No se permite "
"más de un elemento sin nombre a menos que todos los elementos sean funciones "
"con una longitud igual a %d (la longitud de la lista de transposición o el "
"argumento 'keep' si se especifica)."

#: transpose.R:66
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, it should "
"be a named list of non-missing integer values (with no duplicate) except the "
"last element that should be unnamed if it is a function."
msgstr ""
"Cuando el argumento 'type.convert' contiene índices de lista transpuesta, "
"debe ser una lista con nombre de valores enteros no faltantes (sin "
"duplicados), excepto el último elemento que no debe tener nombre si es una "
"función."

#: transpose.R:68
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, they "
"should be integer values contained in the argument 'keep' (if it is "
"specified) or be between %d and %d (if it is not). But '%s' is/are not "
"contained in '%s'."
msgstr ""
"Cuando el argumento 'type.convert' contiene índices de lista transpuesta, "
"deben ser valores enteros contenidos en el argumento 'keep' (si se "
"especifica) o estar entre %d y %d (si No lo es). Pero '%s' no está contenido "
"en '%s'."

#: transpose.R:74
#, c-format
msgid ""
"In the argument 'type.convert', '%s' was ignored because all elements in the "
"transpose list or elements corresponding to indices specified in the 'keep' "
"argument have already been converted."
msgstr ""
"En el argumento 'type.convert', se ignoró '%s' porque todos los elementos en "
"la lista de transposición o los elementos correspondientes a los índices "
"especificados en el argumento 'keep' ya se han convertido."

#: transpose.R:83
#, c-format
msgid ""
"The argument 'type.convert' should be TRUE/FALSE, a function, a list of "
"functions, or a named list of pairs 'fun=indices' with optionally one "
"unnamed element (a function) but an object of type '%s' was provided."
msgstr ""
"El argumento 'type.convert' debe ser TRUE/FALSE, una función, una lista de "
"funciones o una lista de pares con nombre 'fun=indices' con opcionalmente un "
"elemento sin nombre (una función) pero un objeto de tipo '%s' fue "
"proporcionado."

#: transpose.R:88
#, c-format
msgid "length(names) (= %d) is not equal to length(%s) (= %d)."
msgstr "length(nombres) (= %d) no es igual a length(%s) (= %d)."

#: uniqlist.R:11
#, c-format
msgid "l not type list"
msgstr "l no es de tipo lista"

#: utils.R:18
#, c-format
msgid "Argument 'nan' must be length 1"
msgstr "El argumento 'nan' debe tener una longitud de 1"

#: utils.R:21
#, c-format
msgid "Argument 'nan' must be NA or NaN"
msgstr "El argumento 'nan' debe ser NA o NaN"

#: utils.R:25
msgid "Internal error in"
msgstr "Error interno en"

#: forder.c:111 utils.c:446
msgid "Please report to the data.table issues tracker."
msgstr "Favor informe al rastreador de problemas de data.table"

#: utils.R:57 utils.R:66
#, c-format
msgid "x not boolean"
msgstr "x no booleano"

#: utils.R:77
#, c-format
msgid ""
"Some columns are type 'integer64' but package bit64 is not installed. Those "
"columns will print as strange looking floating point data. There is no need "
"to reload the data. Simply install.packages('bit64') to obtain the integer64 "
"print method and print the data again."
msgstr ""
"Algunas columnas son de tipo 'integer64' pero el paquete bit64 no está "
"instalado. Esas columnas se imprimirán como datos de punto flotante de "
"aspecto extraño. No es necesario recargar los datos. Simplemente instale."
"packages('bit64') para obtener el método de impresión integer64 e imprimir "
"los datos nuevamente."

#: xts.R:3
#, c-format
msgid "keep.rownames must be length 1"
msgstr "keep.rownames debe tener una longitud de 1"

#: xts.R:4
#, c-format
msgid "keep.rownames must not be NA"
msgstr "keep.rownames no debe ser NA"

#: xts.R:10
#, c-format
msgid ""
"Input xts object should not have '%s' column because it would result in "
"duplicate column names. Rename '%s' column in xts or use `keep.rownames` to "
"change the index column name."
msgstr ""
"El objeto xts de entrada no debe tener la columna '%s' porque daría como "
"resultado nombres de columna duplicados. Cambie el nombre de la columna '%s' "
"en xts o use `keep.rownames` para cambiar el nombre de la columna del índice."

#: xts.R:20
#, c-format
msgid ""
"data.table must have a time based column in first position, use "
"`setcolorder` function to change the order, or see ?timeBased for supported "
"types"
msgstr ""
"data.table debe tener una columna basada en tiempo en la primera posición, "
"use la función `setcolorder` para cambiar el orden, o vea ?timeBased para "
"los tipos admitidos"

#: xts.R:24
#, c-format
msgid "Following columns are not numeric and will be omitted: %s"
msgstr "Las siguientes columnas no son numéricas y se omitirán: %s"

#: print.data.table.R:53
msgid "Index: %s\n"
msgid_plural "Indices: %s\n"
msgstr[0] "Índice: %s\n"
msgstr[1] "Índices: %s\n"

#: assign.c:557
#, c-format
msgid ""
"Direct plonk of unnamed RHS, no copy. MAYBE_REFERENCED==%d, "
"MAYBE_SHARED==%d\n"
msgstr ""
"RHS sin nombre se pisa directamente (plonk), no hay copia. "
"MAYBE_REFERENCED==%d, MAYBE_SHARED==%d\n"

#: fifelse.c:230
#, c-format
msgid "Argument #%d must be logical but was of type %s."
msgstr "El argumento #%d debe ser lógic, pero era de tipo %s."

#: fifelse.c:248
#, c-format
msgid ""
"Argument #%d has length %lld which differs from that of argument #1 (%lld). "
"Please make sure all logical conditions have the same length."
msgstr ""
"El argumento #%d tiene longitud %lld diferente a la del argumento #1 (%lld). "
"Asegúrese de que todas las condiciones lógicatienen la misma longitud."

#: fifelse.c:288
#, c-format
msgid "Length of 'default' must be 1 or %lld."
msgstr "La longitud de 'default' debe ser 1 o %lld."

#: fifelse.c:290
#, c-format
msgid ""
"Length of output value #%d (%lld) must either be 1 or match the length of "
"the logical condition (%lld)."
msgstr ""
"La longitud del valor de salida #%d (%lld) debe ser 1 o la longitud de la "
"condición lógica"

#: fifelse.c:395
#, c-format
msgid "Type '%s' is not supported."
msgstr "El tipo '%s' no está soportado"

#: forder.c:287
msgid "Failed to alloc cradix_counts and/or cradix_tmp"
msgstr "No se pudo asignar cradix_counts y/o cradix_tmp"

#: forder.c:477
#, c-format
msgid "'order' length (%d) is different to by='s length (%d)"
msgstr "longitud de 'order' (%d) es diferente a la de by= (%d)"

#: forder.c:908 forder.c:978 forder.c:1000 forder.c:1102 forder.c:1233
#: forder.c:1289 fread.c:2573
#, c-format
msgid "Failed to allocate %d bytes for '%s'."
msgstr "Error al asignar %d bytes para '%s'"

#: forder.c:1145
#, c-format
msgid "Failed to allocate 'my_otmp' and/or 'my_ktmp' arrays (%d bytes)."
msgstr ""
"Error al asignar memoria para los arrays 'my_otmp' y/o 'my_otmp' (%d bytes)"

#: fread.c:2132
#, c-format
msgid "Failed to allocate %d bytes for '%s': %s"
msgstr "Error al asignar %d bytes para '%s': %s"

#: fread.c:2688
#, c-format
msgid ""
"Stopped early on line %<PRIu64>. Expected %d fields but found %d. Consider "
"fill=%d or even more based on your knowledge of the input file. Use fill=Inf "
"for reading the whole file for detecting the number of fields. First "
"discarded non-empty line: <<%s>>"
msgstr ""
"Se detuvo anticipadamente en la línea %<PRIu64>. Se esperaban %d campos pero "
"se encontraron %d. Considere fill=%d o más en función de su conocimiento del "
"archivo de entrada. Use fill=Inf para detectar el número de campos leyendo "
"el archivo completo. Primera línea no vacía descartada: <<%s>>"

#: fsort.c:132
#, c-format
msgid "Failed to allocate %d bytes in fsort()."
msgstr "Error al asignar %d bytes en fsort()."

#: fwrite.c:853
#, c-format
msgid "Failed to allocated %d bytes for '%s'."
msgstr "Error al asignar %d bytes para: '%s'."

#: rbindlist.c:330
#, c-format
msgid ""
"Class attribute on column %d of item %d does not match with column %d of "
"item %d. You can deactivate this safety-check by using ignore.attr=TRUE"
msgstr ""
"El atributo de clase en la columna %d del elemento %d no coincide con la "
"columna %d del elemento %d. Puede desactivar este control de seguridad "
"usando ignore.attr=TRUE"

#: assign.c:121
msgid ""
".internal.selfref ptr is NULL. This is expected and normal for a data.table "
"loaded from disk. Please remember to always setDT() immediately after "
"loading to prevent unexpected behavior. If this table was not loaded from "
"disk or you've already run setDT(), please report to data.table issue "
"tracker.\n"
msgstr ""
".internal.selfref ptr es NULL. Esto es esperado y normal para una data.table "
"cargada desde el disco. Recuerde siempre hacer setDT() inmediatamente "
"después de la carga para evitar comportamientos inesperados. Si esta tabla "
"no se cargó desde el disco o ya ejecutó setDT(), informe al rastreador de "
"problemas de data.table.\n"

#: assign.c:202
#, c-format
msgid ""
"Some columns are a multi-column type (such as a matrix column), for example "
"column %d. setDT will retain these columns as-is but subsequent operations "
"like grouping and joining may fail. Please consider as.data.table() instead "
"which will create a new column for each embedded column."
msgstr ""
"Algunas columnas son de tipo multicolumna (como una columna de matriz), por "
"ejemplo, la columna %d. setDT conservará estas columnas tal como están, pero "
"las operaciones posteriores, como la agrupación y la unión, pueden fallar. "
"Considere en cambio as.data.table(), que creará una nueva columna para cada "
"columna incrustada."

#: assign.c:219
#, c-format
msgid ""
"Column %d has class 'POSIXlt'. Please convert it to POSIXct (using as."
"POSIXct) and run setDT() again. We do not recommend the use of POSIXlt at "
"all because it uses 40 bytes to store one date."
msgstr ""
"La columna %d tiene la clase 'POSIXlt'. Conviértala a POSIXct (usando as."
"POSIXct) y ejecute setDT() nuevamente. No recomendamos el uso de POSIXlt en "
"absoluto porque utiliza 40 bytes para almacenar una fecha."

#: assign.c:239
#, c-format
msgid ""
"All elements in argument 'x' to 'setDT' must be of equal length, but input "
"%d has length %d whereas the first non-empty input had length %d"
msgstr ""
"Todos los elementos en el argumento 'x' de 'setDT' deben tener la misma "
"longitud, pero la entrada %d tiene una longitud %d mientras que la primera "
"entrada no vacía tenía una longitud %d"

#: assign.c:249
msgid "alloccol has been passed a NULL dt"
msgstr " a 'alloccol' se le ha pasado un dt NULL"

#: assign.c:250
msgid "dt passed to alloccol isn't type VECSXP"
msgstr "dt pasado a 'alloccol' no es del tipo VECSXP"

#: assign.c:252
msgid ""
"dt passed to alloccol has no class attribute. Please report result of "
"traceback() to data.table issue tracker."
msgstr ""
"dt pasado a 'alloccol' no tiene atributo de clase. Informe el resultado de "
"traceback() al rastreador de problemas de data.table."

#: assign.c:269
#, c-format
msgid ""
"tl (%d) is greater than 10,000 items over-allocated (l = %d). If you didn't "
"set the datatable.alloccol option to be very large, please report to data."
"table issue tracker including the result of sessionInfo()."
msgstr ""
"tl (%d) es mayor que 10000 elementos sobreasignados (l = %d). Si no "
"configuró la opción datatable.alloccol para que sea muy grande, informe al "
"rastreador de problemas de data.table, incluido el resultado de "
"sessionInfo()."

#: assign.c:271
#, c-format
msgid ""
"Attempt to reduce allocation from %d to %d ignored. Can only increase "
"allocation via shallow copy. Please do not use DT[...]<- or DT$someCol<-. "
"Use := inside DT[...] instead."
msgstr ""
"Se ignora el intento de reducir la asignación de %d a %d. Solo se puede "
"aumentar la asignación mediante una copia superficial. No utilice DT[...]<- "
"o DT$someCol<-. Utilice := dentro de DT[...] en su lugar."

#: assign.c:279
msgid ""
"Has getOption('datatable.alloccol') somehow become unset? It should be a "
"number, by default 1024."
msgstr ""
"¿Se ha desconfigurado getOption('datatable.alloccol') de alguna manera? "
"Debería ser un número, por defecto 1024."

#: assign.c:281
#, c-format
msgid ""
"getOption('datatable.alloccol') should be a number, by default 1024. But its "
"type is '%s'."
msgstr ""
"getOption('datatable.alloccol') debería ser un número, por defecto 1024. "
"Pero su tipo es '%s'."

#: assign.c:283
#, c-format
msgid ""
"getOption('datatable.alloc') is a numeric vector ok but its length is %d. "
"Its length should be 1."
msgstr ""
"getOption('datatable.alloc') es un vector numérico correcto, pero su "
"longitud es %d. Su longitud debe ser 1."

#: assign.c:286
#, c-format
msgid "getOption('datatable.alloc')==%d.  It must be >=0 and not NA."
msgstr "getOption('datatable.alloc')==%d. Debe ser >=0 y no NA."

#: assign.c:340
msgid "assign has been passed a NULL dt"
msgstr "a la asignación se le ha pasado un dt NULL"

#: assign.c:341
msgid "dt passed to assign isn't type VECSXP"
msgstr "dt pasado para asignar no es del tipo VECSXP"

#: assign.c:343
msgid ""
".SD is locked. Updating .SD by reference using := or set are reserved for "
"future use. Use := in j directly. Or use copy(.SD) as a (slow) last resort, "
"until shallow() is exported."
msgstr ""
".SD está bloqueado. La actualización de .SD por referencia usando := o set "
"está reservada para uso futuro. Utilice := en 'j' directamente. O utilice "
"copy(.SD) como último recurso (lento), hasta que se exporte shallow()."

#: assign.c:355
msgid "dt passed to assign has no names"
msgstr "dt pasado para asignar no tiene nombres"

#: assign.c:359
msgid ""
"data.table is NULL; malformed. A null data.table should be an empty list. "
"typeof() should always return 'list' for data.table."
msgstr ""
"datos.tabla es NULL; malformado. Una data.table nula debe ser una lista "
"vacía. typeof() siempre debe devolver 'list' para data.table."

#: assign.c:369
#, c-format
msgid "Assigning to all %d rows\n"
msgstr "Asignando a todas las %d filas\n"

#: assign.c:374
msgid ""
"Coerced i from numeric to integer. Please pass integer for efficiency; e.g., "
"2L rather than 2"
msgstr ""
"Forzando 'i' a numérico a entero. Pase un número entero para mayor "
"eficiencia; por ejemplo, 2L en lugar de 2"

#: assign.c:377
#, c-format
msgid ""
"i is type '%s'. Must be integer, or numeric is coerced with warning. If i is "
"a logical subset, simply wrap with which(), and take the which() outside the "
"loop if possible for efficiency."
msgstr ""
"'i' es del tipo '%s'. Debe ser un número entero o el valor numérico se "
"fuerza con una advertencia. Si i es un subconjunto lógico, simplemente "
"envuélvalo con which() y, si es posible, saque el which() fuera del bucle "
"para mayor eficiencia."

#: assign.c:383 subset.c:170
#, c-format
msgid "i[%d] is %d which is out of range [1,nrow=%d]"
msgstr "i[%d] es %d que está fuera de rango [1,nrow=%d]"

#: assign.c:386
#, c-format
msgid "Assigning to %d row subset of %d rows\n"
msgstr "Asignando a %d subconjunto de filas de %d filas\n"

#: assign.c:395
#, c-format
msgid "Added %d new column%s initialized with all-NA\n"
msgstr "Se agregó %d nuevas columnas%s inicializadas con todo-NA\n"

#: assign.c:400
msgid "length(LHS)==0; no columns to delete or assign RHS to."
msgstr "length(LHS)==0; no hay columnas para eliminar o asignar RHS."

#: assign.c:414
msgid ""
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that. data.table's are over-allocated and don't "
"shallow copy."
msgstr ""
"set() en un data.frame es para cambiar columnas existentes, no para agregar "
"nuevas. Utilice una data.table para eso. Los data.table están sobreasignados "
"y no realizan copias superficiales."

#: assign.c:425
msgid ""
"Coerced j from numeric to integer. Please pass integer for efficiency; e.g., "
"2L rather than 2"
msgstr ""
"J forzado de numérico a entero. Pase un número entero para mayor eficiencia; "
"por ejemplo, 2L en lugar de 2"

#: assign.c:428
#, c-format
msgid ""
"j is type '%s'. Must be integer, character, or numeric is coerced with "
"warning."
msgstr ""
"j es tipo '%s'. Debe ser un número entero, un carácter o un número numérico "
"con advertencia."

#: assign.c:430
msgid ""
"Can't assign to the same column twice in the same query (duplicates "
"detected)."
msgstr ""
"No se puede asignar a la misma columna dos veces en la misma consulta (se "
"detectaron duplicados)."

#: assign.c:431
msgid "newcolnames is supplied but isn't a character vector"
msgstr "se proporciona 'newcolnames' pero no es un vector de caracteres"

#: assign.c:433
msgid ""
"Values of type POSIXlt detected and converted to POSIXct. We do not "
"recommend the use of POSIXlt at all because it typically takes more than 6 "
"times the storage as an equivalent POSIXct column. Use as.POSIXct() to avoid "
"this warning."
msgstr ""
"Valores de tipo POSIXlt detectados y convertidos a POSIXct. No recomendamos "
"el uso de POSIXlt para nada, ya que típicamente usa más de 6 veces el "
"almacenamiento de una columna POSIXct equivalente. Use as.POSIXct() para "
"evitar este aviso."

#: assign.c:437
#, c-format
msgid "RHS_list_of_columns == %s\n"
msgstr "RHS_list_of_columns == %s\n"

#: assign.c:442
#, c-format
msgid ""
"RHS_list_of_columns revised to true because RHS list has 1 item which is "
"NULL, or whose length %d is either 1 or targetlen (%d). Please unwrap RHS.\n"
msgstr ""
"RHS_list_of_columns revisado a verdadero porque la lista RHS tiene 1 "
"elemento que es NULL, o cuya longitud %d es 1 o targetlen (%d). Desenvuelva "
"el RHS.\n"

#: assign.c:447
#, c-format
msgid ""
"Supplied %d columns to be assigned an empty list (which may be an empty data."
"table or data.frame since they are lists too). To delete multiple columns "
"use NULL instead. To add multiple empty list columns, use list(list())."
msgstr ""
"Se proporcionaron %d columnas a las que se les asignará una lista vacía (que "
"puede ser una data.table o un data.frame vacío, ya que también son listas). "
"Para eliminar varias columnas, utilice NULL en su lugar. Para agregar varias "
"columnas de lista vacías, use list(list())."

#: assign.c:452
#, c-format
msgid "Recycling single RHS list item across %d columns. Please unwrap RHS.\n"
msgstr ""
"Reciclando un solo elemento de la lista RHS en %d columnas. Desenvuelva el "
"RHS.\n"

#: assign.c:454
#, c-format
msgid ""
"Supplied %d columns to be assigned %d items. Please see NEWS for v1.12.2."
msgstr ""
"Se proporcionaron %d columnas para asignar %d elementos. Consulte NEWS para "
"v1.12.2."

#: assign.c:462
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. "
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that."
msgstr ""
"El elemento %d de los números de columna en 'j' es %d que está fuera del "
"rango [1,ncol=%d]. set() en un data.frame es para cambiar columnas "
"existentes, no para agregar otras nuevas. Utilice una data.table para eso."

#: assign.c:463
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. Use "
"column names instead in j to add new columns."
msgstr ""
"El elemento %d de los números de columna en 'j' es %d que está fuera del "
"rango [1,ncol=%d]. Utilice nombres de columnas en su lugar en 'j' para "
"agregar nuevas columnas."

#: assign.c:468
msgid "When deleting columns, i should not be provided"
msgstr "Al eliminar columnas, 'i' no debe ser proporcionado"

#: assign.c:474
#, c-format
msgid ""
"RHS of assignment to existing column '%s' is zero length but not NULL. If "
"you intend to delete the column use NULL. Otherwise, the RHS must have "
"length > 0; e.g., NA_integer_. If you are trying to change the column type "
"to be an empty list column then, as with all column type changes, provide a "
"full length RHS vector such as vector('list',nrow(DT)); i.e., 'plonk' in the "
"new column."
msgstr ""
"RHS de la asignación a la columna existente '%s' tiene longitud cero pero no "
"es NULL. Si tiene la intención de eliminar la columna, utilice NULL. De lo "
"contrario, el RHS debe tener una longitud > 0; por ejemplo, NA_integer_. Si "
"está intentando cambiar el tipo de columna para que sea una columna de lista "
"vacía, al igual que con todos los cambios de tipo de columna, proporcione un "
"vector RHS de longitud completa como vector('list',nrow(DT)) ; es decir, "
"pisar ('plonk') los datos sobre la nueva columna."

#: assign.c:481
#, c-format
msgid ""
"Tried to assign NULL to column '%s', but this column does not exist to remove"
msgstr ""
"Se intentó asignar NULL a la columna '%s', pero esta columna no existe para "
"eliminarla"

#: assign.c:489
#, c-format
msgid "%d column matrix RHS of := will be treated as one vector"
msgstr "matriz de %d columnas en RHS de := será tratada como un vector"

#: assign.c:494
#, c-format
msgid ""
"Can't assign to column '%s' (type 'factor') a value of type '%s' (not "
"character, factor, integer or numeric)"
msgstr ""
"No se puede asignar a la columna '%s' (escriba 'factor') un valor de tipo "
"'%s' (ni carácter, factor, número entero o numérico)"

#: assign.c:500
#, c-format
msgid ""
"Supplied %d items to be assigned to %d items of column '%s'. If you wish to "
"'recycle' the RHS please use rep() to make this intent clear to readers of "
"your code."
msgstr ""
"Se proporcionaron %d elementos para asignarlos a %d elementos de la columna "
"'%s'. Si desea 'recycle' el RHS, utilice rep() para dejar clara esta "
"intención a los lectores de su código."

#: assign.c:510
msgid ""
"This data.table has either been loaded from disk (e.g. using readRDS()/"
"load()) or constructed manually (e.g. using structure()). Please run setDT() "
"or setalloccol() on it first (to pre-allocate space for new columns) before "
"assigning by reference to it."
msgstr ""
"Esta data.table se ha cargado desde el disco (por ejemplo, usando readRDS()/"
"load()) o se ha construido manualmente (por ejemplo, usando estructura()). "
"Ejecute setDT() o setalloccol() en él primero (para preasignar espacio para "
"nuevas columnas) antes de asignarlo por referencia."

#: assign.c:513
#, c-format
msgid ""
"truelength (%d) is greater than 10,000 items over-allocated (length = %d). "
"See ?truelength. If you didn't set the datatable.alloccol option very large, "
"please report to data.table issue tracker including the result of "
"sessionInfo()."
msgstr ""
"truelength (%d) es mayor que 10000 elementos sobreasignados (length = %d). "
"Ver ?truelength. Si no configuró la opción datatable.alloccol en un tamaño "
"muy grande, informe al rastreador de problemas de data.table, incluido el "
"resultado de sessionInfo()."

#: assign.c:517
msgid ""
"It appears that at some earlier point, names of this data.table have been "
"reassigned. Please ensure to use setnames() rather than names<- or "
"colnames<-. Otherwise, please report to data.table issue tracker."
msgstr ""
"Parece que en algún momento anterior, los nombres de esta data.table han "
"sido reasignados. Asegúrese de utilizar setnames() en lugar de` names<-` o "
"`colnames<-`. De lo contrario, informe al rastreador de problemas de data."
"table."

#: assign.c:552
#, c-format
msgid ""
"RHS for item %d has been duplicated because MAYBE_REFERENCED==%d "
"MAYBE_SHARED==%d, but then is being plonked. length(values)==%d; "
"length(cols)==%d)\n"
msgstr ""
"RHS para el elemento %d se ha duplicado porque MAYBE_REFERENCED==%d "
"MAYBE_SHARED==%d, pero luego es pisado ('plonked'). length(values)==%d; "
"length(cols)==%d)\n"

#: assign.c:626
#, c-format
msgid ""
"Dropping index '%s' as it doesn't have '__' at the beginning of its name. It "
"was very likely created by v1.9.4 of data.table.\n"
msgstr ""
"Eliminando el índice '%s' ya que no tiene '__' al principio de su nombre. Es "
"muy probable que haya sido creado por la versión 1.9.4 de data.table.\n"

#: assign.c:671 assign.c:687
#, c-format
msgid "Dropping index '%s' due to an update on a key column\n"
msgstr ""
"Se elimina el índice '%s' debido a una actualización en una columna de "
"clave\n"

#: assign.c:680
#, c-format
msgid "Shortening index '%s' to '%s' due to an update on a key column\n"
msgstr ""
"Acortamiento del índice '%s' a '%s' debido a una actualización en una "
"columna de clave\n"

#: assign.c:738
#, c-format
msgid "target vector"
msgstr "vector objetivo"

#: assign.c:738
#, c-format
msgid "column %d named '%s'"
msgstr "columna %d llamada '%s'"

#: assign.c:772
#, c-format
msgid ""
"Cannot assign 'factor' to '%s'. Factors can only be assigned to factor, "
"character or list columns."
msgstr ""
"No se puede asignar 'factor' a '%s. Los factores sólo se pueden asignar a "
"columnas de factores, caracteres o listas."

#: assign.c:786
#, c-format
msgid ""
"Assigning factor numbers to %s. But %d is outside the level range [1,%d]"
msgstr ""
"Se asignan números de factor a %s. Pero %d está fuera del rango de nivel [1,"
"%d]"

#: assign.c:795
#, c-format
msgid ""
"Assigning factor numbers to %s. But %f is outside the level range [1,%d], or "
"is not a whole number."
msgstr ""
"Se asignan números de factor a %s. Pero %f está fuera del rango de niveles "
"[1,%d] o no es un número entero."

#: assign.c:801
#, c-format
msgid ""
"Cannot assign '%s' to 'factor'. Factor columns can be assigned factor, "
"character, NA in any type, or level numbers."
msgstr ""
"No se puede asignar '%s' a 'factor'. A las columnas de factores se les puede "
"asignar factor, carácter, NA de cualquier tipo, o números de nivel."

#: assign.c:861
msgid "Unable to allocate working memory of %zu bytes to combine factor levels"
msgstr ""
"No se puede asignar memoria de trabajo de %zu bytes para combinar niveles de "
"factor"

#: assign.c:887
#, c-format
msgid "Coercing 'character' RHS to '%s' to match the type of %s."
msgstr ""
"Coaccionando 'character' RHS a '%s' para que coincida con el tipo de %s."

#: assign.c:894
#, c-format
msgid "Cannot coerce 'list' RHS to 'integer64' to match the type of %s."
msgstr ""
"No se puede forzar a 'list' RHS a 'integer64' para que coincida con el tipo "
"de %s."

#: assign.c:899
#, c-format
msgid "Coercing 'list' RHS to '%s' to match the type of %s."
msgstr "Forzar 'list' RHS a '%s' para que coincida con el tipo de %s."

#: assign.c:904
#, c-format
msgid "Zero-copy coerce when assigning '%s' to '%s' %s.\n"
msgstr "Coacción de copia cero al asignar '%s' a '%s' %s.\n"

#: assign.c:1006
#, c-format
msgid "type '%s' cannot be coerced to '%s'"
msgstr "el tipo '%s' no puede ser forzado a '%s'"

#: assign.c:1164
#, c-format
msgid "Unsupported column type in assign.c:memrecycle '%s'"
msgstr "<assign.c> Tipo de columna no admitido: 'memrecycle' '%s'"

#: assign.c:1249
#, c-format
msgid "savetl_init checks failed (%d %d %p %p)"
msgstr "savetl_init: comprobaciones fallaron (%d %d %p %p)"

#: assign.c:1258
#, c-format
msgid "Failed to allocate initial %d items in savetl_init"
msgstr "No se pudieron asignar %d elementos iniciales en savetl_init"

#: assign.c:1274
#, c-format
msgid "Failed to realloc saveds to %d items in savetl"
msgstr "No se pudo hacer realloc() sobre 'saveds' a %d elementos en 'savetl'"

#: assign.c:1280
#, c-format
msgid "Failed to realloc savedtl to %d items in savetl"
msgstr "No se pudo hacer realloc() sobre 'savedtl' a %d elementos en 'savetl'"

#: assign.c:1303
msgid "x must be a character vector"
msgstr "x debe ser un vector de caracteres"

#: assign.c:1304
msgid "'which' must be an integer vector"
msgstr "'which' debe ser un vector entero"

#: assign.c:1305
msgid "'new' must be a character vector"
msgstr "'new' debe ser un vector de caracteres"

#: assign.c:1306
#, c-format
msgid "'new' is length %d. Should be the same as length of 'which' (%d)"
msgstr ""
"'new' tiene una longitud %d. Debe ser la misma que la longitud de "
"'which' (%d)"

#: assign.c:1309
#, c-format
msgid ""
"Item %d of 'which' is %d which is outside range of the length %d character "
"vector"
msgstr ""
"El elemento %d de 'which' es %d que está fuera del rango del vector de "
"caracteres de longitud %d"

#: between.c:12
#, c-format
msgid ""
"Incompatible vector lengths: length(x)==%d length(lower)==%d "
"length(upper)==%d. Each should be either length 1 or the length of the "
"longest."
msgstr ""
"Longitudes de vectores incompatibles: length(x)==%d length(lower)==%d "
"length(upper)==%d. Cada uno debe tener una longitud de 1 o la longitud del "
"más largo."

#: between.c:19
msgid "NAbounds must be TRUE or NA"
msgstr "'NAbounds' debe ser TRUE o NA"

#: between.c:64
#, c-format
msgid "Item %d of lower (%d) is greater than item %d of upper (%d)"
msgstr ""
"El elemento %d del inferior (%d) es mayor que el elemento %d del superior "
"(%d)"

#: between.c:82
#, c-format
msgid "between parallel processing of integer took %8.3fs\n"
msgstr "'between' con procesamiento paralelo de un número entero tomó %8.3fs\n"

#: between.c:88
msgid "x is integer64 but lower and/or upper are not."
msgstr "'x' es entero64 pero inferior y/o superior no lo son."

#: between.c:95
#, c-format
msgid ""
"Item %d of lower (%<PRId64>) is greater than item %d of upper (%<PRId64>)"
msgstr ""
"El elemento %d del inferior (%<PRId64>) es mayor que el elemento %d del "
"superior (%<PRId64>)"

#: between.c:112
#, c-format
msgid "between parallel processing of integer64 took %8.3fs\n"
msgstr "'between' con procesamiento paralelo de integer64 tomó %8.3fs\n"

#: between.c:115
msgid ""
"x is not integer64 but lower and/or upper is integer64. Please align classes."
msgstr ""
"'x' no es entero64 pero inferior y/o superior es entero64. Por favor alinee "
"las clases."

#: between.c:122
#, c-format
msgid "Item %d of lower (%f) is greater than item %d of upper (%f)"
msgstr ""
"El elemento %d de 'lower' (%f) es mayor que el elemento %d de 'upper' (%f)"

#: between.c:140
#, c-format
msgid "between parallel processing of double with open bounds took %8.3fs\n"
msgstr ""
"'between' con procesamiento paralelo de 'double' con intervalo abierto tomó "
"%8.3fs\n"

#: between.c:157
#, c-format
msgid "between parallel processing of double with closed bounds took %8.3fs\n"
msgstr ""
"'between' con procesamiento paralelo de 'double' con intervalo cerrado tomó "
"%8.3fs\n"

#: between.c:172
#, c-format
msgid "Item %d of lower ('%s') is greater than item %d of upper ('%s')"
msgstr ""
"El elemento %d de 'lower' ('%s') es mayor que el elemento %d de "
"'upper' ('%s')."

#: between.c:187
#, c-format
msgid "between non-parallel processing of character took %8.3fs\n"
msgstr "'between' con procesamiento no paralelo del carácter tomó %8.3fs\n"

#: bmerge.c:65
#, c-format
msgid "icols[%d]=%d outside range [1,length(i)=%d]"
msgstr "icols[%d]=%d fuera del rango [1,length(i)=%d]"

#: bmerge.c:66
#, c-format
msgid "xcols[%d]=%d outside range [1,length(x)=%d]"
msgstr "xcols[%d]=%d fuera del rango [1,length(x)=%d]"

#: bmerge.c:69
#, c-format
msgid "typeof x.%s (%s) != typeof i.%s (%s)"
msgstr "tipo de x.%s (%s) != tipo de i.%s (%s)"

#: bmerge.c:71 bmerge.c:383
#, c-format
msgid "Type '%s' is not supported for joining/merging"
msgstr "El tipo '%s' no es compatible para join/merge"

#: bmerge.c:77
msgid "roll is character but not 'nearest'"
msgstr "roll es un carácter pero no 'nearest'"

#: bmerge.c:78
msgid "roll='nearest' can't be applied to a character column, yet."
msgstr ""
"roll='nearest' todavía no se puede aplicar a una columna de caracteres."

#: bmerge.c:86
msgid "rollends must be a length 2 logical vector"
msgstr "'rollends' debe ser un vector lógico de longitud 2"

#: bmerge.c:115
msgid "Only '==' operator is supported for columns of type character."
msgstr "Solo se admite el operador '==' para columnas de tipo carácter."

#: chmatch.c:5
#, c-format
msgid "table is type '%s' (must be 'character' or NULL)"
msgstr "la tabla es del tipo '%s' (debe ser 'character' o NULL)"

#: chmatch.c:19
#, c-format
msgid "x is type '%s' (must be 'character' or NULL)"
msgstr "'x' es del tipo '%s' (debe ser 'character' o NULL)"

#: chmatch.c:105
#, c-format
msgid ""
"Failed to allocate %<PRIu64> bytes working memory in chmatchdup: "
"length(table)=%d length(unique(table))=%d"
msgstr ""
"Error al asignar %<PRIu64> bytes de memoria de trabajo en chmatchdup: "
"length(tabla)=%d length(unique(tabla))=%d"

#: cj.c:89
#, c-format
msgid "Type '%s' is not supported by CJ."
msgstr "El tipo '%s' no es soportado por CJ."

#: coalesce.c:14
msgid ""
"The first argument is a list, data.table or data.frame. In this case there "
"should be no other arguments provided."
msgstr ""
"El primer argumento es una lista, data.table o data.frame. En este caso no "
"deberían haber sido proporcionados otros argumentos."

#: coalesce.c:30
#, c-format
msgid ""
"Item 1 is a factor but item %d is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""
"El elemento 1 es un factor pero el elemento %d no es un factor. Cuando hay "
"factores involucrados, todos los elementos deben ser factores."

#: coalesce.c:32
#, c-format
msgid ""
"Item %d is a factor but its levels are not identical to the first item's "
"levels."
msgstr ""
"El elemento %d es un factor pero sus niveles no son idénticos a los niveles "
"del primer elemento."

#: coalesce.c:36
#, c-format
msgid ""
"Item %d is a factor but item 1 is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""
"El elemento %d es un factor pero el elemento 1 no es un factor. Cuando hay "
"factores involucrados, todos los elementos deben ser factores."

#: coalesce.c:39
#, c-format
msgid ""
"Item %d is type %s but the first item is type %s. Please coerce before "
"coalescing."
msgstr ""
"El elemento %d es del tipo %s pero el primer elemento es del tipo %s. Por "
"favor, coaccione antes de fusionarse."

#: coalesce.c:41
#, c-format
msgid "Item %d has a different class than item 1."
msgstr "El elemento %d tiene una clase diferente a la del elemento 1."

#: coalesce.c:44
#, c-format
msgid ""
"Item %d is length %d but the first item is length %d. Only singletons are "
"recycled."
msgstr ""
"El elemento %d tiene una longitud %d pero el primer elemento tiene una "
"longitud %d. Sólo se reciclan los singleton."

#: coalesce.c:48
msgid "coalesce copied first item (inplace=FALSE)\n"
msgstr "'coalesce' copió primer elemento (inplace=FALSE)\n"

#: coalesce.c:164 fifelse.c:193 shift.c:171 uniqlist.c:98 uniqlist.c:130
#: uniqlist.c:211 uniqlist.c:248 uniqlist.c:321
#, c-format
msgid "Type '%s' is not supported"
msgstr "El tipo '%s' no está soportado"

#: dogroups.c:85 gsumm.c:43
msgid "env is not an environment"
msgstr "env no es un entorno"

#: dogroups.c:109
#, c-format
msgid "!length(bynames)[%d]==length(groups)[%d]==length(grpcols)[%d]"
msgstr "!length(bynames)[%d]==length(groups)[%d]==length(grpcols)[%d]"

#: dogroups.c:131
msgid "row.names attribute of .SD not found"
msgstr "atributo row.names de .SD no encontrado"

#: dogroups.c:133
#, c-format
msgid ""
"row.names of .SD isn't integer length 2 with NA as first item; i.e., ."
"set_row_names(). [%s %d %d]"
msgstr ""
"row.names de .SD no tiene una longitud entera de 2 con NA como primer "
"elemento; es decir, .set_row_names(). [%s %d %d]"

#: dogroups.c:138
msgid "length(names)!=length(SD)"
msgstr "length(names)!=length(SD)"

#: dogroups.c:154
msgid "length(xknames)!=length(xSD)"
msgstr "length(xknames)!=length(xSD)"

#: dogroups.c:162
#, c-format
msgid "length(iSD)[%d] != length(jiscols)[%d]"
msgstr "length(iSD)[%d] != length(jiscols)[%d]"

#: dogroups.c:163
#, c-format
msgid "length(xSD)[%d] != length(xjiscols)[%d]"
msgstr "length(xSD)[%d] != length(xjiscols)[%d]"

#: dogroups.c:274
#, c-format
msgid "j evaluates to type '%s'. Must evaluate to atomic vector or list."
msgstr "j evalúa escribir '%s'. Debe evaluarse como vector atómico o lista."

#: dogroups.c:283
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) should be atomic vector or list. If you "
"are trying something like j=list(.SD,newcol=mean(colA)) then use := by group "
"instead (much quicker), or cbind or merge afterwards."
msgstr ""
"La entrada %d para el grupo %d en j=list(...) debe ser un vector atómico o "
"una lista. Si está intentando algo como j=list(.SD,newcol=mean(colA)), "
"utilice := por grupo en su lugar (mucho más rápido), o cbind o merge después."

#: dogroups.c:290
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) is an array with %d dimensions > 1, "
"which is disallowed. \"Break\" the array yourself with c() or as.vector() if "
"that is intentional."
msgstr ""
"La entrada %d para el grupo %d en j=list(...) es una matriz con %d "
"dimensiones > 1, lo cual no está permitido. \"Rompe\" la matriz tú mismo con "
"c() o as.vector() si es intencional."

#: dogroups.c:300
msgid ""
"RHS of := is NULL during grouped assignment, but it's not possible to delete "
"parts of a column."
msgstr ""
"RHS de := es NULL durante la asignación agrupada, pero no es posible "
"eliminar partes de una columna."

#: dogroups.c:304
#, c-format
msgid ""
"Supplied %d items to be assigned to group %d of size %d in column '%s'. The "
"RHS length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""
"Se suministraron %d elementos para asignarlos al grupo %d de tamaño %d en la "
"columna '%s'. La longitud del RHS debe ser 1 (los valores individuales están "
"bien) o coincidir exactamente con la longitud del LHS. Si desea 'recycle' el "
"RHS, utilice rep() explícitamente para dejar clara esta intención a los "
"lectores de su código."

#: dogroups.c:336
#, c-format
msgid "Group %d column '%s': %s"
msgstr "Grupo %d columna '%s': %s"

#: dogroups.c:343
msgid "j doesn't evaluate to the same number of columns for each group"
msgstr "'j' no evalúa el mismo número de columnas para cada grupo"

#: dogroups.c:377
#, c-format
msgid ""
"Column %d of j's result for the first group is NULL. We rely on the column "
"types of the first result to decide the type expected for the remaining "
"groups (and require consistency). NULL columns are acceptable for later "
"groups (and those are replaced with NA of appropriate type and recycled) but "
"not for the first. Please use a typed empty vector instead, such as "
"integer() or numeric()."
msgstr ""
"La columna %d del resultado de 'j' para el primer grupo es NULL. Nos basamos "
"en los tipos de columnas del primer resultado para decidir el tipo esperado "
"para los grupos restantes (y requerir coherencia). Las columnas NULL son "
"aceptables para grupos posteriores (y se reemplazan con NA del tipo "
"apropiado y se reciclan) pero no para el primero. Utilice en su lugar un "
"vector vacío con tipo, como integer() o numeric()."

#: dogroups.c:380
msgid ""
"j appears to be a named vector. The same names will likely be created over "
"and over again for each group and slow things down. Try and pass a named "
"list (which data.table optimizes) or an unnamed list() instead.\n"
msgstr ""
"'j' parece ser un vector con nombre. Es probable que se creen los mismos "
"nombres una y otra vez para cada grupo y que el proceso sea más lento. "
"Intente pasar una lista con nombre (que data.table optimiza) o una lista sin "
"nombre en su lugar.\n"

#: dogroups.c:382
#, c-format
msgid ""
"Column %d of j is a named vector (each item down the rows is named, "
"somehow). Please remove those names for efficiency (to save creating them "
"over and over for each group). They are ignored anyway.\n"
msgstr ""
"La columna %d de 'j' es un vector con nombre (cada elemento de las filas "
"tiene un nombre, de alguna manera). Elimine esos nombres para mayor "
"eficiencia (para evitar crearlos una y otra vez para cada grupo). Se ignoran "
"de todos modos.\n"

#: dogroups.c:390
msgid ""
"The result of j is a named list. It's very inefficient to create the same "
"names over and over again for each group. When j=list(...), any names are "
"detected, removed and put back after grouping has completed, for efficiency. "
"Using j=transform(), for example, prevents that speedup (consider changing "
"to :=). This message may be upgraded to warning in future.\n"
msgstr ""
"El resultado de 'j' es una lista con nombre. Es muy ineficaz crear los "
"mismos nombres una y otra vez para cada grupo. Cuando j=list(...), cualquier "
"nombre se detecta, se elimina y se vuelve a colocar después de que se haya "
"completado la agrupación, para mayor eficiencia. El uso de j=transform(), "
"por ejemplo, evita esa mejora en eficiencia (considere cambiar a :=). Es "
"posible que este mensaje se actualice a advertencia en el futuro.\n"

#: dogroups.c:402
#, c-format
msgid "dogroups: growing from %d to %d rows\n"
msgstr "dogroups: creciendo de %d a %d filas\n"

#: dogroups.c:403
#, c-format
msgid "dogroups: length(ans)[%d]!=ngrpcols[%d]+njval[%d]"
msgstr "dogrupos: length(ans)[%d]!=ngrpcols[%d]+njval[%d]"

#: dogroups.c:421
#, c-format
msgid ""
"Item %d of j's result for group %d is zero length. This will be filled with "
"%d NAs to match the longest column in this result. Later groups may have a "
"similar problem but only the first is reported to save filling the warning "
"buffer."
msgstr ""
"El elemento %d del resultado de 'j' para el grupo %d tiene longitud cero. "
"Esto se completará con %d NA para que coincida con la columna más larga de "
"este resultado. Los grupos posteriores pueden tener un problema similar, "
"pero solo se informa que el primero guarda el llenado del búfer de "
"advertencia."

#: dogroups.c:428
#, c-format
msgid ""
"Column %d of result for group %d is type '%s' but expecting type '%s'. "
"Column types must be consistent for each group."
msgstr ""
"La columna %d del resultado para el grupo %d es del tipo '%s' pero se espera "
"el tipo '%s'. Los tipos de columnas deben ser coherentes para cada grupo."

#: dogroups.c:430
#, c-format
msgid ""
"Supplied %d items for column %d of group %d which has %d rows. The RHS "
"length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""
"Se proporcionaron %d elementos para la columna %d del grupo %d que tiene %d "
"filas. La longitud del RHS debe ser 1 (los valores individuales están bien) "
"o coincidir exactamente con la longitud del LHS. Si desea 'recycle' en el "
"RHS, utilice rep() explícitamente para dejar clara esta intención a los "
"lectores de su código."

#: dogroups.c:448 fsort.c:250 fwrite.c:707
msgid "\n"
msgstr "\n"

#: dogroups.c:449
#, c-format
msgid ""
"\rProcessed %d groups out of %d. %.0f%% done. Time elapsed: %ds. ETA: %ds."
msgstr ""
"\rProcesados %d grupos de %d. %.0f%% finalizado. Tiempo transcurrido: %ds. "
"ETA: %ds."

#: dogroups.c:462
#, c-format
msgid ""
"\rProcessed %d groups out of %d. %.0f%% done. Time elapsed: %ds. ETA: %ds.\n"
msgstr ""
"\rProcesados %d grupos de %d. %.0f%% finalizado. Tiempo transcurrido: %ds. "
"ETA: %ds.\n"

#: dogroups.c:465
#, c-format
msgid "Wrote less rows (%d) than allocated (%d).\n"
msgstr "Escribió menos filas (%d) de las asignadas (%d).\n"

#: dogroups.c:489
#, c-format
msgid ""
"\n"
"  %s took %.3fs for %d groups\n"
msgstr ""
"\n"
" %s tomó %.3fs para %d grupos\n"

#: dogroups.c:491
#, c-format
msgid "  eval(j) took %.3fs for %d calls\n"
msgstr " eval(j) tomó %.3fs para %d llamadas\n"

#: dogroups.c:520
msgid "growVector passed NULL"
msgstr "growVector pasó NULL"

#: fastmean.c:39 rbindlist.c:8 rbindlist.c:12
#, c-format
msgid "%s should be TRUE or FALSE"
msgstr "%s debe ser TRUE o FALSE"

#: fastmean.c:45
#, c-format
msgid "fastmean was passed type %s, not numeric or logical"
msgstr "fastmean recibió tipo %s, no numérico ni lógico"

#: fcast.c:101
#, c-format
msgid "Unsupported column type in fcast val: '%s'"
msgstr "Tipo de columna no admitido en fcast val: '%s'"

#: fifelse.c:5
msgid "Argument 'test' must be logical."
msgstr "El argumento 'test' debe ser lógico."

#: fifelse.c:9
msgid "S4 class objects (except nanotime) are not supported."
msgstr "Los objetos de clase S4 (excepto nanotime) no son compatibles."

#: fifelse.c:24
#, c-format
msgid ""
"Length of 'yes' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""
"La longitud de 'yes' es %<PRId64> pero debe ser 1 o la longitud de "
"'test' (%<PRId64>)."

#: fifelse.c:26
#, c-format
msgid ""
"Length of 'no' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""
"La longitud de 'no' es %<PRId64> pero debe ser 1 o la longitud de "
"'test' (%<PRId64>)."

#: fifelse.c:28
#, c-format
msgid ""
"Length of 'na' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""
"La longitud de 'na' es %<PRId64> pero debe ser 1 o la longitud de "
"'test' (%<PRId64>)."

#: fifelse.c:46
#, c-format
msgid ""
"'no' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr ""
"'no' es del tipo %s pero '%s' es %s. Por favor haga que todos los argumentos "
"sean del mismo tipo."

#: fifelse.c:52
#, c-format
msgid ""
"'na' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr ""
"'na' es del tipo %s pero '%s' es %s. Por favor haga que todos los argumentos "
"sean del mismo tipo."

#: fifelse.c:57
msgid ""
"'yes' has different class than 'no'. Please make sure that both arguments "
"have the same class."
msgstr ""
"'yes' tiene una clase diferente a la de 'no'. Asegúrese de que ambos "
"argumentos tengan la misma clase."

#: fifelse.c:62
msgid ""
"'yes' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr ""
"'yes' tiene una clase diferente a la de 'na'. Asegúrese de que ambos "
"argumentos tengan la misma clase."

#: fifelse.c:67
msgid ""
"'no' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr ""
"'no' tiene una clase diferente a la de 'na'. Asegúrese de que ambos "
"argumentos tengan la misma clase."

#: fifelse.c:74
msgid "'yes' and 'no' are both type factor but their levels are different."
msgstr "'yes' y 'no' son factores de tipo pero sus niveles son diferentes."

#: fifelse.c:79
msgid "'yes' and 'na' are both type factor but their levels are different."
msgstr "'yes' y 'na' son factores de tipo pero sus niveles son diferentes."

#: fifelse.c:84
msgid "'no' and 'na' are both type factor but their levels are different."
msgstr "'no' y 'na' son factores de tipo pero sus niveles son diferentes."

#: fifelse.c:207
#, c-format
msgid ""
"Received %d inputs; please supply an even number of arguments in ..., "
"consisting of logical condition, resulting value pairs (in that order). Note "
"that the default argument must be named explicitly, e.g., default=0"
msgstr ""
"Se recibieron %d entradas; proporcione un número par de argumentos en..., "
"que consistan en pares condición lógica, valor resultante (en ese orden). "
"Tenga en cuenta que el argumento predeterminado debe nombrarse "
"explícitamente, por ejemplo, default=0"

#: fifelse.c:227
msgid ""
"S4 class objects (except nanotime) are not supported. Please see https://"
"github.com/Rdatatable/data.table/issues/4131."
msgstr ""
"Los objetos de clase S4 (excepto nanotime) no son compatibles. Consulte "
"https://github.com/Rdatatable/data.table/issues/4131."

#: fifelse.c:254
#, c-format
msgid ""
"Resulting value is of type %s but 'default' is of type %s. Please make sure "
"that both arguments have the same type."
msgstr ""
"El valor resultante es de tipo %s pero 'default' es de tipo %s. Asegúrese de "
"que ambos argumentos sean del mismo tipo."

#: fifelse.c:257
#, c-format
msgid ""
"Argument #%d is of type %s, however argument #2 is of type %s. Please make "
"sure all output values have the same type."
msgstr ""
"El argumento #%d es de tipo %s, sin embargo, el argumento #2 es de tipo %s. "
"Asegúrese de que todos los valores de salida sean del mismo tipo."

#: fifelse.c:265
msgid ""
"Resulting value has different class than 'default'. Please make sure that "
"both arguments have the same class."
msgstr ""
"El valor resultante tiene una clase diferente a 'default'. Asegúrese de que "
"ambos argumentos tengan la misma clase."

#: fifelse.c:268
#, c-format
msgid ""
"Argument #%d has different class than argument #2, Please make sure all "
"output values have the same class."
msgstr ""
"El argumento #%d tiene una clase diferente a la del argumento #2. Asegúrese "
"de que todos los valores de salida tengan la misma clase."

#: fifelse.c:277
msgid ""
"Resulting value and 'default' are both type factor but their levels are "
"different."
msgstr ""
"El valor resultante y 'default' son factores de tipo pero sus niveles son "
"diferentes."

#: fifelse.c:279
#, c-format
msgid ""
"Argument #2 and argument #%d are both factor but their levels are different."
msgstr ""
"El argumento #2 y el argumento #%d son ambos factores pero sus niveles son "
"diferentes."

#: fmelt.c:18
msgid "'x' must be an integer"
msgstr "'x' debe ser un número entero"

#: fmelt.c:19
msgid "'n' must be a positive integer"
msgstr "'n' debe ser un número entero positivo"

#: fmelt.c:41
msgid "Argument to 'which' must be logical"
msgstr "El argumento de 'which' debe ser lógico"

#: fmelt.c:65
msgid "concat: 'vec' must be a character vector"
msgstr "concat: 'vec' debe ser un vector de caracteres"

#: fmelt.c:66
msgid "concat: 'idx' must be an integer vector of length >= 0"
msgstr "concat: 'idx' debe ser un vector entero de longitud >= 0"

#: fmelt.c:134
#, c-format
msgid "Unknown 'measure.vars' type %s at index %d of list"
msgstr "Tipo 'measure.vars' desconocido %s en el índice %d de la lista"

#: fmelt.c:187
msgid "One or more values in 'measure.vars' is invalid."
msgstr "Uno o más valores en 'measure.vars' no son válidos."

#: fmelt.c:189
msgid "One or more values in 'id.vars' is invalid."
msgstr "Uno o más valores en 'id.vars' no son válidos."

#: fmelt.c:213
#, c-format
msgid ""
"Unknown 'measure.vars' type %s, must be character or integer vector/list"
msgstr ""
"Tipo 'measure.vars' desconocido %s, debe ser un vector/lista de caracteres o "
"enteros"

#: fmelt.c:215
#, c-format
msgid "Unknown 'id.vars' type %s, must be character or integer vector"
msgstr "Tipo 'id.vars' desconocido %s, debe ser un vector de carácter o entero"

#: fmelt.c:240
#, c-format
msgid ""
"id.vars and measure.vars are internally guessed when both are 'NULL'. All "
"non-numeric/integer/logical type columns are considered id.vars, which in "
"this case are columns [%s]. Consider providing at least one of 'id' or "
"'measure' vars in future."
msgstr ""
"id.vars y measure.vars se infieren internamente cuando ambos son 'NULL'. "
"Todas las columnas de tipo no numérico/entero/lógico se consideran id.vars, "
"que en este caso son columnas [%s]. Considere proporcionar al menos una de "
"las variables 'id' o 'measure' en el futuro."

#: fmelt.c:246
msgid ""
"'measure.vars' is missing. Assigning all columns other than 'id.vars' "
"columns as 'measure.vars'.\n"
msgstr ""
"Falta 'measure.vars'. Asignar todas las columnas que no sean 'id.vars' como "
"'measure.vars'.\n"

#: fmelt.c:248
#, c-format
msgid "Assigned 'measure.vars' are [%s].\n"
msgstr "Las 'measure.vars' asignadas son [%s].\n"

#: fmelt.c:259
msgid ""
"'id.vars' is missing. Assigning all columns other than 'measure.vars' "
"columns as 'id.vars'.\n"
msgstr ""
"Falta 'id.vars'. Asignar todas las columnas que no sean 'measure.vars' como "
"'id.vars'.\n"

#: fmelt.c:260
#, c-format
msgid "Assigned 'id.vars' are [%s].\n"
msgstr "Los 'id.vars' asignados son [%s].\n"

#: fmelt.c:314
msgid ""
"When 'measure.vars' is a list, 'value.name' must be a character vector of "
"length =1 or =length(measure.vars)."
msgstr ""
"Cuando 'measure.vars' es una lista, 'value.name' debe ser un vector de "
"caracteres de longitud =1 o =length(measure.vars)."

#: fmelt.c:315
msgid ""
"When 'measure.vars' is either not specified or a character/integer vector, "
"'value.name' must be a character vector of length =1."
msgstr ""
"Cuando no se especifica 'measure.vars' o es un vector de caracteres/entero, "
"'value.name' debe ser un vector de caracteres de longitud =1."

#: fmelt.c:318
msgid "'variable.name' must be a character/integer vector of length 1."
msgstr "'variable.name' debe ser un vector de carácter/entero de longitud 1."

#: fmelt.c:371
msgid ""
"variable_table attribute of measure.vars should be a data table with at "
"least one column"
msgstr ""
"el atributo variable_table de measure.vars debe ser una data.table con al "
"menos una columna"

#: fmelt.c:376
#, c-format
msgid ""
"variable_table attribute of measure.vars should be a data table with same "
"number of rows as max length of measure.vars vectors =%d"
msgstr ""
"El atributo variable_table de measure.vars debe ser una data.table con el "
"mismo número de filas que la longitud máxima de los vectores de measure.vars "
"=%d"

#: fmelt.c:380
msgid ""
"variable_table attribute of measure.vars should be either NULL or a data "
"table"
msgstr ""
"el atributo variable_table de measure.vars debe ser NULL o una data.table"

#: fmelt.c:463
#, c-format
msgid ""
"'measure.vars' [%s] are not all of the same type. By order of hierarchy, the "
"molten data value column will be of type '%s'. All measure variables not of "
"type '%s' will be coerced too. Check DETAILS in ?melt.data.table for more on "
"coercion.\n"
msgstr ""
"las 'measure.vars' [%s] no son todas del mismo tipo. Por orden de jerarquía, "
"la columna de valores de datos \"fundida\" será del tipo '%s'. Todas las "
"variables de medida que no sean del tipo '%s' también serán coercionadas. "
"Consulte los detalles en ?melt.data.table para obtener más información sobre "
"la coerción.\n"

#: fmelt.c:575
#, c-format
msgid "Unknown column type '%s' for column '%s'."
msgstr "Tipo de columna desconocida '%s' para la columna '%s'."

#: fmelt.c:685
#, c-format
msgid "variable_table does not support column type '%s' for column '%s'."
msgstr "variable_table no admite el tipo de columna '%s' para la columna '%s'."

#: fmelt.c:779
#, c-format
msgid "Unknown column type '%s' for column '%s' in 'data'"
msgstr "Tipo de columna desconocido '%s' para la columna '%s' en 'data'"

#: fmelt.c:790
msgid "Input is not of type VECSXP, expected a data.table, data.frame or list"
msgstr ""
"La entrada no es del tipo VECSXP, se esperaba una data.table, un data.frame "
"o una lista"

#: fmelt.c:791
msgid "Argument 'value.factor' should be logical TRUE/FALSE"
msgstr "El argumento 'value.factor' debe ser lógico TRUE/FALSE"

#: fmelt.c:792
msgid "Argument 'variable.factor' should be logical TRUE/FALSE"
msgstr "El argumento 'variable.factor' debe ser lógico TRUE/FALSE"

#: fmelt.c:793
msgid "Argument 'na.rm' should be logical TRUE/FALSE."
msgstr "El argumento 'na.rm' debe ser lógico TRUE/FALSE."

#: fmelt.c:794
msgid "Argument 'variable.name' must be a character vector"
msgstr "El argumento 'variable.name' debe ser un vector de caracteres"

#: fmelt.c:795
msgid "Argument 'value.name' must be a character vector"
msgstr "El argumento 'value.name' debe ser un vector de caracteres"

#: fmelt.c:796
msgid "Argument 'verbose' should be logical TRUE/FALSE"
msgstr "El argumento 'verbose' debe ser lógico TRUE/FALSE"

#: fmelt.c:800
msgid "ncol(data) is 0. Nothing to melt. Returning original data.table."
msgstr ""
"ncol(data) es 0. Nada que \"fundir\". Devolviendo la data.table original."

#: fmelt.c:805
msgid "names(data) is NULL. Please report to data.table-help"
msgstr "nombres(datos) es NULL. Por favor informe a data.table-help"

#: forder.c:121
#, c-format
msgid "Failed to realloc thread private group size buffer to %d*4bytes"
msgstr ""
"No se pudo reasignar el búfer del tamaño del grupo privado del hilo de "
"ejecución a %d*4bytes"

#: forder.c:135
#, c-format
msgid "Failed to realloc group size result to %d*4bytes"
msgstr "No se pudo reasignar el resultado del tamaño del grupo a %d*4bytes"

#: forder.c:269
#, c-format
msgid ""
"Logical error. counts[0]=%d in cradix but should have been decremented to 0. "
"radix=%d"
msgstr ""
"Error lógico. counts[0]=%d en cradix pero debería haberse reducido a 0. "
"radix=%d"

#: forder.c:320
#, c-format
msgid "Unable to realloc %d * %d bytes in range_str"
msgstr "No se puede reasignar %d * %d bytes en range_str"

#: forder.c:347
msgid "Failed to alloc ustr3 when converting strings to UTF8"
msgstr "No se pudo asignar ustr3 al convertir cadenas a UTF8"

#: forder.c:366
msgid "Failed to alloc tl when converting strings to UTF8"
msgstr "No se pudo asignar tl al convertir cadenas a UTF8"

#: forder.c:395
msgid "Must an integer or numeric vector length 1"
msgstr "Debe ser un vector entero o numérico de longitud 1"

#: forder.c:396
msgid "Must be 2, 1 or 0"
msgstr "Debe ser 2, 1 o 0"

#: forder.c:431
msgid "Unknown non-finite value; not NA, NaN, -Inf or +Inf"
msgstr "Valor desconocido no finito; no NA, NaN, -Inf o +Inf"

#: forder.c:457
msgid ""
"Input is an atomic vector (not a list of columns) but order= is not a length "
"1 integer"
msgstr ""
"La entrada es un vector atómico (no una lista de columnas) pero order= no es "
"un entero de longitud 1"

#: forder.c:459
#, c-format
msgid "forder.c received a vector type '%s' length %d\n"
msgstr "<forder.c>: recibió un tipo de vector '%s' de longitud %d\n"

#: forder.c:467
#, c-format
msgid "forder.c received %d rows and %d columns\n"
msgstr "<forder.c>: recibió %d filas y %d columnas\n"

#: forder.c:491
#, c-format
msgid ""
"Column %d is length %d which differs from length of column 1 (%d), are you "
"attempting to order by a list column?\n"
msgstr ""
"La columna %d tiene una longitud %d que difiere de la longitud de la columna "
"1 (%d). ¿Está intentando ordenarla por una columna de lista?\n"

#: forder.c:495
msgid "retGrp must be TRUE or FALSE"
msgstr "retGrp debe ser TRUE o FALSE"

#: forder.c:498
msgid "retStats must be TRUE or FALSE"
msgstr "retStats debe ser TRUE o FALSE"

#: forder.c:503
msgid "sort must be TRUE or FALSE"
msgstr "sort debe ser TRUE o FALSE"

#: forder.c:506
msgid "At least one of retGrp= or sort= must be TRUE"
msgstr "Al menos uno de retGrp= o sort= debe ser TRUE"

#: forder.c:508
msgid "na.last must be logical TRUE, FALSE or NA of length 1"
msgstr "na.last debe ser lógico TRUE, FALSE o NA de longitud 1"

#: forder.c:542 forder.c:656
#, c-format
msgid "Unable to allocate %<PRIu64> bytes of working memory"
msgstr "No se pueden asignar %<PRIu64> bytes de memoria de trabajo"

#: forder.c:560
#, c-format
msgid "Item %d of order (ascending/descending) is %d. Must be +1 or -1."
msgstr ""
"El elemento %d del orden (ascendente/descendente) es %d. Debe ser +1 o -1."

#: forder.c:586
#, c-format
msgid ""
"\n"
"*** Column %d passed to forder is a date stored as an 8 byte double but no "
"fractions are present. Please consider a 4 byte integer date such as IDate "
"to save space and time.\n"
msgstr ""
"\n"
"*** La columna %d pasada al forder es una fecha almacenada como un double de "
"8 bytes pero no hay fracciones presentes. Considere una fecha entera de 4 "
"bytes como IDate para ahorrar espacio y tiempo.\n"

#: forder.c:602
#, c-format
msgid "Column %d passed to [f]order is type '%s', not yet supported."
msgstr ""
"La columna %d pasada al pedido [f] es del tipo '%s' y aún no se admite."

#: forder.c:771
#, c-format
msgid "nradix=%d\n"
msgstr "nradix=%d\n"

#: forder.c:780
#, c-format
msgid ""
"Failed to allocate TMP or UGRP or they weren't cache line aligned: nth=%d"
msgstr ""
"No se pudo asignar TMP o UGRP o no estaban alineadas con la línea de caché: "
"nth=%d"

#: forder.c:789
msgid "Could not allocate (very tiny) group size thread buffers"
msgstr ""
"No se pudieron asignar búferes de hilos de (muy pequeños) tamaño de grupo"

#: forder.c:857
#, c-format
msgid "Timing block %2d%s = %8.3f   %8d\n"
msgstr "Bloque de tiempo %2d%s = %8.3f %8d\n"

#: forder.c:860
#, c-format
msgid "stat[%03d]==%20<PRIu64>\n"
msgstr "stat[%03d]==%20<PRIu64>\n"

#: forder.c:1133
#, c-format
msgid "Failed to allocate parallel counts. my_n=%d, nBatch=%d"
msgstr ""
"Fallo al asignar memoria para conteo de lotes en paralelo . my_n=%d, "
"nBatch=%d"

#: forder.c:1250
#, c-format
msgid "Unable to allocate TMP for my_n=%d items in parallel batch counting"
msgstr ""
"No se puede asignar TMP para my_n=%d elementos en el conteo de lotes en "
"paralelo"

#: forder.c:1365 forder.c:1416
#, c-format
msgid "issorted 'by' [%d] out of range [1,%d]"
msgstr "issorted 'by' [%d] fuera de rango [1,%d]"

#: forder.c:1370
msgid "is.sorted does not work on list columns"
msgstr "is.sorted no funciona en columnas de lista"

#: forder.c:1403 forder.c:1433 forder.c:1467
#, c-format
msgid "type '%s' is not yet supported"
msgstr "el tipo '%s' aún no es compatible"

#: forder.c:1480
msgid "x must be either NULL or an integer vector"
msgstr "'x' debe ser NULL o un vector entero"

#: forder.c:1482
msgid "nrow must be integer vector length 1"
msgstr "nrow debe ser un vector entero de longitud 1"

#: forder.c:1484
#, c-format
msgid "nrow==%d but must be >=0"
msgstr "nrow==%d pero debe ser >=0"

#: forder.c:1501
msgid "x must be type 'double'"
msgstr "'x' debe ser del tipo 'double'"

#: frank.c:14 frank.c:192
#, c-format
msgid "Item %d of 'cols' is %d which is outside 1-based range [1,ncol(x)=%d]"
msgstr ""
"El elemento %d de 'cols' es %d que está fuera del rango basado en 1 [1,"
"ncol(x)=%d]"

#: frank.c:24 frank.c:200
#, c-format
msgid ""
"Column %d of input list x is length %d, inconsistent with first column of "
"that item which is length %d."
msgstr ""
"La columna %d de la lista de entrada x tiene una longitud %d, inconsistente "
"con la primera columna de ese elemento que tiene una longitud %d."

#: frank.c:101 frank.c:234 transpose.c:97
#, c-format
msgid "Unsupported column type '%s'"
msgstr "Tipo de columna no admitido '%s'"

#: fread.c:154
#, c-format
msgid "System error %lu unmapping view of file\n"
msgstr "Error del sistema %lu al desasignar la vista del archivo\n"

#: fread.c:157
#, c-format
msgid "System errno %d unmapping file: %s\n"
msgstr "Error del sistema %d archivo de desasignación: %s\n"

#: fread.c:446
#, c-format
msgid "Unable to allocate %s of contiguous virtual RAM. %s allocation."
msgstr "No se puede asignar %s de RAM virtual contigua. %s asignación."

#: fread.c:451
#, c-format
msgid "Avoidable %.3f seconds. %s time to copy.\n"
msgstr " %.3f segundos evitables. %s tiempo para copiar.\n"

#: fread.c:452
#, c-format
msgid "  File copy in RAM took %.3f seconds.\n"
msgstr "  La copia del archivo en la RAM tomó %.3f segundos.\n"

#: fread.c:1283
msgid ""
"Previous fread() session was not cleaned up properly. Cleaned up ok at the "
"beginning of this fread() call.\n"
msgstr ""
"La sesión anterior de fread() no se limpió correctamente. Se limpió bien al "
"comienzo de esta llamada fread().\n"

#: fread.c:1286
msgid "[01] Check arguments\n"
msgstr "[01] Verificar argumentos\n"

#: fread.c:1293
#, c-format
msgid "  Using %d threads (omp_get_max_threads()=%d, nth=%d)\n"
msgstr " Usando %d hilos (omp_get_max_threads()=%d, nth=%d)\n"

#: fread.c:1315
#, c-format
msgid "freadMain: NAstring <<%s>> has whitespace at the beginning or end"
msgstr ""
"freadMain: NAstring <<%s>> tiene espacios en blanco al principio o al final"

#: fread.c:1319
#, c-format
msgid ""
"freadMain: NAstring <<%s>> is recognized as type boolean, this is not "
"permitted."
msgstr ""
"freadMain: NAstring <<%s>> se reconoce como tipo booleano, esto no está "
"permitido."

#: fread.c:1321
#, c-format
msgid "freadMain: NAstring <<%s>> and logical01=TRUE, this is not permitted."
msgstr "freadMain: NAstring <<%s>> y logic01=TRUE, esto no está permitido."

#: fread.c:1333
msgid "  No NAstrings provided.\n"
msgstr " No se proporcionan cadenas NA.\n"

#: fread.c:1335
msgid "  NAstrings = ["
msgstr " NAstrings = ["

#: fread.c:1338
msgid "]\n"
msgstr "]\n"

#: fread.c:1340
msgid "  One or more of the NAstrings looks like a number.\n"
msgstr " Una o más de las NAstrings parecen un número.\n"

#: fread.c:1342
msgid "  None of the NAstrings look like numbers.\n"
msgstr " Ninguna de las cadenas NA parece números.\n"

#: fread.c:1344
#, c-format
msgid "  skip num lines = %<PRId64>\n"
msgstr " saltar núm líneas = %<PRId64>\n"

#: fread.c:1345
#, c-format
msgid "  skip to string = <<%s>>\n"
msgstr " saltar a cadena = <<%s>>\n"

#: fread.c:1346
#, c-format
msgid "  show progress = %d\n"
msgstr " mostrar progreso = %d\n"

#: fread.c:1347
#, c-format
msgid "  0/1 column will be read as %s\n"
msgstr " 0/1 columna se leerá como %s\n"

#: fread.c:1359
#, c-format
msgid "sep == quote ('%c') is not allowed"
msgstr "sep == quote ('%c') no está permitido"

#: fread.c:1360
#, c-format
msgid "sep == dec ('%c') is not allowed"
msgstr "sep == dec ('%c') no está permitido"

#: fread.c:1361
#, c-format
msgid "quote == dec ('%c') is not allowed"
msgstr "quote == dec ('%c') no está permitido"

#: fread.c:1378
msgid "[02] Opening the file\n"
msgstr "[02] Abriendo el archivo\n"

#: fread.c:1381
msgid ""
"  `input` argument is provided rather than a file name, interpreting as raw "
"text to read\n"
msgstr ""
" Se proporciona el argumento `input` en lugar de un nombre de archivo, "
"interpretándose como texto sin formato para leer\n"

#: fread.c:1388
#, c-format
msgid "  Opening file %s\n"
msgstr " Abriendo archivo %s\n"

#: fread.c:1392 fread.c:1421
#, c-format
msgid "File not found: %s"
msgstr "Archivo no encontrado: %s"

#: fread.c:1396
#, c-format
msgid "Opened file ok but couldn't obtain its size: %s"
msgstr "Archivo abierto correctamente pero no se pudo obtener su tamaño: %s"

#: fread.c:1399 fread.c:1431
#, c-format
msgid "File is empty: %s"
msgstr "El archivo está vacío: %s"

#: fread.c:1400 fread.c:1432
#, c-format
msgid "  File opened, size = %s.\n"
msgstr " Archivo abierto, tamaño = %s.\n"

#: fread.c:1427
#, c-format
msgid "Unable to open file after %d attempts (error %lu): %s"
msgstr "No se puede abrir el archivo después de %d intentos (error %lu): %s"

#: fread.c:1429
#, c-format
msgid "GetFileSizeEx failed (returned 0) on file: %s"
msgstr "GetFileSizeEx falló (devolvió 0) en el archivo: %s"

#: fread.c:1434
#, c-format
msgid "This is Windows, CreateFileMapping returned error %lu for file %s"
msgstr ""
"Esto es Windows, CreateFileMapping devolvió el error %lu para el archivo %s"

#: fread.c:1441
#, c-format
msgid ""
"Opened %s file ok but could not memory map it. This is a %dbit process. %s."
msgstr ""
"Abierto el archivo %s correctamente pero no fue posible mapearlo en memoria. "
"Este es un proceso de %dbit. %s."

#: fread.c:1442
msgid "Please upgrade to 64bit"
msgstr "Actualice a 64 bits"

#: fread.c:1442
msgid "There is probably not enough contiguous virtual memory available"
msgstr "Probablemente no haya suficiente memoria virtual contigua disponible"

#: fread.c:1445
msgid "  Memory mapped ok\n"
msgstr " Memoria asignada correctamente\n"

#: fread.c:1464
msgid "[03] Detect and skip BOM\n"
msgstr "[03] Detectar y omitir BOM (marca de orden de bytes)\n"

#: fread.c:1468
msgid ""
"  UTF-8 byte order mark EF BB BF found at the start of the file and "
"skipped.\n"
msgstr ""
" Marca de orden de bytes UTF-8 EF BB BF encontrada al inicio del archivo y "
"omitida.\n"

#: fread.c:1473
msgid ""
"GB-18030 encoding detected, however fread() is unable to decode it. Some "
"character fields may be garbled.\n"
msgstr ""
"Se detectó la codificación GB-18030, sin embargo, fread() no puede "
"decodificarla. Es posible que algunos campos de caracteres estén confusos.\n"

#: fread.c:1476
msgid ""
"File is encoded in UTF-16, this encoding is not supported by fread(). Please "
"recode the file to UTF-8."
msgstr ""
"El archivo está codificado en UTF-16, esta codificación no es compatible con "
"fread(). Vuelva a codificar el archivo en UTF-8."

#: fread.c:1481
#, c-format
msgid "  Last byte(s) of input found to be %s and removed.\n"
msgstr " Los últimos bytes de entrada encontrados son %s y eliminados.\n"

#: fread.c:1484
msgid "Input is empty or only contains BOM or terminal control characters"
msgstr ""
"La entrada está vacía o solo contiene la lista de materiales o caracteres de "
"control del terminal"

#: fread.c:1491
msgid "[04] Arrange mmap to be \\0 terminated\n"
msgstr "[04] Organizar mmap para ser terminado en \\0 \n"

#: fread.c:1498
msgid ""
"  No \\n exists in the file at all, so single \\r (if any) will be taken as "
"one line ending. This is unusual but will happen normally when there is no "
"\\r either; e.g. a single line missing its end of line.\n"
msgstr ""
" No existe ningún \\n en el archivo, por lo que un único \\r (si lo hay) se "
"tomará como final de línea. Esto es inusual pero sucederá normalmente cuando "
"tampoco hay \\r; p.ej. si hay una sola línea a la que le falta el fin de "
"línea.\n"

#: fread.c:1499
msgid ""
"  \\n has been found in the input and different lines can end with different "
"line endings (e.g. mixed \\n and \\r\\n in one file). This is common and "
"ideal.\n"
msgstr ""
"se ha encontrado  \\n en la entrada y diferentes líneas pueden terminar con "
"diferentes finales de línea (por ejemplo, \\n y \\r\\n mezclados en un "
"archivo). Esto es común e ideal.\n"

#: fread.c:1523
#, c-format
msgid ""
"  File ends abruptly with '%c'. Final end-of-line is missing. Using cow page "
"to write 0 to the last byte.\n"
msgstr ""
" El archivo termina abruptamente con '%c'. Falta el último fin de línea. "
"Usando página COW  para escribir 0 en el último byte.\n"

#: fread.c:1529
msgid ""
"This file is very unusual: it ends abruptly without a final newline, and "
"also its size is a multiple of 4096 bytes. Please properly end the last row "
"with a newline using for example 'echo >> file' to avoid this "
msgstr ""
"Este archivo es muy inusual: termina abruptamente sin una nueva línea final, "
"y además su tamaño es múltiplo de 4096 bytes. Termine correctamente la "
"última fila con una nueva línea usando, por ejemplo, 'echo >> file' para "
"evitarlo. "

#: fread.c:1530
#, c-format
msgid "  File ends abruptly with '%c'. Copying file in RAM. %s copy.\n"
msgstr ""
" El archivo termina abruptamente con '%c'. Copiando archivo en RAM. %s (esta "
"copia).\n"

#: fread.c:1564
msgid "[05] Skipping initial rows if needed\n"
msgstr "[05] Saltando filas iniciales si es necesario\n"

#: fread.c:1570
#, c-format
msgid ""
"skip='%s' not found in input (it is case sensitive and literal; i.e., no "
"patterns, wildcards or regex)"
msgstr ""
"skip='%s' no se encuentra en la entrada (tenga en cuenta que distingue entre "
"mayúsculas y minúsculas y es literal; es decir, no hay patrones, comodines "
"ni expresiones regulares)"

#: fread.c:1576
#, c-format
msgid ""
"Found skip='%s' on line %<PRIu64>. Taking this to be header row or first row "
"of data.\n"
msgstr ""
"Encontrado skip='%s' en la línea %<PRIu64>. Tomando esto como fila de "
"encabezado o primera fila de datos.\n"

#: fread.c:1589
#, c-format
msgid "  Skipped to line %<PRIu64> in the file"
msgstr " Saltó a la línea %<PRIu64> en el archivo"

#: fread.c:1590
#, c-format
msgid "skip=%<PRIu64> but the input only has %<PRIu64> line%s"
msgstr "skip=%<PRIu64> pero la entrada solo tiene %<PRIu64> línea%s"

#: fread.c:1599
msgid ""
"Input is either empty, fully whitespace, or skip has been set after the last "
"non-whitespace."
msgstr ""
"La entrada está vacía, completamente con espacios en blanco o se ha omitido "
"después del último espacio que no es en blanco."

#: fread.c:1601
#, c-format
msgid "  Moved forward to first non-blank line (%d)\n"
msgstr " Se ha avanzado a la primera línea que no está en blanco (%d)\n"

#: fread.c:1602
#, c-format
msgid "  Positioned on line %d starting: <<%s>>\n"
msgstr " Posicionado en la línea %d comenzando en: <<%s>>\n"

#: fread.c:1624
msgid "[06] Detect separator, quoting rule, and ncolumns\n"
msgstr ""
"[06] Detectar separador, regla de entrecomillado y número de columnas\n"

#: fread.c:1628
msgid "  sep='\\n' passed in meaning read lines as single character column\n"
msgstr ""
" pasar sep='\n"
"' significa leer líneas como una sola columna de tipo carácter\n"

#: fread.c:1647
msgid "  Detecting sep automatically ...\n"
msgstr " Detectando 'sep' automáticamente...\n"

#: fread.c:1654
#, c-format
msgid "  Using supplied sep '%s'\n"
msgstr " Usando el 'sep' suministrado '%s'\n"

#: fread.c:1688
#, c-format
msgid "  with %d fields using quote rule %d\n"
msgstr " con %d campos usando la regla de entrecomillado %d\n"

#: fread.c:1738
#, c-format
msgid "  with %d lines of %d fields using quote rule %d\n"
msgstr " con %d líneas de %d campos usando la regla de entrecomillado %d\n"

#: fread.c:1745
msgid ""
"  No sep and quote rule found a block of 2x2 or greater. Single column "
"input.\n"
msgstr ""
" Ninguna regla de separación y entrecomillado encontró un bloque de 2x2 o "
"mayor. Entrada de una sola columna.\n"

#: fread.c:1761
msgid ""
"Single column input contains invalid quotes. Self healing only effective "
"when ncol>1"
msgstr ""
"La entrada de una sola columna contiene comillas no válidas. La "
"autorreparación sólo es efectiva cuando ncol>1"

#: fread.c:1766
#, c-format
msgid ""
"Found and resolved improper quoting in first %d rows. If the fields are not "
"quoted (e.g. field separator does not appear within any field), try "
"quote=\"\" to avoid this warning."
msgstr ""
"Se encontraron y resolvieron comillas incorrectas en las primeras %d filas. "
"Si los campos no están entrecomillados (por ejemplo, el separador de campos "
"no aparece dentro de ningún campo), intente quote=\"\" para evitar esta "
"advertencia."

#: fread.c:1787
#, c-format
msgid ""
"  Detected %d columns on line %d. This line is either column names or first "
"data row. Line starts as: <<%s>>\n"
msgstr ""
" Se detectaron %d columnas en la línea %d. Esta línea son nombres de "
"columnas o la primera fila de datos. La línea comienza como: <<%s>>\n"

#: fread.c:1789
#, c-format
msgid "  Quote rule picked = %d\n"
msgstr " Regla de entrecomillado elegida = %d\n"

#: fread.c:1790
#, c-format
msgid "  fill=%s and the most number of columns found is %d\n"
msgstr " fill=%s y el mayor número de columnas encontradas es %d\n"

#: fread.c:1796
msgid ""
"This file is very unusual: it's one single column, ends with 2 or more end-"
"of-line (representing several NA at the end), and is a multiple of 4096, too."
msgstr ""
"Este archivo es muy inusual: es una sola columna, termina con 2 o más "
"finales de línea (que representan varios NA al final) y también es un "
"múltiplo de 4096."

#: fread.c:1797
#, c-format
msgid "  Copying file in RAM. %s\n"
msgstr " Copiando archivo en RAM. %s\n"

#: fread.c:1803
msgid ""
"  1-column file ends with 2 or more end-of-line. Restoring last eol using "
"extra byte in cow page.\n"
msgstr ""
" El archivo de 1 columna termina con 2 o más finales de línea. Restaurando "
"el último eol usando un byte adicional en la página de vaca.\n"

#: fread.c:1822
msgid ""
"[07] Detect column types, dec, good nrow estimate and whether first row is "
"column names\n"
msgstr ""
"[07] Detecta tipos de columnas, dec, buena estimación de nrow y si la "
"primera fila son nombres de columnas\n"

#: fread.c:1823
#, c-format
msgid "  'header' changed by user from 'auto' to %s\n"
msgstr " 'header' cambiado por el usuario de 'auto' a %s\n"

#: fread.c:1829
#, c-format
msgid "Failed to allocate 2 x %d bytes for type and tmpType: %s"
msgstr "No se pudieron asignar 2 x %d bytes para tipo y tmpType: %s"

#: fread.c:1834
msgid "  sep=',' so dec set to '.'\n"
msgstr " sep=',' por lo que dec se establece en '.'\n"

#: fread.c:1858
#, c-format
msgid "  Number of sampling jump points = %d because "
msgstr " Número de puntos de salto de muestreo = %d porque "

#: fread.c:1859
#, c-format
msgid "nrow limit (%<PRIu64>) supplied\n"
msgstr "límite de nrow (%<PRIu64>) proporcionado\n"

#: fread.c:1860
msgid "jump0size==0\n"
msgstr "saltar0tamaño==0\n"

#: fread.c:1861
#, c-format
msgid ""
"(%<PRIu64> bytes from row 1 to eof) / (2 * %<PRIu64> jump0size) == "
"%<PRIu64>\n"
msgstr ""
"(%<PRIu64> bytes de la fila 1 al eof) / (2 * %<PRIu64> jump0size) == "
"%<PRIu64>\n"

#: fread.c:1900
#, c-format
msgid ""
"  A line with too-%s fields (%d/%d) was found on line %d of sample jump %d. "
"%s\n"
msgstr ""
" Se encontró una línea con %s campos (%d/%d) en la línea %d del salto de "
"muestra %d. %s\n"

#: fread.c:1901
msgid "few"
msgstr "pocos"

#: fread.c:1901
msgid "many"
msgstr "muchos"

#: fread.c:1901
msgid ""
"Most likely this jump landed awkwardly so type bumps here will be skipped."
msgstr ""
"Lo más probable es que este salto haya aterrizado de manera extraña, por lo "
"que se omitirán los golpes de tipo aquí."

#: fread.c:1924 fread.c:1950
#, c-format
msgid "  dec='%c' detected based on a balance of %d parsed fields\n"
msgstr " dec='%c' detectado en función de un balance de %d campos analizados\n"

#: fread.c:1934
#, c-format
msgid "  Type codes (jump %03d)    : %s  Quote rule %d\n"
msgstr " Códigos de tipo (salto %03d): %s Regla de entrecomillado %d\n"

#: fread.c:1956
#, c-format
msgid ""
"  'header' determined to be true due to column %d containing a string on row "
"1 and a lower type (%s) in the rest of the %<PRId64> sample rows\n"
msgstr ""
"  'header' se determinó como verdadero debido a que la columna %d contiene "
"una cadena en la fila 1 y un tipo inferior (%s) en el resto de las "
"%<PRId64>filas de muestra  \n"

#: fread.c:1970
#, c-format
msgid ""
"Types in 1st data row match types in 2nd data row but previous row has %d "
"fields. Taking previous row as column names."
msgstr ""
"Los tipos en la primera fila de datos coinciden con los tipos en la segunda "
"fila de datos, pero la fila anterior tiene %d campos. Tomando la fila "
"anterior como nombres de columna."

#: fread.c:1973
#, c-format
msgid ""
"Detected %d column names but the data has %d columns (i.e. invalid file). "
"Added %d extra default column name%s\n"
msgstr ""
"Se detectaron %d nombres de columnas pero los datos tienen %d columnas (es "
"decir, un archivo no válido). Se agrega/n %d nombre(s) predeterminado(s) "
"adicional/es de columna%s\n"

#: fread.c:1974
msgid ""
" for the first column which is guessed to be row names or an index. Use "
"setnames() afterwards if this guess is not correct, or fix the file write "
"command that created the file to create a valid file."
msgstr ""
" para la primera columna que se supone que son nombres de filas o un índice. "
"Utilice setnames() después si esta suposición no es correcta, o corrija el "
"comando de escritura de archivo que creó el archivo para crear un archivo "
"válido."

#: fread.c:1974
msgid "s at the end."
msgstr "s al final."

#: fread.c:1977
#, c-format
msgid ""
"Detected %d column names but the data has %d columns. Filling rows "
"automatically. Set fill=TRUE explicitly to avoid this warning.\n"
msgstr ""
"Se detectaron %d nombres de columnas pero los datos tienen %d columnas. "
"Llenando filas automáticamente. Establezca fill=TRUE explícitamente para "
"evitar esta advertencia.\n"

#: fread.c:1981
#, c-format
msgid "Failed to realloc 2 x %d bytes for type and tmpType: %s"
msgstr "Error al reasignar 2 x %d bytes para tipo y tmpType: %s"

#: fread.c:2001
#, c-format
msgid ""
"  'header' determined to be %s because there are%s number fields in the "
"first and only row\n"
msgstr ""
" 'header' determinado como %s porque hay %s campos numéricos en la primera y "
"única fila\n"

#: fread.c:2001
msgid " no"
msgstr " no"

#: fread.c:2004
msgid ""
"  'header' determined to be true because all columns are type string and a "
"better guess is not possible\n"
msgstr ""
" 'header' se determinó como verdadero porque todas las columnas son de tipo "
"cadena y no es posible realizar una suposición mejor\n"

#: fread.c:2006
msgid ""
"  'header' determined to be false because there are some number columns and "
"those columns do not have a string field at the top of them\n"
msgstr ""
" 'header' se determinó que es falso porque hay algunas columnas numéricas y "
"esas columnas no tienen un campo de cadena en la parte superior\n"

#: fread.c:2022
#, c-format
msgid "  Type codes (first row)   : %s  Quote rule %d\n"
msgstr " Códigos de tipo (primera fila): %s Regla de entrecomillado %d\n"

#: fread.c:2031
#, c-format
msgid ""
"  All rows were sampled since file is small so we know nrow=%<PRIu64> "
"exactly\n"
msgstr ""
" Se tomaron muestras de todas las filas ya que el archivo es pequeño, por lo "
"que sabemos exactamente nrow=%<PRIu64>\n"

#: fread.c:2043 fread.c:2050
msgid "  =====\n"
msgstr " =====\n"

#: fread.c:2044
#, c-format
msgid ""
"  Sampled %<PRIu64> rows (handled \\n inside quoted fields) at %d jump "
"points\n"
msgstr ""
" %<PRIu64> filas muestreadas (manejadas \\n dentro de los campos entre "
"comillas) en %d puntos de salto\n"

#: fread.c:2045
#, c-format
msgid ""
"  Bytes from first data row on line %d to the end of last row: %<PRIu64>\n"
msgstr ""
" Bytes desde la primera fila de datos en la línea %d hasta el final de la "
"última fila: %<PRIu64>\n"

#: fread.c:2046
#, c-format
msgid "  Line length: mean=%.2f sd=%.2f min=%d max=%d\n"
msgstr " Longitud de línea: media=%.2f sd=%.2f min=%d max=%d\n"

#: fread.c:2047
#, c-format
msgid "  Estimated number of rows: %<PRIu64> / %.2f = %<PRIu64>\n"
msgstr " Número estimado de filas: %<PRIu64> / %.2f = %<PRIu64>\n"

#: fread.c:2048
#, c-format
msgid ""
"  Initial alloc = %<PRIu64> rows (%<PRIu64> + %d%%) using bytes/"
"max(mean-2*sd,min) clamped between [1.1*estn, 2.0*estn]\n"
msgstr ""
" Asignación inicial = %<PRIu64> filas (%<PRIu64> + %d%%) usando bytes/"
"max(mean-2*sd,min) sujetos entre [1.1*estn, 2.0*estn]\n"

#: fread.c:2056
#, c-format
msgid "  Alloc limited to lower nrows=%<PRIu64> passed in.\n"
msgstr " Alloc limitado a nrows=%<PRIu64> inferior pasado.\n"

#: fread.c:2068
msgid "[08] Assign column names\n"
msgstr "[08] Asignando nombres de columnas\n"

#: fread.c:2077
#, c-format
msgid "Unable to allocate %d*%d bytes for column name pointers: %s"
msgstr ""
"No se pueden asignar %d*%d bytes para los punteros de nombre de columna: %s"

#: fread.c:2117
msgid "[09] Apply user overrides on column types\n"
msgstr ""
"[09] Aplicando sobreescritura de tipos de columnas provisto por el usuario\n"

#: fread.c:2121
msgid "  Cancelled by user: userOverride() returned false."
msgstr " Cancelado por el usuario: userOverride() devolvió false."

#: fread.c:2139
#, c-format
msgid ""
"Attempt to override column %d%s%.*s%s of inherent type '%s' down to '%s' "
"ignored. Only overrides to a higher type are currently supported. If this "
"was intended, please coerce to the lower type afterwards."
msgstr ""
"Se ignora el intento de sobreescribir tipo de columna %d%s%.*s%s del tipo "
"inherente '%s' a '%s'. Actualmente solo se admiten reemplazos a un tipo "
"superior. Si esto era lo que pretendía, coercione al tipo inferior después."

#: fread.c:2154
#, c-format
msgid "  After %d type and %d drop user overrides : %s\n"
msgstr " Después de %d tipo y %d eliminar sobreescrituras de usuario: %s\n"

#: fread.c:2162
msgid "[10] Allocate memory for the datatable\n"
msgstr "[10] Asignar memoria para la data.table\n"

#: fread.c:2163
#, c-format
msgid "  Allocating %d column slots (%d - %d dropped) with %<PRIu64> rows\n"
msgstr ""
" Asignando %d espacios de columna (%d - %d eliminados) con %<PRIu64> filas\n"

#: fread.c:2218
#, c-format
msgid "Buffer size %<PRId64> is too large\n"
msgstr "El tamaño del búfer %<PRId64> es demasiado grande\n"

#: fread.c:2221
msgid "[11] Read the data\n"
msgstr "[11] Leer los datos\n"

#: fread.c:2224
#, c-format
msgid "  jumps=[%d..%d), chunk_size=%<PRIu64>, total_size=%<PRIu64>\n"
msgstr " jumps=[%d..%d), chunk_size=%<PRIu64>, total_size=%<PRIu64>\n"

#: fread.c:2450
#, c-format
msgid ""
"Column %d%s%.*s%s bumped from '%s' to '%s' due to <<%.*s>> on row %<PRIu64>\n"
msgstr ""
"La columna %d%s%.*s%s pasó de '%s' a '%s' debido a <<%.*s>> en la fila "
"%<PRIu64>\n"

#: fread.c:2568
#, c-format
msgid "  Provided number of fill columns: %d but only found %d\n"
msgstr ""
" Número proporcionado de columnas de relleno: %d pero solo se encontró %d\n"

#: fread.c:2569
#, c-format
msgid "  Dropping %d overallocated columns\n"
msgstr " Descartando %d columnas sobreasignadas\n"

#: fread.c:2587
msgid "Please report to the data.table issues tracker"
msgstr "Favor informe al rastreador de problemas de data.table"

#: fread.c:2594
#, c-format
msgid ""
"  Too few rows allocated. Allocating additional %<PRIu64> rows (now "
"nrows=%<PRIu64>) and continue reading from jump %d\n"
msgstr ""
" Muy pocas filas asignadas en memoria. Asignar %<PRIu64> filas adicionales "
"(ahora nrows=%<PRIu64>) y continuar leyendo desde el salto %d\n"

#: fread.c:2601
#, c-format
msgid "  Restarting team from jump %d. nSwept==%d quoteRule==%d\n"
msgstr " Reiniciando desde el salto %d. nSwept==%d quoteRule==%d\n"

#: fread.c:2621
#, c-format
msgid "  %d out-of-sample type bumps: %s\n"
msgstr " %d aumentos de tipo fuera de muestra: %s\n"

#: fread.c:2656
#, c-format
msgid ""
"Read %<PRIu64> rows x %d columns from %s file in %02d:%06.3f wall clock "
"time\n"
msgstr ""
"Leer %<PRIu64> filas x %d columnas del archivo %s en %02d:%06.3f tiempo "
"actual\n"

#: fread.c:2663
msgid "[12] Finalizing the datatable\n"
msgstr "[12] Finalizando la data.table\n"

#: fread.c:2664
msgid "  Type counts:\n"
msgstr " El tipo cuenta:\n"

#: fread.c:2666
#, c-format
msgid "%10d : %-9s '%c'\n"
msgstr "%10d : %-9s '%c'\n"

#: fread.c:2682
#, c-format
msgid "Discarded single-line footer: <<%s>>"
msgstr "Pie de página de una sola línea descartado: <<%s>>"

#: fread.c:2691
#, c-format
msgid ""
"Stopped early on line %<PRIu64>. Expected %d fields but found %d. Consider "
"fill=TRUE and comment.char=. First discarded non-empty line: <<%s>>"
msgstr ""
"Se detuvo anticipadamente en la línea %<PRIu64>. Se esperaban %d campos pero "
"se encontraron %d. Considere fill=TRUE y comment.char=. Primera línea no "
"vacía descartada: <<%s>>"

#: fread.c:2698
#, c-format
msgid ""
"Found and resolved improper quoting out-of-sample. First healed line "
"%<PRIu64>: <<%s>>. If the fields are not quoted (e.g. field separator does "
"not appear within any field), try quote=\"\" to avoid this warning."
msgstr ""
"Se encontraron y resolvieron comillas inadecuadas fuera de la muestra. "
"Primera línea saneada %<PRIu64>: <<%s>>. Si los campos no están "
"entrecomillados (por ejemplo, el separador de campos no aparece dentro de "
"ningún campo), intente quote=\"\" para evitar esta advertencia."

#: fread.c:2702
msgid "=============================\n"
msgstr "==============================\n"

#: fread.c:2704
#, c-format
msgid "%8.3fs (%3.0f%%) Memory map %.3fGB file\n"
msgstr "%8.3fs (%3.0f%%) Archivo de mapa de memoria de %.3fGB\n"

#: fread.c:2705
#, c-format
msgid "%8.3fs (%3.0f%%) sep="
msgstr "%8.3fs (%3.0f%%) sep="

#: fread.c:2707
#, c-format
msgid " ncol=%d and header detection\n"
msgstr " ncol=%dy detección de encabezado\n"

#: fread.c:2708
#, c-format
msgid "%8.3fs (%3.0f%%) Column type detection using %<PRIu64> sample rows\n"
msgstr ""
"%8.3fs (%3.0f%%) Detección de tipo de columna usando %<PRIu64> filas de "
"muestra\n"

#: fread.c:2710
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Allocation of %<PRIu64> rows x %d cols (%.3fGB) of which "
"%<PRIu64> (%3.0f%%) rows used\n"
msgstr ""
"%8.3fs (%3.0f%%) Asignación de %<PRIu64> filas x %d columnas (%.3fGB) de las "
"cuales se utilizan %<PRIu64> (%3.0f%%) filas\n"

#: fread.c:2714
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Reading %d chunks (%d swept) of %.3fMB (each chunk %d rows) "
"using %d threads\n"
msgstr ""
"%8.3fs (%3.0f%%) Leyendo %d fragmentos (%d barridos) de %.3fMB (cada "
"fragmento %d filas) usando %d hilos\n"

#: fread.c:2716
#, c-format
msgid ""
"   + %8.3fs (%3.0f%%) Parse to row-major thread buffers (grown %d times)\n"
msgstr ""
" + %8.3fs (%3.0f%%) Parsear a búferes de hilo por fila principal (aumentados "
"%d veces)\n"

#: fread.c:2717
#, c-format
msgid "   + %8.3fs (%3.0f%%) Transpose\n"
msgstr " + %8.3fs (%3.0f%%) Transponer\n"

#: fread.c:2718
#, c-format
msgid "   + %8.3fs (%3.0f%%) Waiting\n"
msgstr " + %8.3fs (%3.0f%%) Esperando\n"

#: fread.c:2719
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Rereading %d columns due to out-of-sample type exceptions\n"
msgstr ""
"%8.3fs (%3.0f%%) Releyendo %d columnas debido a excepciones de tipo fuera de "
"muestra\n"

#: fread.c:2721
#, c-format
msgid "%8.3fs        Total\n"
msgstr "%8.3fsTotal\n"

#: freadR.c:92
#, c-format
msgid "freadR.c has been passed a filename: %s\n"
msgstr "<freadR.c>: se ha pasado un nombre de archivo: %s\n"

#: freadR.c:96
msgid "freadR.c has been passed the data as text input (not a filename)\n"
msgstr ""
"<freadR.c>: se han pasado los datos como entrada de texto (no como nombre de "
"archivo)\n"

#: freadR.c:114
msgid "quote= must be a single character, blank \"\", or FALSE"
msgstr "quote= debe ser un solo carácter, \"\", o FALSE"

#: freadR.c:158
#, c-format
msgid "nThread(%d)<1"
msgstr "nThread(%d)<1"

#: freadR.c:166
msgid "'integer64' must be a single character string"
msgstr "'integer64' debe ser una cadena de un solo carácter"

#: freadR.c:174
#, c-format
msgid ""
"Invalid value integer64='%s'. Must be 'integer64', 'character', 'double' or "
"'numeric'"
msgstr ""
"Valor no válido entero64='%s'. Debe ser 'integer64', 'character', 'double' o "
"'^n^u^m^ e^r^i^c'"

#: freadR.c:182
msgid "Use either select= or drop= but not both."
msgstr "Utilice select= o drop= pero no ambos."

#: freadR.c:185
msgid ""
"select= is type list for specifying types in select=, but colClasses= has "
"been provided as well. Please remove colClasses=."
msgstr ""
"select= es una lista de tipos para especificar tipos en select=, pero "
"también se ha proporcionado colClasses=. Elimine colClasses=."

#: freadR.c:187
msgid ""
"select= is type list but has no names; expecting list(type1=cols1, "
"type2=cols2, ...)"
msgstr ""
"select= es una lista de tipos pero no tiene nombres; se esperaba "
"list(tipo1=cols1, tipo2=cols2, ...)"

#: freadR.c:194
msgid ""
"select= is a named vector specifying the columns to select and their types, "
"but colClasses= has been provided as well. Please remove colClasses=."
msgstr ""
"select= es un vector con nombre que especifica las columnas a seleccionar y "
"sus tipos, pero también se ha proporcionado colClasses=. Elimine colClasses=."

#: freadR.c:202 freadR.c:368
msgid "colClasses is type list but has no names"
msgstr "colClasses es una lista de tipos pero no tiene nombres"

#: freadR.c:212
#, c-format
msgid "encoding='%s' invalid. Must be 'unknown', 'Latin-1' or 'UTF-8'"
msgstr "codificación='%s' no válida. Debe ser 'unknown', 'Latin-1' o 'UTF-8'"

#: freadR.c:235
#, c-format
msgid "Column name '%s' (%s) not found"
msgstr "Nombre de columna '%s' (%s) no encontrada"

#: freadR.c:237
#, c-format
msgid "%s is NA"
msgstr "%s es NA"

#: freadR.c:239
#, c-format
msgid "%s is %d which is out of range [1,ncol=%d]"
msgstr "%s es %d que está fuera de rango [1,ncol=%d]"

#: freadR.c:288
#, c-format
msgid ""
"Column name '%s' not found in column name header (case sensitive), skipping."
msgstr ""
"El nombre de columna '%s' no se encuentra en el encabezado de nombres de "
"columna (distingue entre mayúsculas y minúsculas), omitiendo."

#: freadR.c:298
#, c-format
msgid ""
"Column number %d (select[%d]) is negative but should be in the range [1,"
"ncol=%d]. Consider drop= for column exclusion."
msgstr ""
"El número de columna %d (select[%d]) es negativo pero debe estar en el rango "
"[1,ncol=%d]. Considere drop= para la exclusión de columnas."

#: freadR.c:299
#, c-format
msgid ""
"select = 0 (select[%d]) has no meaning. All values of select should be in "
"the range [1,ncol=%d]."
msgstr ""
"select = 0 (select[%d]) no tiene sentido. Todos los valores de select deben "
"estar en el rango [1,ncol=%d]."

#: freadR.c:300
#, c-format
msgid ""
"Column number %d (select[%d]) is too large for this table, which only has %d "
"columns."
msgstr ""
"El número de columna %d (select[%d]) es demasiado grande para esta tabla, "
"que solo tiene %d columnas."

#: freadR.c:301
#, c-format
msgid "Column number %d ('%s') has been selected twice by select="
msgstr ""
"El número de columna %d ('%s') ha sido seleccionado dos veces por select="

#: freadR.c:324
#, c-format
msgid ""
"colClasses= is an unnamed vector of types, length %d, but there are %d "
"columns in the input. To specify types for a subset of columns, you can use "
"a named vector, list format, or specify types using select= instead of "
"colClasses=. Please see examples in ?fread."
msgstr ""
"colClasses= es un vector de tipos sin nombre, longitud %d, pero hay %d "
"columnas en la entrada. Para especificar tipos para un subconjunto de "
"columnas, puede usar un vector con nombre, un formato de lista o especificar "
"tipos usando select= en lugar de colClasses=. Consulte ejemplos en ?fread."

#: freadR.c:366
#, c-format
msgid "colClasses is type '%s' but should be list or character"
msgstr "colClasses es del tipo '%s' pero debe ser una lista o un carácter"

#: freadR.c:390
#, c-format
msgid "Column name '%s' (colClasses[[%d]][%d]) not found"
msgstr "Nombre de columna '%s' (colClasses[[%d]][%d]) no encontrada"

#: freadR.c:392
#, c-format
msgid "colClasses[[%d]][%d] is NA"
msgstr "colClasses[[%d]][%d] es NA"

#: freadR.c:396
#, c-format
msgid "Column number %d (colClasses[[%d]][%d]) is out of range [1,ncol=%d]"
msgstr ""
"El número de columna %d (colClasses[[%d]][%d]) está fuera de rango [1,"
"ncol=%d]"

#: freadR.c:400
#, c-format
msgid ""
"Column %d ('%s') appears more than once in colClasses. The second time is "
"colClasses[[%d]][%d]."
msgstr ""
"La columna %d ('%s') aparece más de una vez en colClasses. La segunda vez es "
"colClasses[[%d]][%d]."

#: freadR.c:640
#, c-format
msgid "Field size is 1 but the field is of type %d\n"
msgstr "El tamaño del campo es 1 pero el campo es de tipo %d\n"

#: freadR.c:717 utils.c:387
#, c-format
msgid "%s"
msgstr "%s"

#: froll.c:14 froll.c:223 froll.c:407
#, c-format
msgid "%s: window width longer than input vector, returning all NA vector\n"
msgstr ""
"%s: ancho de ventana más largo que el vector de entrada, devolviendo vector "
"de NAs\n"

#: froll.c:32 froll.c:240 froll.c:456
#, c-format
msgid "%s: align %d, shift answer by %d\n"
msgstr "%s: 'align'=%d, se desplaza respuesta en %d\n"

#: froll.c:39 froll.c:247 frolladaptive.c:19 frolladaptive.c:214
#, c-format
msgid "%s: processing algo %u took %.3fs\n"
msgstr "%s: procesando algoritmo 'algo'=%u tomó %.3fs\n"

#: froll.c:48 froll.c:251
#, c-format
msgid "%s: running for input length %<PRIu64>, window %d, hasna %d, narm %d\n"
msgstr ""
"%s: corriendo para longitud de entrada %<PRIu64>, ventana %d, hasna %d, narm "
"%d\n"

#: froll.c:68 froll.c:78 froll.c:169 froll.c:271 froll.c:281 froll.c:362
#: frolladaptive.c:58 frolladaptive.c:147 frolladaptive.c:247
#: frolladaptive.c:326
#, c-format
msgid ""
"%s: hasNA=FALSE used but NA (or other non-finite) value(s) are present in "
"input, use default hasNA=NA to avoid this warning"
msgstr ""
"%s: hasNA=FALSE usado pero NA (u otros valores no finitos) están presentes "
"en la entrada, use el valor por defecto 'hasNA'=NA para evitar esta "
"advertencia"

#: froll.c:71 froll.c:173 froll.c:274 froll.c:366 frolladaptive.c:61
#: frolladaptive.c:151 frolladaptive.c:250 frolladaptive.c:330
#, c-format
msgid ""
"%s: NA (or other non-finite) value(s) are present in input, re-running with "
"extra care for NAs\n"
msgstr ""
"%s: Los valores NA (u otros no finitos) están presentes en la entrada, "
"volviendo a ejecutar con especial cuidado para los NA\n"

#: froll.c:81 froll.c:284
#, c-format
msgid ""
"%s: NA (or other non-finite) value(s) are present in input, skip non-NA "
"attempt and run with extra care for NAs\n"
msgstr ""
"%s: Los valores NA (u otros no finitos) están presentes en la entrada: "
"omitiendo intento sin Nas y ejecutando con especial cuidado para los NA\n"

#: froll.c:137 froll.c:335
#, c-format
msgid ""
"%s: running in parallel for input length %<PRIu64>, window %d, hasna %d, "
"narm %d\n"
msgstr ""
"%s: ejecutándose en paralelo para la longitud de entrada %<PRIu64>, ventana "
"%d, hasna %d, narm %d\n"

#: froll.c:175 froll.c:368 frolladaptive.c:153 frolladaptive.c:332
#, c-format
msgid ""
"%s: NA (or other non-finite) value(s) are present in input, na.rm was FALSE "
"so in 'exact' implementation NAs were handled already, no need to re-run\n"
msgstr ""
"%s: Los valores NA (u otros no finitos) están presentes en la entrada, na.rm "
"era FALSE, por lo que en la implementación 'exact' los NA ya se manejaron, "
"no es necesario volver a ejecutar\n"

#: froll.c:424
#, c-format
msgid "%s: results from provided FUN are not length 1"
msgstr "%s: los resultados de FUN proporcionados no tienen una longitud de 1"

#: froll.c:431
#, c-format
msgid ""
"%s: results from provided FUN are not of type double, coercion from integer "
"or logical will be applied on each iteration\n"
msgstr ""
"%s: los resultados de FUN proporcionados no son de tipo double, se aplicará "
"coerción de entero o lógico en cada iteración\n"

#: froll.c:434
#, c-format
msgid "%s: results from provided FUN are not of type double"
msgstr "%s: los resultados de FUN proporcionados no son de tipo double"

#: froll.c:463 nafill.c:87
#, c-format
msgid "%s: took %.3fs\n"
msgstr "%s: tomó %.3fs\n"

#: frollR.c:17
msgid ""
"x must be of type numeric or logical, or a list, data.frame or data.table of "
"such"
msgstr ""
"'x' debe ser de tipo numérico o lógico, o una lista, data.frame o data.table "
"con esos tipos"

#: frollR.c:38 frollR.c:244
msgid "n must be non 0 length"
msgstr "n debe tener una longitud distinta de 0"

#: frollR.c:49
msgid "n must be integer, list is accepted for adaptive TRUE"
msgstr "n debe ser un número entero, se acepta una lista para TRUE adaptativo"

#: frollR.c:56 frollR.c:236 frollR.c:239
msgid "n must be integer"
msgstr "n debe ser un número entero"

#: frollR.c:63
msgid "n must be positive integer values (> 0)"
msgstr "n deben ser valores enteros positivos (> 0)"

#: frollR.c:72 frollR.c:84
msgid "n must be integer vector or list of integer vectors"
msgstr "n debe ser un vector entero o una lista de vectores enteros"

#: frollR.c:98
msgid "hasNA must be TRUE, FALSE or NA"
msgstr "hasNA debe ser TRUE, FALSE o NA"

#: frollR.c:100
msgid ""
"using hasNA FALSE and na.rm TRUE does not make sense, if you know there are "
"NA values use hasNA TRUE, otherwise leave it as default NA"
msgstr ""
"usar hasNA FALSE y na.rm TRUE no tiene sentido, si sabe que hay valores NA "
"usa hasNA = TRUE, de lo contrario dejelo como NA predeterminado"

#: frollR.c:113
msgid ""
"using adaptive TRUE and align argument different than 'right' is not "
"implemented"
msgstr ""
"el uso de TRUE adaptativo y un argumento de alineación diferente a 'right' "
"no está implementado"

#: frollR.c:117 frollR.c:267 types.c:64
#, c-format
msgid "%s: allocating memory for results %dx%d\n"
msgstr "%s: asignando memoria para resultados %dx%d\n"

#: frollR.c:126
msgid ""
"adaptive rolling function can only process 'x' having equal length of "
"elements, like data.table or data.frame; If you want to call rolling "
"function on list having variable length of elements call it for each field "
"separately"
msgstr ""
"la función de ventana adaptativa solo puede procesar 'x' que tenga la misma "
"longitud de elementos, como data.table o data.frame; Si desea llamar a la "
"función de ventana en una lista que tiene elementos de longitud variable, "
"llámela para cada campo por separado"

#: frollR.c:128
msgid ""
"length of integer vector(s) provided as list to 'n' argument must be equal "
"to number of observations provided in 'x'"
msgstr ""
"la longitud de los vectores enteros proporcionados como lista para el "
"argumento 'n' debe ser igual al número de observaciones proporcionadas en 'x'"

#: frollR.c:146 frollR.c:259 gsumm.c:1198 shift.c:21
msgid "fill must be a vector of length 1"
msgstr "'fill' debe ser un vector de longitud 1"

#: frollR.c:148 frollR.c:261
msgid "fill must be numeric or logical"
msgstr "el relleno debe ser numérico o lógico"

#: frollR.c:178
#, c-format
msgid ""
"%s: %d column(s) and %d window(s), if product > 1 then entering parallel "
"execution\n"
msgstr ""
"%s: %d columnas y %d ventanas, si producto > 1 entonces se ingresa a "
"ejecución en paralelo\n"

#: frollR.c:180
#, c-format
msgid ""
"%s: %d column(s) and %d window(s), not entering parallel execution here "
"because algo='exact' will compute results in parallel\n"
msgstr ""
"%s: %d columnas y %d ventanas, no se ingresa la ejecución en paralelo aquí "
"porque algo='exact' calculará los resultados en paralelo\n"

#: frollR.c:207 frollR.c:299
#, c-format
msgid "%s: processing of %d column(s) and %d window(s) took %.3fs\n"
msgstr "%s: el procesamiento de %d columnas y %d ventanas tomó %.3fs\n"

#: frolladaptive.c:29 frolladaptive.c:218
#, c-format
msgid "%s: running for input length %<PRIu64>, hasna %d, narm %d\n"
msgstr "%s: corriendo para longitud de entrada %<PRIu64>, hasna %d, narm %d\n"

#: frolladaptive.c:35 frolladaptive.c:224
#, c-format
msgid "%s: Unable to allocate memory for cumsum"
msgstr "%s: No se puede asignar memoria para cumsum"

#: frolladaptive.c:71 frolladaptive.c:260
#, c-format
msgid "%s: Unable to allocate memory for cum NA counter"
msgstr "%s: No se puede asignar memoria para el contador de NA cumulativo"

#: frolladaptive.c:114 frolladaptive.c:298
#, c-format
msgid "%s: running in parallel for input length %<PRIu64>, hasna %d, narm %d\n"
msgstr ""
"%s: ejecutándose en paralelo para la longitud de entrada %<PRIu64>, hasna "
"%d, narm %d\n"

#: fsort.c:107
msgid "x must be a vector of type double currently"
msgstr "'x' debe ser un vector de tipo double actualmente"

#: fsort.c:118
#, c-format
msgid "nth=%d, nBatch=%d\n"
msgstr "nth=%d, nBatch=%d\n"

#: fsort.c:158
#, c-format
msgid "Range = [%g,%g]\n"
msgstr "Range = [%g,%g]\n"

#: fsort.c:159
msgid "Cannot yet handle negatives."
msgstr "Aún no no se pueden manejar valores negativos."

#: fsort.c:174
#, c-format
msgid "maxBit=%d; MSBNbits=%d; shift=%d; MSBsize=%zu\n"
msgstr "maxBit=%d; MSBNbits=%d; shift=%d; Size MSB=%zu\n"

#: fsort.c:180
#, c-format
msgid ""
"counts is %dMB (%d pages per nBatch=%d, batchSize=%<PRIu64>, "
"lastBatchSize=%<PRIu64>)\n"
msgstr ""
"el recuento es %dMB (%d páginas por nBatch=%d, batchSize=%<PRIu64>, "
"lastBatchSize=%<PRIu64>)\n"

#: fsort.c:250
msgid "Top 20 MSB counts: "
msgstr "Los 20 principales recuentos de MSB: "

#: fsort.c:250
#, c-format
msgid "%<PRId64> "
msgstr "%<PRId64> "

#: fsort.c:251
msgid "Reduced MSBsize from %zu to "
msgstr "MSBsize reducido de %zu a "

#: fsort.c:255
msgid "%zu by excluding 0 and 1 counts\n"
msgstr "%zu excluyendo los recuentos 0 y 1\n"

#: fsort.c:321
#, c-format
msgid ""
"OpenMP %d did not assign threads to iterations monotonically. Please search "
"Stack Overflow for this message."
msgstr ""
"OpenMP %d no asignó hilos a iteraciones de forma monótona. Busque en Stack "
"Overflow para este mensaje."

#: fsort.c:323
msgid "Unable to allocate working memory"
msgstr "No se puede asignar memoria de trabajo"

#: fsort.c:333
#, c-format
msgid "%d: %.3f (%4.1f%%)\n"
msgstr "%d: %.3f (%4.1f%%)\n"

#: fwrite.c:612
#, c-format
msgid "buffMB=%d outside [1,1024]"
msgstr "buffMB=%d fuera del rango [1,1024]"

#: fwrite.c:619
#, c-format
msgid ""
"eol must be 1 or more bytes (usually either \\n or \\r\\n) but is length %d"
msgstr ""
"fin de línea (eol) debe tener 1 o más bytes (normalmente \\n o \\r\\n) pero "
"su longitud es %d"

#: fwrite.c:622
msgid "Column writers: "
msgstr "Escritores de columnas: "

#: fwrite.c:624 fwrite.c:626 fwrite.c:628
#, c-format
msgid "%d "
msgstr "%d "

#: fwrite.c:627
msgid "... "
msgstr "... "

#: fwrite.c:630
#, c-format
msgid ""
"\n"
"args.doRowNames=%d args.rowNames=%p args.rowNameFun=%d doQuote=%d args."
"nrow=%<PRId64> args.ncol=%d eolLen=%d\n"
msgstr ""
"\n"
"args.doRowNames=%d args.rowNames=%p args.rowNameFun=%d doQuote=%d args."
"nrow=%<PRId64> args.ncol=%d eolLen=%d\n"

#: fwrite.c:672
#, c-format
msgid "maxLineLen=%<PRIu64>. Found in %.3fs\n"
msgstr "maxLineLen=%<PRIu64>. Encontrado en %.3fs\n"

#: fwrite.c:692
#, c-format
msgid ""
"%s: '%s'. Failed to open existing file for writing. Do you have write "
"permission to it? Is this Windows and does another process such as Excel "
"have it open?"
msgstr ""
"%s: '%s'. No se pudo abrir el archivo existente para escribirlo. ¿Tiene "
"permiso de escritura? ¿Está usted en Windows y lo tiene abierto otro proceso "
"como Excel?"

#: fwrite.c:693
#, c-format
msgid ""
"%s: '%s'. Unable to create new file for writing (it does not exist already). "
"Do you have permission to write here, is there space on the disk and does "
"the path exist?"
msgstr ""
"%s: '%s'. No se puede crear un nuevo archivo para escribir (y no existía "
"previamente). ¿Tiene permiso para escribir aquí, hay espacio en el disco y "
"existe la ruta?"

#: fwrite.c:700
msgid ""
"Compression in fwrite uses zlib library. Its header files were not found at "
"the time data.table was compiled. To enable fwrite compression, please "
"reinstall data.table and study the output for further guidance."
msgstr ""
"La compresión en fwrite usa la biblioteca zlib. Sus archivos de encabezado "
"no se encontraron en el momento en que se compiló data.table. Para habilitar "
"la compresión fwrite, reinstale data.table y estudie el resultado para "
"obtener más orientación."

#: fwrite.c:705
#, c-format
msgid "Writing bom (%s), yaml (%d characters) and column names (%s) ... "
msgstr ""
"Escribiendo bom (%s), yaml (%d caracteres) y nombres de columnas (%s)... "

#: fwrite.c:719
#, c-format
msgid "Unable to allocate %zu MiB for header: %s"
msgstr "No se pueden asignar %zu MiB para el encabezado: %s"

#: fwrite.c:753 fwrite.c:817
msgid "Can't allocate gzip stream structure"
msgstr "No se puede asignar la estructura de flujo gzip"

#: fwrite.c:761
#, c-format
msgid "Unable to allocate %zu MiB for zbuffer: %s"
msgstr "No se puede asignar %zu MiB para zbuffer: %s"

#: fwrite.c:777
#, c-format
msgid "Compress gzip error: %d"
msgstr "Error al comprimir gzip: %d"

#: fwrite.c:778 fwrite.c:786
#, c-format
msgid "%s: '%s'"
msgstr "%s: '%s'"

#: fwrite.c:783
#, c-format
msgid "done in %.3fs\n"
msgstr "hecho en %.3fs\n"

#: fwrite.c:785
msgid "No data rows present (nrow==0)\n"
msgstr "No hay filas de datos presentes (nrow==0)\n"

#: fwrite.c:803
#, c-format
msgid ""
"Writing %<PRId64> rows in %d batches of %d rows (each buffer size %dMB, "
"showProgress=%d, nth=%d)\n"
msgstr ""
"Escribiendo %<PRId64> filas en %d lotes de %d filas (cada tamaño de búfer "
"%dMB, showProgress=%d, nth=%d)\n"

#: fwrite.c:819
#, c-format
msgid "zbuffSize=%d returned from deflateBound\n"
msgstr "zbuffSize=%d devuelto desde deflateBound\n"

#: fwrite.c:828
#, c-format
msgid ""
"Unable to allocate %zu MB * %d thread buffers; '%d: %s'. Please read ?fwrite "
"for nThread, buffMB and verbose options."
msgstr ""
"No se pueden asignar %zu MB * %d búferes de hilos; '%d:%s'. Lea ?fwrite para "
"conocer las opciones nThread, buffMB y detalladas."

#: fwrite.c:839
#, c-format
msgid ""
"Unable to allocate %zu MB * %d thread compressed buffers; '%d: %s'. Please "
"read ?fwrite for nThread, buffMB and verbose options."
msgstr ""
"No se pueden asignar %zu MB * %d búferes comprimidos de hilos; '%d:%s'. Lea ?"
"fwrite para conocer las opciones nThread, buffMB y detalladas."

#: fwrite.c:1019
#, c-format
msgid ""
"zlib %s (zlib.h %s) deflate() returned error %d with z_stream->msg==\"%s\" "
"Z_FINISH=%d Z_BLOCK=%d. %s"
msgstr ""
"zlib %s (zlib.h %s) deflate() devolvió el error %d con z_stream->msg==\"%s\" "
"Z_FINISH=%d Z_BLOCK=%d. %s"

#: fwrite.c:1021
msgid ""
"Please include the full output above and below this message in your data."
"table bug report."
msgstr ""
" Incluya el resultado completo arriba y debajo de este mensaje en su informe "
"de error de data.table."

#: fwrite.c:1022
msgid ""
"Please retry fwrite() with verbose=TRUE and include the full output with "
"your data.table bug report."
msgstr ""
"Vuelva a intentar fwrite() con verbose=TRUE e incluya el resultado completo "
"con su informe de error de data.table."

#: fwriteR.c:103
#, c-format
msgid ""
"Row %<PRId64> of list column is type '%s' - not yet implemented. fwrite() "
"can write list columns containing items which are atomic vectors of type "
"logical, integer, integer64, double, complex and character."
msgstr ""
"La fila %<PRId64> de la columna de la lista es del tipo '%s'; aún no está "
"implementada. fwrite() puede escribir columnas de lista que contengan "
"elementos que sean vectores atómicos de tipo lógico, entero, entero64, "
"doble, complejo y de carácter."

#: fwriteR.c:176
msgid ""
"fwrite must be passed an object of type list; e.g. data.frame, data.table"
msgstr ""
"a fwrite se le debe pasar un objeto de tipo lista; p.ej. data.frame, data."
"table"

#: fwriteR.c:186
msgid "fwrite was passed an empty list of no columns. Nothing to write."
msgstr "a fwrite se le pasó una lista vacía sin columnas. Nada que escribir."

#: fwriteR.c:240
#, c-format
msgid ""
"Column %d's length (%d) is not the same as column 1's length (%<PRId64>)"
msgstr ""
"La longitud de la columna %d (%d) no es la misma que la longitud de la "
"columna 1 (%<PRId64>)"

#: fwriteR.c:244
#, c-format
msgid "Column %d's type is '%s' - not yet implemented in fwrite."
msgstr "El tipo de columna %d es '%s'; aún no se ha implementado en fwrite."

#: fwriteR.c:267
#, c-format
msgid ""
"input has specific integer rownames but their length (%lld) != nrow "
"(%<PRId64>)"
msgstr ""
"la entrada tiene nombres de filas enteros específicos pero su longitud "
"(%lld) != nrow (%<PRId64>)"

#: fwriteR.c:282
msgid ""
"No list columns are present. Setting sep2='' otherwise quote='auto' would "
"quote fields containing sep2.\n"
msgstr ""
"No hay columnas de lista presentes. Se establece sep2='', de lo contrario "
"quote='auto' entrecomillaría los campos que contienen sep2.\n"

#: fwriteR.c:286
#, c-format
msgid ""
"If quote='auto', fields will be quoted if the field contains either sep "
"('%c') or sep2 ('%c') because column %d is a list column.\n"
msgstr ""
"Si quote='auto', los campos se entrecomillarán si el campo contiene sep "
"('%c') o sep2 ('%c') porque la columna %d es una columna de lista.\n"

#: fwriteR.c:290
#, c-format
msgid ""
"sep ('%c'), sep2 ('%c') and dec ('%c') must all be different. Column %d is a "
"list column."
msgstr ""
"sep ('%c'), sep2 ('%c') y dec ('%c') deben ser todos diferentes. La columna "
"%d es una columna de lista."

#: gsumm.c:45 gsumm.c:46 gsumm.c:47
#, c-format
msgid "%s is not an integer vector"
msgstr "%s no es un vector entero"

#: gsumm.c:56
msgid "irowsArg is neither an integer vector nor NULL"
msgstr "irowsArg no es un vector entero ni NULL"

#: gsumm.c:58
#, c-format
msgid "length(f)=%d != length(l)=%d"
msgstr "length(f)=%d != length(l)=%d"

#: gsumm.c:66
#, c-format
msgid "o has length %d but sum(l)=%d"
msgstr "o tiene longitud %d pero sum(l)==%d"

#: gsumm.c:98
#, c-format
msgid "gforce initial population of grp took %.3f\n"
msgstr "gforce población inicial de grp tomó %.3f\n"

#: gsumm.c:118
msgid "Failed to allocate counts or TMP when assigning g in gforce"
msgstr "No se pudieron asignar recuentos o TMP al asignar g en gforce"

#: gsumm.c:197
#, c-format
msgid "gforce assign high and low took %.3f\n"
msgstr "asignación gforce high y low tomó %.3f\n"

#: gsumm.c:203
#, c-format
msgid "gforce eval took %.3f\n"
msgstr "la evaluación de gforce tomó %.3f\n"

#: gsumm.c:219
msgid "gather took ... "
msgstr "recopilación tomó... "

#: gsumm.c:337
#, c-format
msgid "gather implemented for INTSXP, REALSXP, and CPLXSXP but not '%s'"
msgstr ""
"recopilación implementada para INTSXP, REALSXP y CPLXSXP pero no para '%s'"

#: gsumm.c:339 gsumm.c:572 gsumm.c:720
#, c-format
msgid "%.3fs\n"
msgstr "%.3fs\n"

#: gsumm.c:349 gsumm.c:580 gsumm.c:731 gsumm.c:868 gsumm.c:1023 gsumm.c:1117
#, c-format
msgid "%s is not meaningful for factors."
msgstr "%s no tiene sentido en factores."

#: gsumm.c:353
#, c-format
msgid "This gsum (narm=%s) took ... "
msgstr "Este gsum (narm=%s) tomó... "

#: gsumm.c:354 gsumm.c:588 gsumm.c:736 gsumm.c:871 gsumm.c:923 gsumm.c:1025
#: gsumm.c:1121
#, c-format
msgid "nrow [%d] != length(x) [%d] in %s"
msgstr "nrow [%d] != length(x) [%d] en %s"

#: gsumm.c:408
msgid ""
"The sum of an integer column for a group was more than type 'integer' can "
"hold so the result has been coerced to 'numeric' automatically for "
"convenience."
msgstr ""
"La suma de una columna de enteros para un grupo era mayor de lo que el tipo "
"'integer' puede contener, por lo que el resultado se ha coercionado a "
"'^n^u^m^e^ r^i^c' automáticamente para mayor conveniencia."

#: gsumm.c:569 gsumm.c:843 gsumm.c:909 gsumm.c:1094 gsumm.c:1166
#, c-format
msgid ""
"Type '%s' is not supported by GForce %s. Either add the prefix %s or turn "
"off GForce optimization using options(datatable.optimize=1)"
msgstr ""
"El tipo '%s' no es compatible con GForce %s. Agregue el prefijo %s o "
"desactive la optimización de GForce usando options(datatable.optimize=1)"

#: gsumm.c:587
#, c-format
msgid "This gmean took (narm=%s) ... "
msgstr "Este gmean tomó (narm=%s)... "

#: gsumm.c:625 gsumm.c:681
#, c-format
msgid "Unable to allocate %d * %zu bytes for non-NA counts in gmean na.rm=TRUE"
msgstr ""
"No se pueden asignar %d * %zu bytes para recuentos que no son de NA en gmean "
"na.rm=TRUE"

#: gsumm.c:717
#, c-format
msgid ""
"Type '%s' not supported by GForce mean (gmean). Either add the prefix base::"
"mean(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""
"Tipo '%s' no admitido por función 'mean' de GForce (gmean). Agregue el "
"prefijo base::mean(.) o desactive la optimización de GForce usando "
"options(datatable.optimize=1)"

#: gsumm.c:729
msgid ""
"GForce min/max can only be applied to columns, not .SD or similar. To find "
"min/max of all items in a list such as .SD, either add the prefix base::min(."
"SD) or turn off GForce optimization using options(datatable.optimize=1). "
"More likely, you may be looking for 'DT[,lapply(.SD,min),by=,.SDcols=]'"
msgstr ""
"GForce min/max solo se puede aplicar a columnas, no a .SD o similares. Para "
"encontrar el mínimo/máximo de todos los elementos en una lista como .SD, "
"agregue el prefijo base::min(.SD) o desactive la optimización de GForce "
"usando opciones (datatable.optimize=1). Lo más probable es que esté buscando "
"'DT[,lapply(.SD,min),by=,.SDcols=]'"

#: gsumm.c:840
msgid "Type 'complex' has no well-defined min/max"
msgstr "El tipo 'complex' no tiene un mínimo/máximo bien definido"

#: gsumm.c:866
msgid ""
"GForce median can only be applied to columns, not .SD or similar. To find "
"median of all items in a list such as .SD, either add the prefix stats::"
"median(.SD) or turn off GForce optimization using options(datatable."
"optimize=1). More likely, you may be looking for 'DT[,lapply(.SD,median),"
"by=,.SDcols=]'"
msgstr ""
"La mediana ('median()') de GForce solo se puede aplicar a columnas, no a .SD "
"o similares. Para encontrar la mediana de todos los elementos en una lista "
"como .SD, agregue el prefijo stats::median(.SD) o desactive la optimización "
"de GForce usando options(datatable.optimize=1). Lo más probable es que esté "
"buscando 'DT[,lapply(.SD,median),by=,.SDcols=]'"

#: gsumm.c:983
#, c-format
msgid ""
"Type '%s' is not supported by GForce head/tail/first/last/`[`. Either add "
"the namespace prefix (e.g. utils::head(.)) or turn off GForce optimization "
"using options(datatable.optimize=1)"
msgstr ""
"El tipo '%s' no es compatible con GForce head/tail/first/last/`[`. Agregue "
"el prefijo del espacio de nombres (por ejemplo, utils::head(.)) o desactive "
"la optimización de GForce usando options(datatable.optimize=1)"

#: gsumm.c:1021
msgid ""
"GForce var/sd can only be applied to columns, not .SD or similar. For the "
"full covariance matrix of all items in a list such as .SD, either add the "
"prefix stats::var(.SD) (or stats::sd(.SD)) or turn off GForce optimization "
"using options(datatable.optimize=1). Alternatively, if you only need the "
"diagonal elements, 'DT[,lapply(.SD,var),by=,.SDcols=]' is the optimized way "
"to do this."
msgstr ""
"GForce var/sd solo se puede aplicar a columnas, no a .SD o similares. Para "
"obtener la matriz de covarianza completa de todos los elementos en una lista "
"como .SD, agregue el prefijo stats::var(.SD) (o stats::sd(.SD)) o desactive "
"la optimización de GForce usando opciones(datatable.optimize =1). "
"Alternativamente, si solo necesita los elementos diagonales, 'DT[,lapply(.SD,"
"var),by=,.SDcols=]' es la forma optimizada de hacerlo."

#: gsumm.c:1115
msgid ""
"GForce prod can only be applied to columns, not .SD or similar. To multiply "
"all items in a list such as .SD, either add the prefix base::prod(.SD) or "
"turn off GForce optimization using options(datatable.optimize=1). More "
"likely, you may be looking for 'DT[,lapply(.SD,prod),by=,.SDcols=]'"
msgstr ""
"GForce prod solo se puede aplicar a columnas, no a .SD o similares. Para "
"multiplicar todos los elementos en una lista como .SD, agregue el prefijo "
"base::prod(.SD) o desactive la optimización de GForce usando "
"options(datatable.optimize=1). Lo más probable es que esté buscando 'DT[,"
"lapply(.SD,prod),by=,.SDcols=]'"

#: gsumm.c:1124
#, c-format
msgid "Unable to allocate %d * %zu bytes for gprod"
msgstr "No se puede asignar %d * %zu bytes para gprod"

#: gsumm.c:1215 shift.c:34
#, c-format
msgid "Item %d of n is NA"
msgstr "El elemento %d de n es NA"

#: gsumm.c:1272
#, c-format
msgid ""
"Type '%s' is not supported by GForce gshift. Either add the namespace prefix "
"(e.g. data.table::shift(.)) or turn off GForce optimization using "
"options(datatable.optimize=1)"
msgstr ""
"El tipo '%s' no es compatible con GForce gshift. Agregue el prefijo del "
"espacio de nombres (por ejemplo, data.table::shift(.)) o desactive la "
"optimización de GForce usando options(datatable.optimize=1)"

#: idatetime.c:126 vecseq.c:13
msgid "x must be an integer vector"
msgstr "'x' debe ser un vector entero"

#: ijoin.c:128
#, c-format
msgid "First pass on calculating lengths in lookup ... done in %8.3f seconds\n"
msgstr ""
"Primera pasada para calcular longitudes en la búsqueda... realizado en %8.3f "
"segundos\n"

#: ijoin.c:141
#, c-format
msgid "Second pass on allocation in lookup ... done in %8.3f seconds\n"
msgstr ""
"Segunda pasada de asignación en la búsqueda... realizada en %8.3f segundos\n"

#: ijoin.c:220
#, c-format
msgid "Final step in generating lookup ... done in %8.3f seconds\n"
msgstr "Pasada final para generar la búsqueda... realizado en %8.3f segundos\n"

#: ijoin.c:330
#, c-format
msgid ""
"First pass on calculating lengths in overlaps ... done in %8.3f seconds\n"
msgstr ""
"Primera pasada para calcular longitudes en superposiciones... realizada en "
"%8.3f segundos\n"

#: ijoin.c:729
#, c-format
msgid "Final step, fetching indices in overlaps ... done in %8.3f seconds\n"
msgstr ""
"Paso final, buscar índices en superposiciones... hecho en %8.3f segundos\n"

#: init.c:172
msgid ""
"Pointers are %zu bytes, greater than 8. We have not tested on any "
"architecture greater than 64bit yet."
msgstr ""
"Los punteros son %zu bytes, mayores que 8. Aún no hemos probado ninguna "
"arquitectura mayor que 64 bits."

#: init.c:186
msgid "... failed. Please forward this message to maintainer('data.table')."
msgstr "... falló. Envíe este mensaje a: `mantainer('data.table')`."

#: init.c:187
#, c-format
msgid "Checking NA_INTEGER [%d] == INT_MIN [%d] %s"
msgstr "Comprobando NA_INTEGER [%d] == INT_MIN [%d] %s"

#: init.c:188
#, c-format
msgid "Checking NA_INTEGER [%d] == NA_LOGICAL [%d] %s"
msgstr "Comprobando NA_INTEGER [%d] == NA_LOGICAL [%d] %s"

#: init.c:189 init.c:190 init.c:192 init.c:195 init.c:196 init.c:197 init.c:198
#: init.c:199 init.c:200 init.c:201
#, c-format
msgid "Checking sizeof(%s) [%zu] is %d %s"
msgstr "Comprobando que sizeof(%s) [%zu] es %d %s"

#: init.c:193
#, c-format
msgid "Checking sizeof(pointer) [%zu] is 4 or 8 %s"
msgstr "Comprobando que sizeof(pointer) [%zu] es 4 u 8 %s"

#: init.c:194
#, c-format
msgid "Checking sizeof(SEXP) [%zu] == sizeof(pointer) [%zu] %s"
msgstr "Comprobando sizeof(SEXP) [%zu] == sizeof(puntero) [%zu] %s"

#: init.c:204
#, c-format
msgid "Checking LENGTH(allocVector(INTSXP,2)) [%d] is 2 %s"
msgstr "Comprobando LENGTH(allocVector(INTSXP,2)) [%d] es 2 %s"

#: init.c:206
#, c-format
msgid "Checking TRUELENGTH(allocVector(INTSXP,2)) [%lld] is 0 %s"
msgstr "Comprobando que TRUELENGTH(allocVector(INTSXP,2)) [%lld] es 0 %s"

#: init.c:213
#, c-format
msgid "Checking memset(&i,0,sizeof(int)); i == (int)0 %s"
msgstr "Comprobando memset(&i,0,sizeof(int)); i == (int)0 %s"

#: init.c:216
#, c-format
msgid "Checking memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"
msgstr ""
"Comprobando memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"

#: init.c:219
#, c-format
msgid "Checking memset(&d, 0, sizeof(double)); d == (double)0.0 %s"
msgstr "Comprobando memset(&d, 0, sizeof(double)); d == (doble)0.0 %s"

#: init.c:222
#, c-format
msgid "Checking memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"
msgstr ""
"Comprobando memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"

#: init.c:225
msgid "The ascii character '/' is not just before '0'"
msgstr "El carácter ascii '/' no está justo antes del '0'"

#: init.c:226
msgid "The C expression (uint_fast8_t)('/'-'0')<10 is true. Should be false."
msgstr ""
"La expresión C (uint_fast8_t)('/'-'0')<10 es verdadera. Debería ser falsa."

#: init.c:227
msgid "The ascii character ':' is not just after '9'"
msgstr "El carácter ascii ':' no está justo después del '9'"

#: init.c:228
msgid "The C expression (uint_fast8_t)('9'-':')<10 is true. Should be false."
msgstr ""
"La expresión C (uint_fast8_t)('9'-':')<10 es verdadera. Debería ser falsa."

#: init.c:233
#, c-format
msgid "Conversion of NA_INT64 via double failed %<PRId64>!=%<PRId64>"
msgstr "Conversión de NA_INT64 mediante doble error %<PRId64>!=%<PRId64>"

#: init.c:237
msgid "NA_INT64_D (negative -0.0) is not == 0.0."
msgstr "NA_INT64_D (negativo -0,0) no es == 0,0."

#: init.c:238
msgid "NA_INT64_D (negative -0.0) is not ==-0.0."
msgstr "NA_INT64_D (negativo -0.0) no es ==-0.0."

#: init.c:239
msgid "ISNAN(NA_INT64_D) is TRUE but should not be"
msgstr "ISNAN(NA_INT64_D) es TRUE pero no debería serlo"

#: init.c:240
msgid "isnan(NA_INT64_D) is TRUE but should not be"
msgstr "isnan(NA_INT64_D) es TRUE pero no debería serlo"

#: init.c:274
#, c-format
msgid "PRINTNAME(install(\"integer64\")) has returned %s not %s"
msgstr "PRINTNAME(install(\"integer64\")) ha devuelto %s no %s"

#: init.c:333
msgid "verbose option must be length 1 non-NA logical or integer"
msgstr ""
"la opción detallada debe tener una longitud de 1, lógica o entera no NA"

#: init.c:367
msgid ".Last.value in namespace is not a length 1 integer"
msgstr ".Last.value en el espacio de nombres no es un entero de longitud 1"

#: nafill.c:110
msgid ""
"'x' argument is atomic vector, in-place update is supported only for list/"
"data.table"
msgstr ""
" El argumento 'x' es un vector atómico, la actualización in situ solo se "
"admite para list/data.table"

#: nafill.c:112 nafill.c:123
msgid "'x' argument must be numeric type, or list/data.table of numeric types"
msgstr ""
"'x' argumento debe ser de tipo numérico, o lista/datos.tabla de tipos "
"numéricos"

#: nafill.c:179
msgid "fill must be a vector of length 1 or a list of length of x"
msgstr "el relleno debe ser un vector de longitud 1 o una lista de longitud x"

#: nafill.c:226
#, c-format
msgid "%s: parallel processing of %d column(s) took %.3fs\n"
msgstr "%s: el procesamiento paralelo de %d columnas tomó %.3fs\n"

#: openmp-utils.c:23
#, c-format
msgid ""
"Ignoring invalid %s==\"%s\". Not an integer >= 1. Please remove any "
"characters that are not a digit [0-9]. See ?data.table::setDTthreads."
msgstr ""
"Ignorando %s no válidos==\"%s\". No es un número entero >= 1. Elimine los "
"caracteres que no sean un dígito [0-9]. Consulte ?data.table::setDTthreads."

#: openmp-utils.c:44
#, c-format
msgid ""
"Ignoring invalid R_DATATABLE_NUM_PROCS_PERCENT==%d. If used it must be an "
"integer between 2 and 100. Default is 50. See ?setDTtheads."
msgstr ""
"Ignorando R_DATATABLE_NUM_PROCS_PERCENT==%d no válido. Si se utiliza, debe "
"ser un número entero entre 2 y 100. El valor predeterminado es 50. Consulte ?"
"setDTtheads."

#: openmp-utils.c:82
msgid ""
"This installation of data.table has not been compiled with OpenMP support.\n"
msgstr ""
"Esta instalación de data.table no ha sido compilada con soporte OpenMP.\n"

#: openmp-utils.c:84
#, c-format
msgid "  OpenMP version (_OPENMP)       %d\n"
msgstr " Versión OpenMP (_OPENMP) %d\n"

#: openmp-utils.c:89
#, c-format
msgid "  omp_get_num_procs()            %d\n"
msgstr " omp_get_num_procs() %d\n"

#: openmp-utils.c:90
#, c-format
msgid "  R_DATATABLE_NUM_PROCS_PERCENT  %s\n"
msgstr " R_DATATABLE_NUM_PROCS_PERCENT %s\n"

#: openmp-utils.c:91
#, c-format
msgid "  R_DATATABLE_NUM_THREADS        %s\n"
msgstr " R_DATATABLE_NUM_THREADS %s\n"

#: openmp-utils.c:92
#, c-format
msgid "  R_DATATABLE_THROTTLE           %s\n"
msgstr " R_DATATABLE_THROTTLE %s\n"

#: openmp-utils.c:93
#, c-format
msgid "  omp_get_thread_limit()         %d\n"
msgstr " omp_get_thread_limit() %d\n"

#: openmp-utils.c:94
#, c-format
msgid "  omp_get_max_threads()          %d\n"
msgstr " omp_get_max_threads() %d\n"

#: openmp-utils.c:95
#, c-format
msgid "  OMP_THREAD_LIMIT               %s\n"
msgstr " OMP_THREAD_LIMIT %s\n"

#: openmp-utils.c:96
#, c-format
msgid "  OMP_NUM_THREADS                %s\n"
msgstr " OMP_NUM_THREADS %s\n"

#: openmp-utils.c:97
#, c-format
msgid "  RestoreAfterFork               %s\n"
msgstr " RestoreAfterFork %s\n"

#: openmp-utils.c:98
#, c-format
msgid ""
"  data.table is using %d threads with throttle==%d. See ?setDTthreads.\n"
msgstr ""
" data.table está usando %d hilos con aceleración==%d. Consulte ?"
"setDTthreads.\n"

#: openmp-utils.c:106
msgid ""
"restore_after_fork= must be TRUE, FALSE, or NULL (default). "
"getDTthreads(verbose=TRUE) reports the current setting.\n"
msgstr ""
"restore_after_fork= debe ser TRUE, FALSE o NULL (predeterminado). "
"getDTthreads(verbose=TRUE) informa la configuración actual.\n"

#: openmp-utils.c:112
msgid "'throttle' must be a single number, non-NA, and >=1"
msgstr "'throttle' debe ser un número único, que no sea NA y >=1"

#: openmp-utils.c:126
msgid ""
"threads= must be either NULL or a single number >= 0. See ?setDTthreads."
msgstr "threads= debe ser NULL o un solo número >= 0. Consulte ?setDTthreads."

#: programming.c:16
#, c-format
msgid ""
"Attempting to substitute '%s' element with object of type '%s' but it has to "
"be 'symbol' type when substituting name of the call argument, functions 'as."
"name' and 'I' can be used to work out proper substitution, see ?substitute2 "
"examples."
msgstr ""
"Intentando sustituir el elemento '%s' con un objeto de tipo '%s' pero tiene "
"que ser del tipo 'symbol' al sustituir el nombre del argumento de llamada, "
"las funciones  'as.name' y 'I' se pueden utilizar para realizar una "
"sustitución adecuada; consulte los ejemplos de ?substitute2."

#: rbindlist.c:10
msgid "use.names= should be TRUE, FALSE, or not used (\"check\" by default)"
msgstr "use.names= debe ser TRUE, FALSE o no usarse (\"check\" por defecto)"

#: rbindlist.c:14
msgid ""
"Input to rbindlist must be a list. This list can contain data.tables, data."
"frames or plain lists."
msgstr ""
"La entrada a rbindlist debe ser una lista. Esta lista puede contener data."
"tables, data.frames o listas simples."

#: rbindlist.c:33
#, c-format
msgid "Item %d of input is not a data.frame, data.table or list"
msgstr ""
"El elemento %d de la entrada no es un data.frame, data.table o una lista"

#: rbindlist.c:41
#, c-format
msgid ""
"Item %d has %d columns, inconsistent with item %d which has %d columns. To "
"fill missing columns use fill=TRUE."
msgstr ""
"El elemento %d tiene %d columnas, lo que es inconsistente con el elemento %d "
"que tiene %d columnas. Para completar las columnas que faltan, utilice "
"fill=TRUE."

#: rbindlist.c:44
#, c-format
msgid "Item %d has %d columns but %d column names. Invalid object."
msgstr ""
"El elemento %d tiene %d columnas pero %d nombres de columna. Objeto no "
"válido."

#: rbindlist.c:51
#, c-format
msgid ""
"Column %d of item %d is length %d inconsistent with column %d which is "
"length %d. Only length-1 columns are recycled."
msgstr ""
"La columna %d del elemento %d tiene una longitud %d inconsistente con la "
"columna %d, que tiene una longitud %d. Sólo se reciclan las columnas de "
"longitud 1."

#: rbindlist.c:60
#, c-format
msgid ""
"Column %d ['%s'] of item %d is length 0. This (and %d other%s like it) has "
"been filled with NA (NULL for list columns) to make each item uniform."
msgstr ""
"La columna %d ['%s'] del elemento %d tiene una longitud de 0. Esta (y %d "
"otras %s similares) se ha llenado con NA (NULL para las columnas de la "
"lista) para que cada elemento sea uniforme."

#: rbindlist.c:64
#, c-format
msgid ""
"Total rows in the list is %<PRId64> which is larger than the maximum number "
"of rows, currently %d"
msgstr ""
"El total de filas en la lista es %<PRId64> que es mayor que el número máximo "
"de filas, actualmente %d"

#: rbindlist.c:65
msgid "use.names=TRUE but no item of input list has any names"
msgstr ""
"use.names=TRUE pero ningún elemento de la lista de entrada tiene ningún "
"nombre"

#: rbindlist.c:74
#, c-format
msgid ""
"Failed to allocate upper bound of %<PRId64> unique column names "
"[sum(lapply(l,ncol))]"
msgstr ""
"No se pudo asignar el límite superior de %<PRId64> nombres de columna únicos "
"[sum(lapply(l,ncol))]"

#: rbindlist.c:105
#, c-format
msgid "Failed to allocate nuniq=%d items working memory in rbindlist.c"
msgstr ""
"Error al asignar memoria de trabajo de elementos nuniq=%d en <rbindlist.c>"

#: rbindlist.c:139
#, c-format
msgid "Failed to allocate ncol=%d items working memory in rbindlist.c"
msgstr ""
"Error al asignar ncol=%d memoria de trabajo de elementos en <rbindlist.c>"

#: rbindlist.c:199
msgid ""
" use.names='check' (default from v1.12.2) emits this message and proceeds as "
"if use.names=FALSE for  backwards compatibility. See news item 5 in v1.12.2 "
"for options to control this message."
msgstr ""
" use.names='check' (predeterminado desde v1.12.2) emite este mensaje y "
"procede como si use.names=FALSE para compatibilidad con versiones "
"anteriores. Consulte ítem 5 en NEWS de v1.12.2 para conocer las opciones "
"para controlar este mensaje."

#: rbindlist.c:213
#, c-format
msgid ""
"Column %d ['%s'] of item %d is missing in item %d. Use fill=TRUE to fill "
"with NA (NULL for list columns), or use.names=FALSE to ignore column names.%s"
msgstr ""
"Falta la columna %d ['%s'] del elemento %d en el elemento %d. Use fill=TRUE "
"para completar con NA (NULL para columnas de lista), o use.names=FALSE para "
"ignorar los nombres de columnas.%s"

#: rbindlist.c:222
#, c-format
msgid ""
"Column %d ['%s'] of item %d appears in position %d in item %d. Set use."
"names=TRUE to match by column name, or use.names=FALSE to ignore column "
"names.%s"
msgstr ""
"La columna %d ['%s'] del elemento %d aparece en la posición %d en el "
"elemento %d. Establezca use.names=TRUE para que coincida con el nombre de la "
"columna, o use.names=FALSE para ignorar los nombres de las columnas.%s"

#: rbindlist.c:231
msgid ""
"options()$datatable.rbindlist.check is set but is not a single string. See "
"news item 5 in v1.12.2."
msgstr ""
"options()$datatable.rbindlist.check está configurado pero no es una sola "
"cadena. Ver ítem 5 en NEWS en v1.12.2."

#: rbindlist.c:238
#, c-format
msgid ""
"options()$datatable.rbindlist.check=='%s' which is not "
"'message'|'warning'|'error'|'none'. See news item 5 in v1.12.2."
msgstr ""
"options()$datatable.rbindlist.check=='%s' que no es "
"'message'|'warning'|'error'|'none'. Ver ítem 5 en NEWS v1.12.2."

#: rbindlist.c:301
#, c-format
msgid ""
"Column %d of item %d has type 'factor' but has no levels; i.e. malformed."
msgstr ""
"La columna %d del elemento %d tiene el tipo 'factor' pero no tiene niveles; "
"es decir, está mal formada."

#: rbindlist.c:380
#, c-format
msgid ""
"Failed to allocate working memory for %d ordered factor levels of result "
"column %d"
msgstr ""
"No se pudo asignar la memoria de trabajo para %d niveles de factores "
"ordenados de la columna de resultados %d"

#: rbindlist.c:403
#, c-format
msgid ""
"Column %d of item %d is an ordered factor but level %d ['%s'] is missing "
"from the ordered levels from column %d of item %d. Each set of ordered "
"factor levels should be an ordered subset of the first longest. A regular "
"factor will be created for this column."
msgstr ""
"La columna %d del elemento %d es un factor ordenado pero el nivel %d ['%s'] "
"falta en los niveles ordenados de la columna %d del elemento %d. Cada "
"conjunto de niveles de factores ordenados debe ser un subconjunto ordenado "
"del primero más largo. Se creará un factor regular para esta columna."

#: rbindlist.c:408
#, c-format
msgid ""
"Column %d of item %d is an ordered factor with '%s'<'%s' in its levels. But "
"'%s'<'%s' in the ordered levels from column %d of item %d. A regular factor "
"will be created for this column due to this ambiguity."
msgstr ""
"La columna %d del ítem %d es un factor ordenado con '%s'<'%s' en sus "
"niveles. Pero '%s'<'%s' en los niveles ordenados de la columna %d del "
"elemento %d. Debido a esta ambigüedad, se creará un factor regular para esta "
"columna."

#: rbindlist.c:453
#, c-format
msgid ""
"Failed to allocate working memory for %d factor levels of result column %d "
"when reading item %d of item %d"
msgstr ""
"No se pudo asignar la memoria de trabajo para %d niveles de factor de la "
"columna de resultados %d al leer el elemento %d del elemento %d"

#: rbindlist.c:544 rbindlist.c:547
#, c-format
msgid "Column %d of item %d: %s"
msgstr "Columna %d del elemento %d: %s"

#: reorder.c:17
#, c-format
msgid "Item %d of list is type '%s' which isn't yet supported (SIZEOF=%zu)"
msgstr ""
"El elemento %d de la lista es del tipo '%s' que aún no está soportado "
"(SIZEOF=%zu)"

#: reorder.c:19
#, c-format
msgid ""
"Column %d is length %d which differs from length of column 1 (%d). Invalid "
"data.table."
msgstr ""
"La columna %d tiene una longitud %d que difiere de la longitud de la columna "
"1 (%d). data.table no válido."

#: reorder.c:27
#, c-format
msgid ""
"reorder accepts vectors but this non-VECSXP is type '%s' which isn't yet "
"supported (SIZEOF=%zu)"
msgstr ""
"reorder acepta vectores pero este no-VECSXP es del tipo '%s' que aún no está "
"soportado (SIZEOF=%zu)"

#: reorder.c:33
msgid "order must be an integer vector"
msgstr "el orden debe ser un vector entero"

#: reorder.c:34
#, c-format
msgid "nrow(x)[%d]!=length(order)[%d]"
msgstr "nrow(x)[%d]!=length(order)[%d]"

#: reorder.c:51
#, c-format
msgid ""
"Item %d of order (%d) is either NA, out of range [1,%d], or is duplicated. "
"The new order must be a strict permutation of 1:n"
msgstr ""
"El elemento %d del pedido (%d) es NA, está fuera del rango [1,%d] o está "
"duplicado. El nuevo orden debe ser una permutación estricta de 1:n"

#: reorder.c:111
msgid "dt passed to setcolorder has no names"
msgstr "dt pasado a setcolorder no tiene nombres"

#: shift.c:12
msgid ""
"shift input must not be matrix or array, consider wrapping it into data."
"table() or c()"
msgstr ""
"la entrada de desplazamiento no debe ser una matriz o array, considere "
"incluirla en data.table() o c()"

#: shift.c:17
#, c-format
msgid ""
"type '%s' passed to shift(). Must be a vector, list, data.frame or data.table"
msgstr ""
"Tipo '%s' pasado a shift(). Debe ser un vector, una lista, un data.frame o "
"una data.table."

#: snprintf.c:193 snprintf.c:196 snprintf.c:199 snprintf.c:202 snprintf.c:205
#: snprintf.c:208 snprintf.c:211 snprintf.c:214 snprintf.c:217 snprintf.c:221
#: snprintf.c:224 snprintf.c:227 snprintf.c:230 snprintf.c:233 snprintf.c:236
#: snprintf.c:239 snprintf.c:242 snprintf.c:245
#, c-format
msgid "dt_win_snprintf test %d failed: %s"
msgstr "prueba dt_win_snprintf %d falló: %s"

#: snprintf.c:218
#, c-format
msgid "dt_win_snprintf test %d failed: %d"
msgstr "prueba dt_win_snprintf %d falló: %d"

#: subset.c:182
#, c-format
msgid ""
"Item %d of i is %d and item %d is %d. Cannot mix positives and negatives."
msgstr ""
"El elemento %d de 'i' es %d y el elemento %d es %d. No se pueden mezclar "
"valores positivos y negativos."

#: subset.c:192
#, c-format
msgid "Item %d of i is %d and item %d is NA. Cannot mix negatives and NA."
msgstr ""
"El elemento %d de 'i' es %dy el elemento %d es NA. No se pueden mezclar "
"negativos y NA."

#: subset.c:239
#, c-format
msgid ""
"Item %d of i is %d but there are only %d rows. Ignoring this and %d more "
"like it out of %d."
msgstr ""
"El elemento %d de 'i' es %d pero solo hay %d filas. Ignorando este y otros "
"%d similares de un total de %d."

#: subset.c:241
#, c-format
msgid ""
"Item %d of i is %d which removes that item but that has occurred before. "
"Ignoring this dup and %d other dups."
msgstr ""
"El elemento %d de 'i' es %d que elimina ese elemento pero que ya ocurrió "
"antes. Ignorando este duplicado y %d otro(s) duplicado(s)."

#: subset.c:255
#, c-format
msgid "Column %d is NULL; malformed data.table."
msgstr "La columna %d es NULL; data.table con formato incorrecto."

#: subset.c:258
#, c-format
msgid "Column %d ['%s'] is a data.frame or data.table; malformed data.table."
msgstr ""
"La columna %d ['%s'] es un data.frame o data.table; data.table con formato "
"incorrecto."

#: subset.c:263
#, c-format
msgid ""
"Column %d ['%s'] is length %d but column 1 is length %d; malformed data."
"table."
msgstr ""
"La columna %d ['%s'] tiene una longitud %d pero la columna 1 tiene una "
"longitud %d; data.table con formato incorrecto."

#: subset.c:295
#, c-format
msgid "Item %d of cols is %d which is outside the range [1,ncol(x)=%d]"
msgstr ""
"El elemento %d de columnas es %d que está fuera del rango [1,ncol(x)=%d]"

#: transpose.c:9
msgid "l must be a list."
msgstr "'l' debe ser una lista."

#: transpose.c:13
msgid "ignore.empty should be logical TRUE/FALSE."
msgstr "ignore.empty debe ser lógico TRUE/FALSE."

#: transpose.c:16
msgid ""
"keep.names should be either NULL, or the name of the first column of the "
"result in which to place the names of the input"
msgstr ""
"keep.names debe ser NULL o el nombre de la primera columna del resultado en "
"la que colocar los nombres de la entrada"

#: transpose.c:19
msgid "fill must be a length 1 vector, such as the default NA"
msgstr "'fill' debe ser un vector de longitud 1, como el NA predeterminado"

#: transpose.c:22
msgid "list.cols should be logical TRUE/FALSE."
msgstr "list.cols debe tener el valor lógico TRUE/FALSE."

#: transpose.c:31
#, c-format
msgid "Item %d of list input is not either an atomic vector, or a list"
msgstr ""
"El elemento %d de la entrada de lista no es un vector atómico ni una lista"

#: uniqlist.c:151
msgid "Input argument 'x' to 'uniqlengths' must be an integer vector"
msgstr "El argumento de entrada 'x' a 'uniqlengths' debe ser un vector entero"

#: uniqlist.c:152
msgid ""
"Input argument 'n' to 'uniqlengths' must be an integer vector of length 1"
msgstr ""
"El argumento de entrada 'n' a 'uniqlengths' debe ser un vector entero de "
"longitud 1"

#: uniqlist.c:170 uniqlist.c:267
msgid "cols must be an integer vector with length >= 1"
msgstr "cols debe ser un vector entero con longitud >= 1"

#: uniqlist.c:174
#, c-format
msgid "Item %d of cols is %d which is outside the range [1,length(l)=%d]"
msgstr ""
"El elemento %d de columnas es %d que está fuera del rango [1,length(l)=%d]"

#: uniqlist.c:177
#, c-format
msgid ""
"All elements to input list must be of same length. Element [%d] has length "
"%<PRIu64> != length of first element = %<PRIu64>."
msgstr ""
"Todos los elementos para ingresar la lista deben tener la misma longitud. El "
"elemento [%d] tiene una longitud %<PRIu64> != longitud del primer elemento = "
"%<PRIu64>."

#: uniqlist.c:352
msgid "x is not a logical vector"
msgstr "'x' no es un vector lógico"

#: utils.c:85
#, c-format
msgid "Unsupported type '%s' passed to allNA()"
msgstr "Tipo no admitido '%s' pasado a allNA()"

#: utils.c:105
msgid "'x' argument must be data.table compatible"
msgstr " El argumento 'x' debe ser compatible con data.table"

#: utils.c:129
msgid ""
"argument specifying columns is type 'double' and one or more items in it are "
"not whole integers"
msgstr ""
"el argumento que especifica las columnas es del tipo 'double' y uno o más "
"elementos que contiene no son números enteros"

#: utils.c:135
#, c-format
msgid ""
"argument specifying columns received non-existing column(s): cols[%d]=%d"
msgstr ""
"argumento que especifica columnas recibidas columna(s) no existentes: "
"cols[%d]=%d"

#: utils.c:142
msgid "'x' argument data.table has no names"
msgstr "argumento 'x' de tipo data.table no tiene nombres"

#: utils.c:148
#, c-format
msgid ""
"argument specifying columns received non-existing column(s): cols[%d]='%s'"
msgstr ""
"argumento que especifica columnas recibió columnas no existentes: "
"cols[%d]='%s'"

#: utils.c:152
msgid "argument specifying columns must be character or numeric"
msgstr ""
"el argumento que especifica las columnas debe ser de caracteres o numérico"

#: utils.c:155
msgid "argument specifying columns received duplicate column(s)"
msgstr "argumento que especifica columnas recibió columna(s) duplicada(s)"

#: utils.c:289
#, c-format
msgid "Found and copied %d column%s with a shared memory address\n"
msgstr ""
"Encontrada(s) y copiada(s) %d columnas%s con una dirección de memoria "
"compartida\n"

#: utils.c:369
msgid "'x' is not atomic"
msgstr "'x' no es atómico"

#: utils.c:371
msgid "'x' must not be matrix or array"
msgstr "'x' no debe ser matriz o array"

#: utils.c:373
msgid "input must not be matrix or array"
msgstr "la entrada no debe ser una matriz o array"

#: utils.c:377
#, c-format
msgid "copy=false and input already of expected type and class %s[%s]\n"
msgstr "copy=FALSE y entrada ya del tipo y clase esperados %s[%s]\n"

#: utils.c:384
#, c-format
msgid "Coercing %s[%s] into %s[%s]\n"
msgstr "Forzando tipo %s[%s] a %s[%s]\n"

#: utils.c:400
#, c-format
msgid "zlib header files were not found when data.table was compiled"
msgstr ""
"No se encontraron archivos de encabezado zlib cuando se compiló data.table"

#: vecseq.c:14
msgid "len must be an integer vector"
msgstr "len debe ser un vector entero"

#: vecseq.c:15
msgid "x and len must be the same length"
msgstr "'x' y 'len' deben tener la misma longitud"

#: vecseq.c:21
msgid ""
"Join results in more than 2^31 rows (internal vecseq reached physical "
"limit). Very likely misspecified join. Check for duplicate key values in i "
"each of which join to the same group in x over and over again. If that's ok, "
"try by=.EACHI to run j for each group to avoid the large allocation. "
"Otherwise, please search for this error message in the FAQ, Wiki, Stack "
"Overflow and data.table issue tracker for advice."
msgstr ""
"Resultados del join en más de 2^31 filas (el vecseq interno alcanzó el "
"límite físico). Es muy probable que se haya especificado mal una unión. "
"Compruebe si hay valores clave duplicados en i, cada uno de los cuales se "
"une al mismo grupo en x una y otra vez. Si está bien, intente by=.EACHI "
"ejecutar 'j' para cada grupo para evitar una asignación demasiado grande. De "
"lo contrario, busque este mensaje de error en Preguntas frecuentes (FAQ), "
"Wiki, Stack Overflow y rastreador de problemas de data.table para obtener "
"asesoramiento."

#: vecseq.c:25
msgid "clamp must be a double vector length 1"
msgstr "'clamp' debe ser un vector doble de longitud 1"

#: vecseq.c:27
msgid "clamp must be positive"
msgstr "'clamp' debe ser positivo"

#: vecseq.c:28
#, c-format
msgid ""
"Join results in %d rows; more than %d = nrow(x)+nrow(i). Check for duplicate "
"key values in i each of which join to the same group in x over and over "
"again. If that's ok, try by=.EACHI to run j for each group to avoid the "
"large allocation. If you are sure you wish to proceed, rerun with allow."
"cartesian=TRUE. Otherwise, please search for this error message in the FAQ, "
"Wiki, Stack Overflow and data.table issue tracker for advice."
msgstr ""
"Resultados del join en %d filas; más de %d = nrow(x)+nrow(i). Compruebe si "
"hay valores clave duplicados en i, cada uno de los cuales se une al mismo "
"grupo en x una y otra vez. Si está bien, intente by=.EACHI para ejecutar 'j' "
"para cada grupo y evitar así una gran asignación. Si está seguro de que "
"desea continuar, vuelva a ejecutar con enable.cartesian=TRUE. De lo "
"contrario, busque este mensaje de error en Preguntas frecuentes (FAQ), Wiki, "
"Stack Overflow y rastreador de problemas de data.table para obtener "
"asesoramiento."

#: wrappers.c:11
msgid "Attribute name must be a character vector of length 1"
msgstr "El nombre del atributo debe ser un vector de caracteres de longitud 1"

#: wrappers.c:16
msgid ""
"Internal structure doesn't seem to be a list. Can't set class to be 'data."
"table' or 'data.frame'. Use 'as.data.table()' or 'as.data.frame()' methods "
"instead."
msgstr ""
"La estructura interna no parece ser una lista. No se puede configurar la "
"clase para que sea 'data.table' o 'data.frame'. Utilice los métodos 'as.data."
"table()' o 'as.data.frame()' en su lugar."

#: wrappers.c:66
msgid "First argument to setlistelt must be a list()"
msgstr "El primer argumento de setlistelt debe ser una lista"

#: wrappers.c:67
msgid "Second argument to setlistelt must a length 1 integer vector"
msgstr ""
"El segundo argumento para setlistelt debe ser un vector entero de longitud 1"

#: wrappers.c:69
#, c-format
msgid "i (%d) is outside the range of items [1,%d]"
msgstr "i (%d) está fuera del rango de elementos [1,%d]"

#: wrappers.c:91
msgid "x isn't a VECSXP"
msgstr "'x' no es un VECSXP"

#: wrappers.c:106
#, c-format
msgid ""
"dim.data.table expects a data.table as input (which is a list), but seems to "
"be of type %s"
msgstr ""
"dim.data.table espera un data.table como entrada (que es una lista), pero "
"parece ser del tipo %s"

#~ msgid ""
#~ "strptime() usage detected and wrapped with as.POSIXct(). This is to "
#~ "minimize the chance of assigning POSIXlt columns, which use 40+ bytes to "
#~ "store one date (versus 8 for POSIXct). Use as.POSIXct() (which will call "
#~ "strptime() as needed internally) to avoid this warning."
#~ msgstr ""
#~ "uso de strptime() detectado y ajustado con as.POSIXct(). Esto es para "
#~ "minimizar la posibilidad de asignar columnas POSIXlt, que utilizan más de "
#~ "40 bytes para almacenar una fecha (frente a 8 para POSIXct). Utilice as."
#~ "POSIXct() (que llamará a strptime() según sea necesario internamente) "
#~ "para evitar esta advertencia."

#~ msgid ""
#~ "J() called outside of [.data.table. J() is only intended for use in i."
#~ msgstr ""
#~ "J() se llamó fuera de [.data.table. J() solo está destinado a usarse en i."

#~ msgid ""
#~ ".() called outside of [.data.table. .() is only intended as an alias for "
#~ "list() inside DT[...]."
#~ msgstr ""
#~ ".() se llamó fuera de [.data.table. .() solo está pensado como un alias "
#~ "para list() dentro de DT[...]."

#~ msgid ""
#~ "Aggregating function(s) should take vector inputs and return a single "
#~ "value (length=1). However, function(s) returns length!=1. This value will "
#~ "have to be used to fill any missing combinations, and therefore must be "
#~ "length=1. Either override by setting the 'fill' argument explicitly or "
#~ "modify your function to handle this case appropriately."
#~ msgstr ""
#~ "Las funciones de agregación deben tomar entradas vectoriales y devolver "
#~ "un valor único (longitud=1). Sin embargo, las funciones devuelven "
#~ "longitud!=1. Este valor tiene que  usarse para completar cualquier "
#~ "combinación que falte y, por lo tanto, debe tener una longitud = 1. Anule "
#~ "este comportamiento estableciendo el argumento 'fill' explícitamente o "
#~ "modifique su función para manejar este caso de manera adecuada."
