<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />


<meta name="date" content="2024-09-21" />

<title>Benchmarking data.table</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Benchmarking data.table</h1>
<h4 class="date">2024-09-21</h4>



<style>
h2 {
font-size: 20px;
}
</style>
<p>Este documento tiene como objetivo orientar sobre la medición del
rendimiento de <code>data.table</code>. Un único lugar para documentar
las mejores prácticas y las trampas que se deben evitar.</p>
<div id="fread-borrar-cachés" class="section level1">
<h1>fread: borrar cachés</h1>
<p>Lo ideal es que cada llamada a <code>fread</code> se ejecute en una
sesión nueva con los siguientes comandos antes de la ejecución de R.
Esto borra el archivo de caché del SO en la RAM y la caché del disco
duro.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">free</span> <span class="at">-g</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">sudo</span> sh <span class="at">-c</span> <span class="st">&#39;echo 3 &gt;/proc/sys/vm/drop_caches&#39;</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">sudo</span> lshw <span class="at">-class</span> disk</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">sudo</span> hdparm <span class="at">-t</span> /dev/sda</span></code></pre></div>
<p>Al comparar <code>fread</code> con soluciones que no sean de R, tenga
en cuenta que R requiere que los valores de las columnas de caracteres
se agreguen a la <em>caché de cadenas global de R</em>. Esto lleva
tiempo al leer datos, pero las operaciones posteriores se benefician
porque las cadenas de caracteres ya se han almacenado en caché. En
consecuencia, además de cronometrar tareas aisladas (como
<code>fread</code> solo), es una buena idea comparar el tiempo total de
una secuencia de tareas de punta a punta, como leer datos, manipularlos
y producir el resultado final.</p>
</div>
<div id="subconjunto-umbral-para-la-optimización-de-índices-en-consultas-compuestas" class="section level1">
<h1>subconjunto: umbral para la optimización de índices en consultas
compuestas</h1>
<p>La optimización de índices para consultas de filtro compuestas no se
utilizará cuando el producto cruzado de los elementos proporcionados
para filtrar supere los 1e4 elementos.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">data.table</span>(<span class="at">V1=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">V2=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">V3=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">V4=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">setindex</span>(DT)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>v <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">1</span><span class="dt">L</span>, <span class="fu">rep</span>(<span class="dv">11</span><span class="dt">L</span>, <span class="dv">9</span>))</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="fu">length</span>(v)<span class="sc">^</span><span class="dv">4</span>               <span class="co"># cross product of elements in filter</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co">#[1] 10000                # &lt;= 10000</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>DT[V1 <span class="sc">%in%</span> v <span class="sc">&amp;</span> V2 <span class="sc">%in%</span> v <span class="sc">&amp;</span> V3 <span class="sc">%in%</span> v <span class="sc">&amp;</span> V4 <span class="sc">%in%</span> v, verbose<span class="ot">=</span><span class="cn">TRUE</span>]</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co">#Optimized subsetting with index &#39;V1__V2__V3__V4&#39;</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co">#on= matches existing index, using index</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co">#Starting bmerge ...done in 0.000sec</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co">#...</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>v <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">1</span><span class="dt">L</span>, <span class="fu">rep</span>(<span class="dv">11</span><span class="dt">L</span>, <span class="dv">10</span>))</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="fu">length</span>(v)<span class="sc">^</span><span class="dv">4</span>               <span class="co"># cross product of elements in filter</span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a><span class="co">#[1] 14641                # &gt; 10000</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>DT[V1 <span class="sc">%in%</span> v <span class="sc">&amp;</span> V2 <span class="sc">%in%</span> v <span class="sc">&amp;</span> V3 <span class="sc">%in%</span> v <span class="sc">&amp;</span> V4 <span class="sc">%in%</span> v, verbose<span class="ot">=</span><span class="cn">TRUE</span>]</span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="co">#Subsetting optimization disabled because the cross-product of RHS values exceeds 1e4, causing memory problems.</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a><span class="co">#...</span></span></code></pre></div>
</div>
<div id="subconjunto-evaluación-comparativa-con-reconocimiento-de-índices" class="section level1">
<h1>subconjunto: evaluación comparativa con reconocimiento de
índices</h1>
<p>Para mayor comodidad, <code>data.table</code> crea automáticamente un
índice en los campos que utiliza para crear subconjuntos de datos. Esto
agregará cierta sobrecarga al primer subconjunto en campos específicos,
pero reduce en gran medida el tiempo para consultar esas columnas en
ejecuciones posteriores. Al medir la velocidad, la mejor manera es medir
la creación y la consulta de índices utilizando un índice por separado.
Con estos tiempos, es fácil decidir cuál es la estrategia óptima para su
caso de uso. Para controlar el uso del índice, utilice las siguientes
opciones:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">datatable.auto.index=</span><span class="cn">TRUE</span>)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="fu">options</span>(<span class="at">datatable.use.index=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>=====- <code>use.index=FALSE</code> forzará a la consulta a no usar
índices incluso si existen, pero las claves existentes se siguen usando
para la optimización.===== =====- <code>auto.index=FALSE</code>
deshabilita la creación automática de índices cuando se crea un
subconjunto en datos no indexados, pero si los índices se crearon antes
de que se estableciera esta opción, o explícitamente al llamar a
<code>setindex</code>, se seguirán usando para la optimización.=====</p>
<p>Otras dos opciones controlan la optimización globalmente, incluido el
uso de índices:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">datatable.optimize=</span><span class="dv">2</span><span class="dt">L</span>)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">options</span>(<span class="at">datatable.optimize=</span><span class="dv">3</span><span class="dt">L</span>)</span></code></pre></div>
<p><code>options(datatable.optimize=2L)</code> desactivará la
optimización de subconjuntos por completo, mientras que
<code>options(datatable.optimize=3L)</code> la volverá a activar. Esas
opciones afectan a muchas más optimizaciones y, por lo tanto, no se
deben usar cuando solo se necesita el control de índices. Lea más en
<code>?datatable.optimize</code>.</p>
</div>
<div id="operaciones-por-referencia" class="section level1">
<h1>Operaciones <em>por referencia</em></h1>
<p>Al evaluar las funciones <code>set*</code>, solo tiene sentido medir
la primera ejecución. Estas funciones actualizan su entrada por
referencia, por lo que las ejecuciones posteriores utilizarán el
<code>data.table</code> ya procesado, lo que sesgará los resultados.</p>
<p>Para proteger su <code>data.table</code> de ser actualizado por
operaciones de referencia, puede utilizar las funciones
<code>copy</code> o <code>data.table:::shallow</code>. Tenga en cuenta
que <code>copy</code> puede ser muy costoso, ya que necesita duplicar el
objeto completo. Es poco probable que queramos incluir el tiempo de
duplicación en el tiempo de la tarea real que estamos evaluando.</p>
</div>
<div id="intente-evaluar-los-procesos-atómicos" class="section level1">
<h1>Intente evaluar los procesos atómicos</h1>
<p>Si su evaluación comparativa está destinada a publicarse, será mucho
más esclarecedor si la divide para medir el tiempo de los procesos
atómicos. De esta manera, sus lectores pueden ver cuánto tiempo se
dedicó a leer los datos de la fuente, limpiarlos, transformarlos
realmente y exportar los resultados. Por supuesto, si su evaluación
comparativa está destinada a presentar un <em>flujo de trabajo de
extremo a extremo</em>, entonces tiene mucho sentido presentar el tiempo
general. Sin embargo, separar el tiempo de los pasos individuales es
útil para comprender qué pasos son los principales cuellos de botella de
un flujo de trabajo. Existen otros casos en los que la evaluación
comparativa atómica puede no ser deseable, por ejemplo, cuando se lee un
archivo csv y luego se realiza una agrupación. R requiere que se
complete la caché de cadenas global de R, lo que agrega una sobrecarga
adicional al importar datos de caracteres a una sesión de R. Por otro
lado, la caché de cadenas global puede acelerar procesos como la
agrupación. En tales casos, al comparar R con otros lenguajes, puede ser
útil incluir el tiempo total.</p>
</div>
<div id="evitar-la-coerción-de-clases" class="section level1">
<h1>evitar la coerción de clases</h1>
<p>A menos que esto sea lo que realmente desea medir, debe preparar
objetos de entrada de la clase esperada para cada herramienta que esté
evaluando.</p>
</div>
<div id="evite-microbenchmark...-times100" class="section level1">
<h1>Evite <code>microbenchmark(..., times=100)</code></h1>
<p>Repetir una evaluación comparativa muchas veces generalmente no
brinda la imagen más clara para las herramientas de procesamiento de
datos. Por supuesto, tiene mucho sentido para cálculos más atómicos,
pero esta no es una buena representación de la forma más común en que se
usarán realmente estas herramientas, es decir, para tareas de
procesamiento de datos, que consisten en lotes de transformaciones
proporcionadas secuencialmente, cada una de las cuales se ejecuta una
vez. Matt dijo una vez:</p>
<blockquote>
<p>Soy muy cauteloso con las evaluaciones comparativas medidas en
cualquier tiempo menor a 1 segundo. Prefiero mucho 10 segundos o más
para una sola ejecución, lograda al aumentar el tamaño de los datos. Un
recuento de repeticiones de 500 hace sonar las alarmas. 3 a 5
ejecuciones deberían ser suficientes para convencer con datos más
grandes. La sobrecarga de llamadas y el tiempo para GC afectan las
inferencias a esta escala muy pequeña.</p>
</blockquote>
<p>Esto es muy válido. Cuanto menor sea la medición de tiempo, mayor
será el ruido relativamente. Ruido generado por el envío de métodos,
inicialización de paquetes/clases, etc. El punto de referencia debe
centrarse principalmente en casos de uso reales.</p>
</div>
<div id="procesamiento-multihilo" class="section level1">
<h1>Procesamiento multihilo</h1>
<p>Uno de los principales factores que probablemente afecten los tiempos
es la cantidad de hilos disponibles para su sesión R. En versiones
recientes de <code>data.table</code>, algunas funciones están
paralelizadas. Puede controlar la cantidad de hilos que desea utilizar
con <code>setDTthreads</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">setDTthreads</span>(<span class="dv">0</span>)    <span class="co"># use all available cores (default)</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="fu">getDTthreads</span>()     <span class="co"># check how many cores are currently used</span></span></code></pre></div>
</div>
<div id="dentro-de-un-bucle-es-preferible-usar-set-en-lugar-de" class="section level1">
<h1>Dentro de un bucle, es preferible usar <code>set</code> en lugar de
<code>:=</code></h1>
<p>A menos que esté utilizando un índice al realizar una
<em>subasignación por referencia</em>, debería preferir la función
<code>set</code>, que no impone una sobrecarga de la llamada al método
<code>[.data.table</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">data.table</span>(<span class="at">a=</span><span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="at">b=</span>letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>])</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="fu">setindex</span>(DT, a)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># for (...) {                 # imagine loop here</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>  DT[a<span class="sc">==</span><span class="dv">2</span><span class="dt">L</span>, b <span class="sc">:=</span> <span class="st">&quot;z&quot;</span>]         <span class="co"># sub-assign by reference, uses index</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  DT[, d <span class="sc">:=</span> <span class="st">&quot;z&quot;</span>]              <span class="co"># not sub-assign by reference, not uses index and adds overhead of `[.data.table`</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>  <span class="fu">set</span>(DT, <span class="at">j=</span><span class="st">&quot;d&quot;</span>, <span class="at">value=</span><span class="st">&quot;z&quot;</span>)   <span class="co"># no `[.data.table` overhead, but no index yet, till #1196</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co"># }</span></span></code></pre></div>
</div>
<div id="dentro-de-un-bucle-es-preferible-setdt-en-lugar-de-data.table" class="section level1">
<h1>Dentro de un bucle, es preferible <code>setDT</code> en lugar de
<code>data.table()</code></h1>
<p>Al presente, <code>data.table()</code> tiene una sobrecarga, por lo
tanto, dentro de los bucles es preferible utilizar
<code>as.data.table()</code> o <code>setDT()</code> en una lista
válida.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
