<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />


<meta name="date" content="2024-09-21" />

<title>Frequently Asked Questions about data.table</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Frequently Asked Questions about
data.table</h1>
<h4 class="date">2024-09-21</h4>



<style>
h2 {
font-size: 20px;
}
#TOC { width: 100%; }
</style>
<p>La primera sección —Preguntas frecuentes para principiantes— está
pensada para leerse en orden, de principio a fin. Está escrita en un
estilo de preguntas frecuentes, para que sea más fácil de asimilar. En
realidad, no son las preguntas más frecuentes. Una mejor métrica de esto
último sería buscar en Stack Overflow.</p>
<p>Estas preguntas frecuentes son de lectura obligatoria y se consideran
documentación principal. No haga preguntas en Stack Overflow ni plantees
problemas en GitHub hasta que las haya leído. Todos podemos darnos
cuenta de que no las has leído cuando hace una pregunta. Por lo tanto,
si hace una pregunta y no la ha leído, no use su nombre real.</p>
<p>Este documento se ha revisado rápidamente teniendo en cuenta los
cambios en la versión 1.9.8 publicada en noviembre de 2016. Envíe
solicitudes de incorporación de cambios para corregir errores o realizar
mejoras. Si alguien sabe por qué la tabla de contenidos aparece tan
estrecha y aplastada cuando la muestra CRAN, háganoslo saber. Este
documento solía ser un PDF y lo cambiamos recientemente a HTML.</p>
<div id="preguntas-frecuentes-para-principiantes" class="section level1">
<h1>Preguntas frecuentes para principiantes</h1>
<div id="j-num" class="section level2">
<h2>¿Por qué <code>DT[ , 5]</code> y <code>DT[2, 5]</code> devuelven un
data.table de una columna en lugar de vectores como
<code>data.frame</code>?</h2>
<p>Para mantener la coherencia, de modo que cuando utilice data.table en
funciones que aceptan entradas variables, pueda confiar en que
<code>DT[...]</code> devolverá una data.table. No tiene que recordar
incluir <code>drop=FALSE</code> como en data.frame. data.table se lanzó
por primera vez en 2006 y esta diferencia con data.frame ha sido una
característica desde el principio.</p>
<p>Sin embargo, es posible que haya escuchado que, en general, es una
mala práctica hacer referencia a las columnas por número en lugar de por
nombre. Si su colega viene y lee su código más tarde, es posible que
tenga que buscar por todas partes para encontrar qué columna es la
número 5. Si usted o las otras personas cambian el orden de las columnas
más arriba en su programa R, se podrían producir resultados incorrectos
sin advertencia o error en el caso de que olvide cambiar todos los
lugares en su código que hacen referencia a la columna número 5. Esto es
su error, no de R o data.table. Y es, realmente, muy malo. Por favor, no
lo haga. Es el mismo mantra que tienen los desarrolladores profesionales
de SQL: nunca use <code>select *</code>, siempre seleccione
explícitamente por nombre de columna para, al menos, intentar ser
robusto a cambios futuros.</p>
<p>Digamos que la columna 5 se llama <code>&quot;region&quot;</code> y realmente
debe extraer esa columna como un vector, no como un data.table. Es más
robusto usar el nombre de la columna y escribir <code>DT$region</code> o
<code>DT[[&quot;region&quot;]]</code>; es decir, lo mismo que R base. Se
recomienda usar <code>$</code> y <code>[[</code> de R base en
data.table. No cuando se combinan con <code>&lt;-</code> para asignar
(use <code>:=</code> en su lugar para eso), sino solo para seleccionar
una sola columna por nombre.</p>
<p>Hay algunas circunstancias en las que hacer referencia a una columna
por número parece ser la única forma, como una secuencia de columnas. En
estas situaciones, al igual que en data.frame, puede escribir
<code>DT[, 5:10]</code> y <code>DT[,c(1,4,10)]</code>. Sin embargo,
nuevamente, es más robusto (para futuros cambios en la cantidad y orden
de las columnas de sus datos) usar un rango nombrado como
<code>DT[,columnRed:columnViolet]</code> o nombrar cada una
<code>DT[,c(&quot;columnRed&quot;,&quot;columnOrange&quot;,&quot;columnYellow&quot;)]</code>. Es un
trabajo más difícil al principio, pero probablemente se lo agradecerá, y
sus colegas podrían agradecerle en el futuro. Al menos, puede decir que
hizo su mejor esfuerzo para escribir un código robusto si algo sale
mal.</p>
<p>Sin embargo, lo que realmente queremos que haga es
<code>DT[,.(columnRed,columnOrange,columnYellow)]</code>; es decir, que
use los nombres de las columnas como si fueran variables directamente
dentro de <code>DT[...]</code>. No tiene que anteponer cada columna con
<code>DT$</code> como lo hace en data.frame. La parte <code>.()</code>
es solo un alias para <code>list()</code> y puede usar
<code>list()</code> en su lugar si lo prefiere. Puede colocar cualquier
expresión R de nombres de columnas, utilizando cualquier paquete R, que
devuelva diferentes tipos de diferentes longitudes, allí mismo.
Queríamos alentar a que lo hiciera con tanta fuerza en el pasado que
deliberadamente habíamos hecho que <code>DT[,5]</code> no funcionara en
absoluto. Antes de que se lanzara v1.9.8 en noviembre de 2016,
<code>DT[,5]</code> solía devolver solo <code>5</code>. La idea era que
podíamos enseñar de manera más simple un hecho: que las partes dentro de
<code>DT[...]</code> siempre se evalúan dentro del marco de DT (las
data.tables ven los nombres de las columnas como si fueran variables). Y
<code>5</code> evalúa a <code>5</code>, por lo que el comportamiento era
coherente con la regla única. Le pedíamos que pasara por un obstáculo
deliberado adicional <code>DT[,5,with=FALSE]</code> si realmente quería
seleccionar una columna por nombre o número. A partir de noviembre de
2016, no necesita usar <code>with=FALSE</code> y veremos cómo una mayor
coherencia con data.frame en este sentido ayudará o perjudicará tanto a
los usuarios nuevos como a los antiguos. Los nuevos usuarios que no lean
estas preguntas frecuentes, ni siquiera esta primera entrada, con suerte
no se encontrarán con problemas con data.table como antes si esperaban
que funcionara como data.frame. Con suerte, no se perderán la
oportunidad de comprender nuestra intención y recomendación de colocar
expresiones de columnas dentro de <code>DT[i, j, by]</code>. Si usan
data.table como data.frame, no obtendrán ningún beneficio. Si conoce a
alguien así, dele un empujoncito amistoso para que lea este documento
como lo hace usted.</p>
<p>Recordatorio: puede colocar <em>cualquier</em> expresión R dentro de
<code>DT[...]</code> usando nombres de columna como si fueran variables;
por ejemplo, intente <code>DT[, colA*colB/2]</code>. Esto devuelve un
vector porque usó nombres de columna como si fueran variables. Encierre
con <code>.()</code> para devolver una tabla de datos; es decir,
<code>DT[,.(colA*colB/2)]</code>. Nómbrela:
<code>DT[,.(myResult = colA*colB/2)]</code>. Y dejaremos que adivine
cómo devolver dos cosas de esta consulta. También es bastante común
hacer un montón de cosas dentro de un cuerpo anónimo:
<code>DT[, { x&lt;-colA+10; x*x/2 }]</code> o llamar a la función de
otro paquete: <code>DT[ , fitdistr(columnA, &quot;normal&quot;)]</code>.</p>
</div>
<div id="por-qué-dtregion-devuelve-una-tabla-de-datos-de-1-columna-en-lugar-de-un-vector" class="section level2">
<h2>¿Por qué <code>DT[,&quot;region&quot;]</code> devuelve una tabla de datos de 1
columna en lugar de un vector?</h2>
<p>Consulte la <a href="#j-num">respuesta anterior</a>. Pruebe
<code>DT$region</code> en su lugar. O <code>DT[[&quot;region&quot;]]</code>.</p>
</div>
<div id="por-qué-dt-region-devuelve-un-vector-para-la-columna-region-preferiría-una-tabla-de-datos-de-1-columna." class="section level2">
<h2>¿Por qué <code>DT[, region]</code> devuelve un vector para la
columna “region”? Preferiría una tabla de datos de 1 columna.</h2>
<p>Pruebe <code>DT[ , .(region)]</code> en su lugar. <code>.()</code> es
un alias para <code>list()</code> y garantiza que se devuelva una tabla
de datos.</p>
<p>Además, continúe leyendo y consulte las preguntas frecuentes después
de la siguiente página. Revise los documentos completos antes de
quedarse atascado en una parte.</p>
</div>
<div id="por-qué-dt-x-y-z-no-funciona-esperaba-las-3-columnas-xy-y-z." class="section level2">
<h2>¿Por qué <code>DT[ , x, y, z]</code> no funciona? Esperaba las 3
columnas <code>x</code>,<code>y</code> y <code>z</code>.</h2>
<p>La expresión <code>j</code> es el segundo argumento. Pruebe
<code>DT[ , c(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;)]</code> o <code>DT[ , .(x,y,z)]</code>.</p>
</div>
<div id="asigné-una-variable-mycolx-pero-luego-dt-mycol-devuelve-un-error.-cómo-hago-para-que-busque-el-nombre-de-la-columna-que-se-encuentra-en-la-variable-mycol" class="section level2">
<h2>Asigné una variable <code>mycol=&quot;x&quot;</code> pero luego
<code>DT[, mycol]</code> devuelve un error. ¿Cómo hago para que busque
el nombre de la columna que se encuentra en la variable
<code>mycol</code>?</h2>
<p>El error es que no se puede encontrar la columna denominada
<code>&quot;mycol&quot;</code>, y este error es correcto. El alcance de
<code>data.table</code> es diferente al de <code>data.frame</code> en el
sentido de que puede usar nombres de columnas como si fueran variables
directamente dentro de <code>DT[...]</code> sin anteponer
<code>DT$</code> a cada nombre de columna; consulte la pregunta
frecuente 1.1 anterior.</p>
<p>Para usar <code>mycol</code> para seleccionar la columna
<code>x</code> de <code>DT</code>, hay algunas opciones:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>DT[, ..mycol]            <span class="co"># .. prefix conveys to look for the mycol one level up in calling scope</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>DT[, mycol, with<span class="ot">=</span><span class="cn">FALSE</span>]  <span class="co"># revert to data.frame behavior</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>DT[[mycol]]               <span class="co"># treat DT as a list and use [[ from base R</span></span></code></pre></div>
<p>Consulte <code>?data.table</code> para obtener más detalles sobre el
prefijo <code>..</code>.</p>
<p>El argumento <code>with</code> toma su nombre de la función
<code>base</code> <code>with()</code>. Cuando <code>with=TRUE</code>
(predeterminado), <code>data.table</code> funciona de forma similar a
<code>with()</code>, es decir, <code>DT[, mycol]</code> se comporta como
<code>with(DT, mycol)</code>. Cuando <code>with=FALSE</code>, las reglas
de evaluación estándar de <code>data.frame</code> se aplican a todas las
variables en <code>j</code> y ya no se pueden usar nombres de columnas
directamente.</p>
</div>
<div id="cuáles-son-los-beneficios-de-poder-usar-nombres-de-columnas-como-si-fueran-variables-dentro-de-dt..." class="section level2">
<h2>¿Cuáles son los beneficios de poder usar nombres de columnas como si
fueran variables dentro de <code>DT[...]</code>?</h2>
<p><code>j</code> no tiene por qué ser solo nombres de columnas. Puede
escribir cualquier <em>expresión</em> R de nombres de columnas
directamente en <code>j</code>, <em>p. ej.</em>,
<code>DT[ , mean(x*y/z)]</code>. Lo mismo se aplica a <code>i</code>,
<em>p. ej.</em>, <code>DT[x&gt;1000, sum(y*z)]</code>.</p>
<p>Esto ejecuta la expresión <code>j</code> en el conjunto de filas
donde la expresión <code>i</code> es verdadera. Ni siquiera necesita
devolver datos, <em>p. ej.</em>, <code>DT[x&gt;1000, plot(y, z)]</code>.
Puede hacer <code>j</code> por grupo simplemente agregando
<code>by =</code>; p. ej., <code>DT[x&gt;1000, sum(y*z), by = w]</code>.
Esto ejecuta <code>j</code> para cada grupo en la columna <code>w</code>
pero solo sobre las filas donde <code>x&gt;1000</code>. Al colocar las 3
partes de la consulta (i=where, j=select y by=group by) dentro de los
corchetes, data.table ve esta consulta como un todo antes de que se
evalúe cualquier parte de ella. Por lo tanto, puede optimizar la
consulta combinada para el rendimiento. Puede hacer esto porque el
lenguaje R tiene una evaluación diferida única (Python y Julia no la
tienen). data.table ve las expresiones dentro de <code>DT[...]</code>
antes de que se evalúen y las optimiza antes de la evaluación. Por
ejemplo, si data.table ve que solo estás usando 2 columnas de 100, no se
molestará en crear un subconjunto de las 98 que no son necesarias para
tu expresión j.</p>
</div>
<div id="ok-estoy-empezando-a-ver-de-qué-se-trata-data.table-pero-por-qué-no-mejorar-data.frame-en-r-por-qué-tiene-que-ser-un-paquete-nuevo" class="section level2">
<h2>OK, estoy empezando a ver de qué se trata data.table, pero ¿por qué
no mejorar <code>data.frame</code> en R? ¿Por qué tiene que ser un
paquete nuevo?</h2>
<p>Como <a href="#j-num">resaltado arriba</a>, <code>j</code> en
<code>[.data.table</code> es fundamentalmente diferente de
<code>j</code> en <code>[.data.frame</code>. Incluso si algo tan simple
como <code>DF[ , 1]</code> se cambiara en R base para devolver un
data.frame en lugar de un vector, eso rompería el código existente en
muchos miles de paquetes CRAN y código de usuario. Tan pronto como dimos
el paso para crear una nueva clase que heredara de data.frame, tuvimos
la oportunidad de cambiar algunas cosas y lo hicimos. Queremos que
data.table sea ligeramente diferente y que funcione de esta manera para
que funcione una sintaxis más complicada. También hay otras diferencias
(ver <a href="#SmallerDiffs">abajo</a>).</p>
<p>Además, data.table <em>hereda</em> de <code>data.frame</code>.
También <em>es</em> un <code>data.frame</code>. Se puede pasar un
data.table a cualquier paquete que solo acepte <code>data.frame</code> y
ese paquete puede usar la sintaxis <code>[.data.frame</code> en el
data.table. Ver <a href="https://stackoverflow.com/a/10529888/403310">esta respuesta</a>
para saber cómo se logra eso.</p>
<p>También <em>hemos</em> propuesto mejoras para R siempre que era
posible. Una de ellas fue aceptada como una nueva característica en R
2.12.0:</p>
<blockquote>
<p><code>unique()</code> y <code>match()</code> ahora son más rápidos en
vectores de caracteres donde todos los elementos están en la caché
CHARSXP global y tienen codificación sin marcar (ASCII). Gracias a Matt
Dowle por sugerir mejoras en la forma en que se genera el código hash en
unique.c.</p>
</blockquote>
<p>Una segunda propuesta fue utilizar <code>memcpy</code> en
duplicate.c, que es mucho más rápido que un bucle for en C. Esto
mejoraría la <em>forma</em> en que R copia datos internamente (en
algunas medidas, hasta 13 veces). El hilo sobre r-devel está <a href="https://stat.ethz.ch/pipermail/r-devel/2010-April/057249.html">aquí</a>.</p>
<p>Una tercera propuesta más significativa que fue aceptada es que R
ahora utiliza el código de ordenamiento por radix de data.table a partir
de R 3.3.0:</p>
<blockquote>
<p>El algoritmo de ordenamiento por radix y la implementación de
data.table (forder) reemplazan al ordenamiento por radix (conteo)
anterior y agregan un nuevo método para order(). Contribuido por Matt
Dowle y Arun Srinivasan, el nuevo algoritmo admite vectores lógicos,
enteros (incluso con valores grandes), reales y de caracteres. Supera a
todos los demás métodos, pero hay algunas salvedades (ver ?sort).</p>
</blockquote>
<p>Este fue un gran evento para nosotros y lo celebramos hasta el
cansancio. (En realidad, no).</p>
</div>
<div id="por-qué-los-valores-predeterminados-son-como-son-por-qué-funciona-como-lo-hace" class="section level2">
<h2>¿Por qué los valores predeterminados son como son? ¿Por qué funciona
como lo hace?</h2>
<p>La respuesta es sencilla: el autor principal lo diseñó originalmente
para su propio uso. Así lo quería. Le parece una forma más natural y
rápida de escribir código, que también se ejecuta más rápidamente.</p>
</div>
<div id="no-se-hace-esto-ya-con-with-y-subset-en-base" class="section level2">
<h2>¿No se hace esto ya con <code>with()</code> y <code>subset()</code>
en <code>base</code>?</h2>
<p>Algunas de las características que hemos comentado hasta ahora son
afirmativas. El paquete se basa en la funcionalidad básica. Hace el
mismo tipo de cosas, pero requiere menos código y se ejecuta mucho más
rápido si se usa correctamente.</p>
</div>
<div id="por-qué-xy-también-devuelve-todas-las-columnas-de-y-no-debería-devolver-un-subconjunto-de-x" class="section level2">
<h2>¿Por qué <code>X[Y]</code> también devuelve todas las columnas de
<code>Y</code>? ¿No debería devolver un subconjunto de
<code>X</code>?</h2>
<p>Esto se modificó en la versión 1.5.3 (febrero de 2011). Desde
entonces, <code>X[Y]</code> incluye las columnas no unidas de
<code>Y</code>. Nos referimos a esta característica como <em>ámbito
heredado de unión</em> porque no solo las columnas <code>X</code> están
disponibles para la expresión <code>j</code>, sino también las columnas
<code>Y</code>. La desventaja es que <code>X[Y]</code> es menos
eficiente ya que cada elemento de las columnas no unidas de
<code>Y</code> se duplica para que coincida con la cantidad
(probablemente grande) de filas en <code>X</code> que coinciden. Por lo
tanto, recomendamos encarecidamente <code>X[Y, j]</code> en lugar de
<code>X[Y]</code>. Consulte <a href="#MergeDiff">próxima pregunta
frecuente</a>.</p>
</div>
<div id="MergeDiff" class="section level2">
<h2>¿Cuál es la diferencia entre <code>X[Y]</code> y
<code>merge(X, Y)</code>?</h2>
<p><code>X[Y]</code> es una unión, que busca las filas de <code>X</code>
utilizando <code>Y</code> (o la clave de <code>Y</code> si tiene una)
como índice.</p>
<p><code>Y[X]</code> es una unión, que busca las filas de <code>Y</code>
usando <code>X</code> (o la clave de <code>X</code> si tiene una) como
índice.</p>
<p><code>merge(X,Y)</code><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> hace ambas cosas al mismo tiempo. La
cantidad de filas de <code>X[Y]</code> e <code>Y[X]</code> generalmente
difieren, mientras que la cantidad de filas devueltas por
<code>merge(X, Y)</code> y <code>merge(Y, X)</code> es la misma.</p>
<p><em>PERO</em> eso pasa por alto el punto principal. La mayoría de las
tareas requieren que se haga algo con los datos después de una unión o
fusión. ¿Por qué fusionar todas las columnas de datos, solo para usar un
pequeño subconjunto de ellas después? Puede sugerir
<code>merge(X[ , ColsNeeded1], Y[ , ColsNeeded2])</code>, pero eso
requiere que el programador determine qué columnas son necesarias.
<code>X[Y, j]</code> en data.table hace todo eso en un solo paso por
usted. Cuando escribe <code>X[Y, sum(foo*bar)]</code>, data.table
inspecciona automáticamente la expresión <code>j</code> para ver qué
columnas utiliza. Creará subconjuntos de esas columnas solamente; las
otras se ignoran. Solo se crea memoria para las columnas que utiliza
<code>j</code> y las columnas <code>Y</code> disfrutan de las reglas de
reciclaje estándar de R dentro del contexto de cada grupo. Digamos que
<code>foo</code> está en <code>X</code> y <code>bar</code> está en
<code>Y</code> (junto con otras 20 columnas en <code>Y</code>). ¿No es
<code>X[Y, sum(foo*bar)]</code> más rápido de programar y más rápido de
ejecutar que una <code>fusión</code> de todo desperdiciada seguida de un
<code>subconjunto</code>?</p>
</div>
<div id="algo-más-sobre-xy-sumfoobar" class="section level2">
<h2>¿Algo más sobre <code>X[Y, sum(foo*bar)]</code>?</h2>
<p>Este comportamiento cambió en la versión v1.9.4 (septiembre de 2014).
Ahora realiza la unión <code>X[Y]</code> y luego ejecuta
<code>sum(foo*bar)</code> sobre todas las filas; es decir,
<code>X[Y][ , sum(foo*bar)]</code>. Antes ejecutaba <code>j</code> para
cada <em>grupo</em> de <code>X</code> con el que coincide cada fila de
<code>Y</code>. Eso todavía se puede hacer porque es muy útil, pero
ahora debe ser explícito y especificar <code>by = .EACHI</code>, <em>es
decir</em>, <code>X[Y, sum(foo*bar), by = .EACHI]</code>. A esto lo
llamamos <em>agrupamiento por cada <code>i</code></em> (grouping by each
<code>i</code>).</p>
<p>Por ejemplo (complicándolo aún más al usar <em>join legacyed
scope</em>, también):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>X <span class="ot">=</span> <span class="fu">data.table</span>(<span class="at">grp =</span> <span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>,</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>                       <span class="st">&quot;b&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;c&quot;</span>), <span class="at">foo =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">7</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="fu">setkey</span>(X, grp)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>Y <span class="ot">=</span> <span class="fu">data.table</span>(<span class="fu">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>), <span class="at">bar =</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">2</span>))</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>X</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="co"># Key: &lt;grp&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co">#       grp   foo</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;int&gt;</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co"># 1:      a     1</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co"># 2:      a     2</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="co"># 3:      b     3</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="co"># 4:      b     4</span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a><span class="co"># 5:      b     5</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="co"># 6:      c     6</span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="co"># 7:      c     7</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a>Y</span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a><span class="co">#        V1   bar</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;num&gt;</span></span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a><span class="co"># 1:      b     4</span></span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a><span class="co"># 2:      c     2</span></span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a>X[Y, <span class="fu">sum</span>(foo<span class="sc">*</span>bar)]</span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a><span class="co"># [1] 74</span></span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a>X[Y, <span class="fu">sum</span>(foo<span class="sc">*</span>bar), by <span class="ot">=</span> .EACHI]</span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a><span class="co"># Key: &lt;grp&gt;</span></span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a><span class="co">#       grp    V1</span></span>
<span id="cb2-26"><a href="#cb2-26" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;num&gt;</span></span>
<span id="cb2-27"><a href="#cb2-27" tabindex="-1"></a><span class="co"># 1:      b    48</span></span>
<span id="cb2-28"><a href="#cb2-28" tabindex="-1"></a><span class="co"># 2:      c    26</span></span></code></pre></div>
</div>
<div id="eso-está-bien.-cómo-se-las-arregló-para-cambiarlo-dado-que-los-usuarios-dependían-del-comportamiento-anterior" class="section level2">
<h2>Eso está bien. ¿Cómo se las arregló para cambiarlo dado que los
usuarios dependían del comportamiento anterior?</h2>
<p>La solicitud de cambio provino de los usuarios. La sensación era que
si una consulta está haciendo agrupación, entonces debería estar
presente un <code>by=</code> explícito por razones de legibilidad del
código. Se proporcionó una opción para devolver el comportamiento
anterior: <code>options(datatable.old.bywithoutby)</code>, por defecto
<code>FALSE</code>. Esto permitió la actualización para probar las otras
nuevas características / correcciones de errores en v1.9.4, con la
migración posterior de cualquier consulta by-without-by cuando esté
lista agregando <code>by=.EACHI</code> a ellas. Conservamos 47 pruebas
previas al cambio y las agregamos nuevamente como pruebas nuevas,
probadas bajo <code>options(datatable.old.bywithoutby=TRUE)</code>.
Agregamos un mensaje de inicio sobre el cambio y cómo volver al
comportamiento anterior. Después de 1 año, la opción quedó obsoleta con
una advertencia cuando se usaba. Después de 2 años, se eliminó la opción
de volver al comportamiento anterior.</p>
<p>De los 66 paquetes en CRAN o Bioconductor que dependían de data.table
o lo importaban en el momento de la publicación de la versión 1.9.4
(ahora son más de 300), solo uno se vio afectado por el cambio. Esto
podría deberse a que muchos paquetes no tienen pruebas exhaustivas o
simplemente a que los paquetes posteriores no utilizaban mucho la
agrupación por cada fila en <code>i</code>. Siempre probamos la nueva
versión con todos los paquetes dependientes antes de su publicación y
coordinamos los cambios con esos encargados de mantenimiento. Por lo
tanto, esta versión fue bastante sencilla en ese sentido.</p>
<p>Otra razón convincente para realizar el cambio fue que,
anteriormente, no había una forma eficiente de lograr lo que
<code>X[Y, sum(foo*bar)]</code> hace ahora. Había que escribir
<code>X[Y][ , sum(foo*bar)]</code>. Eso no era óptimo porque
<code>X[Y]</code> unía todas las columnas y las pasaba todas a la
segunda consulta compuesta sin saber que solo se necesitaban
<code>foo</code> y <code>bar</code>. Para resolver ese problema de
eficiencia, se requirió un esfuerzo de programación adicional:
<code>X[Y, list(foo, bar)][ , sum(foo*bar)]</code>. El cambio a
<code>by = .EACHI</code> ha simplificado esto al permitir que ambas
consultas se expresen dentro de una única consulta <code>DT[...]</code>
para lograr eficiencia.</p>
</div>
</div>
<div id="sintaxis-general" class="section level1">
<h1>Sintaxis general</h1>
<div id="cómo-puedo-evitar-escribir-una-expresión-j-muy-larga-se-dijo-que-uno-debería-usar-los-nombres-de-columna-pero-tengo-muchas-columnas." class="section level2">
<h2>¿Cómo puedo evitar escribir una expresión <code>j</code> muy larga?
Se dijo que uno debería usar los nombres de columna, pero tengo muchas
columnas.</h2>
<p>Al agrupar, la expresión <code>j</code> puede usar nombres de columna
como variables, como usted sabe, pero también puede usar un símbolo
reservado <code>.SD</code> que hace referencia al
<strong>S</strong>ubconjunto de <strong>D</strong>ata.table para cada
grupo (excluyendo las columnas de agrupación). Entonces, para sumar
todas tus columnas, es solo
<code>DT[ , lapply(.SD, sum), by = grp]</code>. Puede parecer
complicado, pero es rápido de escribir y rápido de ejecutar. Ten en
cuenta que no tienes que crear una función anónima. El objeto
<code>.SD</code> se implementa internamente de manera eficiente y es más
eficiente que pasar un argumento a una función. Pero si el símbolo
<code>.SD</code> aparece en <code>j</code>, data.table debe completar
<code>.SD</code> por completo para cada grupo, incluso si <code>j</code>
no lo usa todo.</p>
<p>Por lo tanto, no haga, por ejemplo,
<code>DT[ , sum(.SD[[&quot;sales&quot;]]), by = grp]</code>. Eso funciona, pero es
ineficiente y poco elegante. <code>DT[ , sum(sales), by = grp]</code> es
lo que se pretendía, y podría ser cientos de veces más rápido. Si usa
<em>todos</em> los datos en <code>.SD</code> para cada grupo (como en
<code>DT[ , lapply(.SD, sum), by = grp]</code>), entonces ese es un muy
buen uso de <code>.SD</code>. Si está usando <em>varias</em> pero no
<em>todas</em> las columnas, puede combinar <code>.SD</code> con
<code>.SDcols</code>; Consulte <code>?data.table</code>.</p>
</div>
<div id="por-qué-el-valor-predeterminado-para-mult-ahora-es-all" class="section level2">
<h2>¿Por qué el valor predeterminado para <code>mult</code> ahora es
<code>&quot;all&quot;</code>?</h2>
<p>En la v1.5.3, el valor predeterminado se cambió a <code>&quot;all&quot;</code>.
Cuando <code>i</code> (o la clave de <code>i</code> si tiene una) tiene
menos columnas que la clave de <code>x</code>, <code>mult</code> ya
estaba configurado en <code>&quot;all&quot;</code> automáticamente. Cambiar el
valor predeterminado hace que esto sea más claro y fácil para los
usuarios, ya que se producía con bastante frecuencia.</p>
<p>En versiones anteriores a la v1.3, <code>&quot;all&quot;</code> era más lento.
Internamente, <code>&quot;all&quot;</code> se implementaba uniendo mediante
<code>&quot;first&quot;</code>, luego nuevamente desde cero mediante
<code>&quot;last&quot;</code>, después de lo cual se realizaba una comparación
entre ellos para calcular el lapso de coincidencias en <code>x</code>
para cada fila en <code>i</code>. Sin embargo, la mayoría de las veces
unimos filas individuales, donde <code>&quot;first&quot;</code>,
<code>&quot;last&quot;</code> y <code>&quot;all&quot;</code> devuelven el mismo resultado.
Preferimos el máximo rendimiento para la mayoría de las situaciones, por
lo que el valor predeterminado elegido fue <code>&quot;first&quot;</code>. Al
trabajar con una clave no única (generalmente una sola columna que
contiene una variable de agrupación), <code>DT[&quot;A&quot;]</code> devolvió la
primera fila de ese grupo, por lo que se necesitaba
<code>DT[&quot;A&quot;, mult = &quot;all&quot;]</code> para devolver todas las filas de ese
grupo.</p>
<p>En la v1.4, la búsqueda binaria en C se modificó para que se
ramificara en el nivel más profundo para encontrar el primero y el
último. Es probable que esa ramificación se produzca dentro de las
mismas páginas finales de RAM, por lo que ya no debería haber una
desventaja de velocidad al establecer <code>mult</code> como
<code>&quot;all&quot;</code> de forma predeterminada. Advertimos que el valor
predeterminado podría cambiar e hicimos el cambio en la v1.5.3.</p>
<p>Una versión futura de data.table puede permitir una distinción entre
una clave y una <em>clave única</em>. Internamente,
<code>mult = &quot;all&quot;</code> funcionaría más como
<code>mult = &quot;first&quot;</code> cuando todas las columnas de clave de
<code>x</code> se unieran y la clave de <code>x</code> fuera una clave
única. data.table necesitaría verificaciones en la inserción y
actualización para asegurarse de que se mantenga una clave única. Una
ventaja de especificar una clave única sería que data.table garantizaría
que no se puedan insertar duplicados, además del rendimiento.</p>
</div>
<div id="estoy-usando-c-en-j-y-obtengo-resultados-extraños." class="section level2">
<h2>Estoy usando <code>c()</code> en <code>j</code> y obtengo resultados
extraños.</h2>
<p>Esta es una fuente común de confusión. En <code>data.frame</code> se
acostumbra, por ejemplo:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>DF <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">y =</span> <span class="dv">4</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">z =</span> <span class="dv">7</span><span class="sc">:</span><span class="dv">9</span>)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>DF</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co">#   x y z</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co"># 1 1 4 7</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co"># 2 2 5 8</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co"># 3 3 6 9</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>DF[ , <span class="fu">c</span>(<span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>)]</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="co">#   y z</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co"># 1 4 7</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co"># 2 5 8</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co"># 3 6 9</span></span></code></pre></div>
<p>que devuelve las dos columnas. En data.table usted sale que puede
usar los nombres de las columnas directamente y puede intentar:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">data.table</span>(DF)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>DT[ , <span class="fu">c</span>(y, z)]</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># [1] 4 5 6 7 8 9</span></span></code></pre></div>
<p>pero esto devuelve un vector. Recuerde que la expresión
<code>j</code> se evalúa dentro del entorno de <code>DT</code> y
<code>c()</code> devuelve un vector. Si se requieren 2 o más columnas,
use <code>list()</code> o <code>.()</code> en su lugar:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>DT[ , .(y, z)]</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="co">#        y     z</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co"># 1:     4     7</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co"># 2:     5     8</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co"># 3:     6     9</span></span></code></pre></div>
<p><code>c()</code> también puede ser útil en un data.table, pero su
comportamiento es diferente al de <code>[.data.frame</code>.</p>
</div>
<div id="he-creado-una-tabla-compleja-con-muchas-columnas.-quiero-usarla-como-plantilla-para-una-nueva-tabla-es-decir-crear-una-nueva-tabla-sin-filas-pero-con-los-nombres-y-tipos-de-columnas-copiados-de-mi-tabla.-puedo-hacer-eso-fácilmente" class="section level2">
<h2>He creado una tabla compleja con muchas columnas. Quiero usarla como
plantilla para una nueva tabla; <em>es decir</em>, crear una nueva tabla
sin filas, pero con los nombres y tipos de columnas copiados de mi
tabla. ¿Puedo hacer eso fácilmente?</h2>
<p>Sí. Si su tabla compleja se llama <code>DT</code>, prueba
<code>NEWDT = DT[0]</code>.</p>
</div>
<div id="un-data.table-nulo-es-lo-mismo-que-dt0" class="section level2">
<h2>¿Un data.table nulo es lo mismo que <code>DT[0]</code>?</h2>
<p>No. Con “data.table null” nos referimos al resultado de
<code>data.table(NULL)</code> o <code>as.data.table(NULL)</code>; <em>es
decir</em>,</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">data.table</span>(<span class="cn">NULL</span>)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co"># Null data.table (0 rows and 0 cols)</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="cn">NULL</span>)</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># data frame with 0 columns and 0 rows</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="fu">as.data.table</span>(<span class="cn">NULL</span>)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co"># Null data.table (0 rows and 0 cols)</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="fu">as.data.frame</span>(<span class="cn">NULL</span>)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co"># data frame with 0 columns and 0 rows</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="fu">is.null</span>(<span class="fu">data.table</span>(<span class="cn">NULL</span>))</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co"># [1] FALSE</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a><span class="fu">is.null</span>(<span class="fu">data.frame</span>(<span class="cn">NULL</span>))</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="co"># [1] FALSE</span></span></code></pre></div>
<p>El data.table|<code>frame</code> nulo es <code>NULL</code> con
algunos atributos adjuntos, lo que significa que ya no es
<code>NULL</code>. En R, solo <code>NULL</code> puro es
<code>NULL</code>, como se prueba con <code>is.null()</code>. Cuando nos
referimos al “data.table null”, usamos null en minúscula para ayudar a
distinguirlo de <code>NULL</code> en mayúscula. Para probar el
data.table nulo, use <code>length(DT) == 0</code> o
<code>ncol(DT) == 0</code> (<code>length</code> es un poco más rápido,
ya que es una función primitiva).</p>
<p>Un data.table <em>vacío</em> (<code>DT[0]</code>) tiene una o más
columnas, todas las cuales están vacías. Esas columnas vacías aún tienen
nombres y tipos.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">data.table</span>(<span class="at">a =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">b =</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>), <span class="at">d =</span> <span class="fu">c</span>(<span class="dv">7</span><span class="dt">L</span>,<span class="dv">8</span><span class="dt">L</span>,<span class="dv">9</span><span class="dt">L</span>))</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>DT[<span class="dv">0</span>]</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co"># Empty data.table (0 rows and 3 cols): a,b,d</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="fu">sapply</span>(DT[<span class="dv">0</span>], class)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#         a         b         d </span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co"># &quot;integer&quot; &quot;numeric&quot; &quot;integer&quot;</span></span></code></pre></div>
</div>
<div id="DTremove1" class="section level2">
<h2>¿Por qué se ha eliminado el alias <code>DT()</code>?</h2>
<p><code>DT</code> se introdujo originalmente como un contenedor para
una lista de expresiones en <code>j</code>. Dado que <code>DT</code> era
un alias para data.table, era una forma conveniente de encargarse del
reciclaje silencioso en los casos en que cada elemento de la lista
<code>j</code> evaluaba en longitudes diferentes. Sin embargo, el alias
era una de las razones por las que la agrupación era lenta.</p>
<p>A partir de la v1.3, <code>list()</code> o <code>.()</code> se deben
pasar en su lugar al argumento <code>j</code>. Esto es mucho más rápido,
especialmente cuando hay muchos grupos. Internamente, este fue un cambio
no trivial. El reciclaje de vectores ahora se realiza internamente,
junto con varias otras mejoras de velocidad para la agrupación.</p>
</div>
<div id="DTremove2" class="section level2">
<h2>Pero mi código usa <code>j = DT(...)</code> y funciona. La pregunta
frecuente anterior dice que <code>DT()</code> se ha eliminado.</h2>
<p>Entonces está usando una versión anterior a la 1.5.3. Antes de la
versión 1.5.3, <code>[.data.table</code> detectaba el uso de
<code>DT()</code> en <code>j</code> y lo reemplazaba automáticamente con
una llamada a <code>list()</code>. Esto era para ayudar a la transición
de los usuarios existentes.</p>
</div>
<div id="cuáles-son-las-reglas-de-alcance-para-las-expresiones-en-j" class="section level2">
<h2>¿Cuáles son las reglas de alcance para las expresiones en
<code>j</code>?</h2>
<p>Piense en el subconjunto como un entorno donde todos los nombres de
columna son variables. Cuando se utiliza una variable <code>foo</code>
en <code>j</code> de una consulta como <code>X[Y, sum(foo)]</code>, se
busca <code>foo</code> en el siguiente orden:</p>
<p>===== 1. El ámbito del subconjunto de <code>X</code>; <em>es
decir</em>, los nombres de columna de <code>X</code>. 2. El ámbito de
cada fila de <code>Y</code>; <em>es decir</em>, los nombres de columna
de <code>Y</code> (<em>ámbito heredado de join</em>) 3. El ámbito del
marco de llamada; <em>p.ej.</em>, la línea que aparece antes de la
consulta data.table.===== ===== 4. Ejercicio para el lector: ¿entonces
se extiende a través de los marcos de llamada o va directamente al
entorno global <code>globalenv()</code>? 5. El entorno global=====</p>
<p>Esto se denomina <em>alcance léxico</em> como se explica en <a href="https://cran.r-project.org/doc/FAQ/R-FAQ.html#Lexical-scoping">Preguntas
frecuentes de R 3.3.1</a>. Sin embargo, el entorno en el que se creó la
función no es relevante, porque <em>no hay función</em>. No se pasa
ninguna <em>función</em> anónima a <code>j</code>. En cambio, se pasa un
<em>cuerpo</em> anónimo a <code>j</code>; por ejemplo,</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">data.table</span>(<span class="at">x =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>), <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>)), <span class="at">y =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>DT</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co">#         x     y</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;int&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co"># 1:      a     1</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="co"># 2:      a     2</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co"># 3:      b     3</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co"># 4:      b     4</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="co"># 5:      b     5</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>DT[ , {z <span class="ot">=</span> <span class="fu">sum</span>(y); z <span class="sc">+</span> <span class="dv">3</span>}, by <span class="ot">=</span> x]</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="co">#         x    V1</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;num&gt;</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="co"># 1:      a     6</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a><span class="co"># 2:      b    15</span></span></code></pre></div>
<p>Algunos lenguajes de programación llaman a esto <em>lambda</em>.</p>
</div>
<div id="j-trace" class="section level2">
<h2>¿Puedo rastrear la expresión <code>j</code> a medida que se ejecuta
a través de los grupos?</h2>
<p>Intente algo como esto:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>DT[ , {</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">&quot;Objects:&quot;</span>, <span class="fu">paste</span>(<span class="fu">objects</span>(), <span class="at">collapse =</span> <span class="st">&quot;,&quot;</span>), <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">&quot;Trace: x=&quot;</span>, <span class="fu">as.character</span>(x), <span class="st">&quot; y=&quot;</span>, y, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="fu">sum</span>(y)},</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  by <span class="ot">=</span> x]</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co"># Objects: -.POSIXt,Cfastmean,print,x,y </span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co"># Trace: x= a  y= 1 2 </span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co"># Objects: -.POSIXt,Cfastmean,print,x,y </span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co"># Trace: x= b  y= 3 4 5</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#         x    V1</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;int&gt;</span></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a><span class="co"># 1:      a     3</span></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="co"># 2:      b    12</span></span></code></pre></div>
</div>
<div id="dentro-de-cada-grupo-por-qué-las-variables-de-grupo-tienen-una-longitud-de-1" class="section level2">
<h2>Dentro de cada grupo, ¿por qué las variables de grupo tienen una
longitud de 1?</h2>
<p><a href="#j-trace">Arriba</a>, <code>x</code> es una variable de
agrupamiento y (a partir de v1.6.1) tiene <code>length</code> 1 (si se
inspecciona o se usa en <code>j</code>). Es por eficiencia y
conveniencia. Por lo tanto, no hay diferencia entre las siguientes dos
declaraciones:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>DT[ , .(<span class="at">g =</span> <span class="dv">1</span>, <span class="at">h =</span> <span class="dv">2</span>, <span class="at">i =</span> <span class="dv">3</span>, <span class="at">j =</span> <span class="dv">4</span>, <span class="at">repeatgroupname =</span> x, <span class="fu">sum</span>(y)), by <span class="ot">=</span> x]</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="co">#         x     g     h     i     j repeatgroupname    V6</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt;          &lt;char&gt; &lt;int&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co"># 1:      a     1     2     3     4               a     3</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co"># 2:      b     1     2     3     4               b    12</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>DT[ , .(<span class="at">g =</span> <span class="dv">1</span>, <span class="at">h =</span> <span class="dv">2</span>, <span class="at">i =</span> <span class="dv">3</span>, <span class="at">j =</span> <span class="dv">4</span>, <span class="at">repeatgroupname =</span> x[<span class="dv">1</span>], <span class="fu">sum</span>(y)), by <span class="ot">=</span> x]</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#         x     g     h     i     j repeatgroupname    V6</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt;          &lt;char&gt; &lt;int&gt;</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co"># 1:      a     1     2     3     4               a     3</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a><span class="co"># 2:      b     1     2     3     4               b    12</span></span></code></pre></div>
<p>Si necesita el tamaño del grupo actual, use <code>.N</code> en lugar
de llamar a <code>length()</code> en cualquier columna.</p>
</div>
<div id="solo-se-imprimen-las-primeras-10-filas-cómo-imprimo-más" class="section level2">
<h2>Solo se imprimen las primeras 10 filas, ¿cómo imprimo más?</h2>
<p>Aquí suceden dos cosas. Primero, si la cantidad de filas en una tabla
de datos es grande (<code>&gt; 100</code> por defecto), entonces se
imprime un resumen de la tabla de datos en la consola por defecto.
Segundo, el resumen de una tabla de datos grande se imprime tomando las
<code>n</code> filas superiores e inferiores (<code>= 5</code> por
defecto) de la tabla de datos y solo imprimiendo esas. Ambos parámetros
(cuándo activar un resumen y qué parte de una tabla utilizar como
resumen) se pueden configurar mediante el mecanismo <code>options</code>
de R o llamando directamente a la función <code>print</code>.</p>
<p>Por ejemplo, para hacer que el resumen de una tabla data.table solo
se realice cuando una tabla data.table tenga más de 50 filas, puede
<code>options(datatable.print.nrows = 50)</code>. Para deshabilitar por
completo el resumen predeterminado, puede
<code>options(datatable.print.nrows = Inf)</code>. También puede llamar
a <code>print</code> directamente, como en
<code>print(your.data.table, nrows = Inf)</code>.</p>
<p>Si desea mostrar más que las 10 filas superiores (e inferiores) de un
resumen de una tabla data.table (digamos que desea 20), configure
<code>options(datatable.print.topn = 20)</code>, por ejemplo.
Nuevamente, también podrías llamar a <code>print</code> directamente,
como en <code>print(your.data.table, topn = 20)</code>.</p>
</div>
<div id="con-una-unión-xy-qué-sucede-si-x-contiene-una-columna-llamada-y" class="section level2">
<h2>Con una unión <code>X[Y]</code>, ¿qué sucede si <code>X</code>
contiene una columna llamada <code>&quot;Y&quot;</code>?</h2>
<p>Cuando <code>i</code> es un nombre único como <code>Y</code>, se
evalúa en el marco de llamada. En todos los demás casos, como llamadas a
<code>.()</code> u otras expresiones, <code>i</code> se evalúa dentro
del alcance de <code>X</code>. Esto facilita <em>autouniones</em>
sencillas como <code>X[J(unique(colA)), mult = &quot;first&quot;]</code>.</p>
</div>
<div id="xzy-está-fallando-porque-x-contiene-una-columna-y.-me-gustaría-que-utilizara-la-tabla-y-en-el-ámbito-de-llamada." class="section level2">
<h2><code>X[Z[Y]]</code> está fallando porque <code>X</code> contiene
una columna <code>&quot;Y&quot;</code>. Me gustaría que utilizara la tabla
<code>Y</code> en el ámbito de llamada.</h2>
<p>La parte <code>Z[Y]</code> no es un nombre único, por lo que se
evalúa dentro del marco de <code>X</code> y se produce el problema.
Pruebe <code>tmp = Z[Y]; X[tmp]</code>. Esto es robusto para
<code>X</code> que contiene una columna <code>&quot;tmp&quot;</code> porque
<code>tmp</code> es un nombre único. Si a menudo encuentra conflictos de
este tipo, una solución simple puede ser nombrar todas las tablas en
mayúsculas y todos los nombres de columnas en minúsculas, o algún
esquema similar.</p>
</div>
<div id="puede-explicar-con-más-detalle-por-qué-data.table-está-inspirado-en-la-sintaxis-ab-en-base" class="section level2">
<h2>¿Puede explicar con más detalle por qué data.table está inspirado en
la sintaxis <code>A[B]</code> en <code>base</code>?</h2>
<p>Considere la sintaxis <code>A[B]</code> utilizando una matriz de
ejemplo <code>A</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>A <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">12</span>, <span class="at">nrow =</span> <span class="dv">4</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>A</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co">#      [,1] [,2] [,3]</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co"># [1,]    1    5    9</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co"># [2,]    2    6   10</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co"># [3,]    3    7   11</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co"># [4,]    4    8   12</span></span></code></pre></div>
<p>Para obtener las celdas <code>(1, 2) = 5</code> y
<code>(3, 3) = 11</code> muchos usuarios (creemos) pueden intentar esto
primero:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>A[<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>)]</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="co">#      [,1] [,2]</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co"># [1,]    5    9</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co"># [2,]    7   11</span></span></code></pre></div>
<p>Sin embargo, esto devuelve la unión de esas filas y columnas. Para
hacer referencia a las celdas, se requiere una matriz de 2 columnas.
<code>?Extract</code> dice:</p>
<blockquote>
<p>Al indexar matrices por <code>[</code> un único argumento
<code>i</code> puede ser una matriz con tantas columnas como dimensiones
de <code>x</code>; el resultado es entonces un vector con elementos
correspondientes a los conjuntos de índices en cada fila de
<code>i</code>.</p>
</blockquote>
<p>Probemos de nuevo.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>B <span class="ot">=</span> <span class="fu">cbind</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>))</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>B</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co">#      [,1] [,2]</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co"># [1,]    1    2</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co"># [2,]    3    3</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>A[B]</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co"># [1]  5 11</span></span></code></pre></div>
<p>Una matriz es una estructura bidimensional con nombres de filas y
nombres de columnas. ¿Podemos hacer lo mismo con los nombres?</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">rownames</span>(A) <span class="ot">=</span> letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="fu">colnames</span>(A) <span class="ot">=</span> LETTERS[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>]</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>A</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co">#   A B  C</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="co"># a 1 5  9</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="co"># b 2 6 10</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="co"># c 3 7 11</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a><span class="co"># d 4 8 12</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>B <span class="ot">=</span> <span class="fu">cbind</span>(<span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>), <span class="fu">c</span>(<span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>))</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>A[B]</span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a><span class="co"># [1]  5 11</span></span></code></pre></div>
<p>Entonces sí podemos. ¿Podemos hacer lo mismo con un
<code>data.frame</code>?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>A <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">A =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>, <span class="at">B =</span> letters[<span class="dv">11</span><span class="sc">:</span><span class="dv">14</span>], <span class="at">C =</span> pi<span class="sc">*</span><span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="fu">rownames</span>(A) <span class="ot">=</span> letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>A</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">#   A B         C</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co"># a 1 k  3.141593</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co"># b 2 l  6.283185</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co"># c 3 m  9.424778</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="co"># d 4 n 12.566371</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>B</span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="co">#      [,1] [,2]</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a><span class="co"># [1,] &quot;a&quot;  &quot;B&quot; </span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="co"># [2,] &quot;c&quot;  &quot;C&quot;</span></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>A[B]</span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a><span class="co"># [1] &quot;k&quot;         &quot; 9.424778&quot;</span></span></code></pre></div>
<p>Pero, observe que el resultado fue convertido a
<code>character.</code>. R convirtió <code>A</code> a
<code>matrix</code> primero para que la sintaxis pudiera funcionar, pero
el resultado no es ideal. Intentemos hacer que <code>B</code> sea un
<code>data.frame</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>B <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>), <span class="fu">c</span>(<span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>))</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="fu">cat</span>(<span class="fu">try</span>(A[B], <span class="at">silent =</span> <span class="cn">TRUE</span>))</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="co"># Error in `[.default`(A, B) : invalid subscript type &#39;list&#39;</span></span></code></pre></div>
<p>Por lo tanto, no podemos subconjunto de un <code>data.frame</code>
por un <code>data.frame</code> en R base. ¿Qué pasa si queremos nombres
de fila y nombres de columna que no sean <code>character</code> sino
<code>integer</code> o <code>float</code>? ¿Qué pasa si queremos más de
2 dimensiones de tipos mixtos? Ingrese data.table.</p>
<p>Además, las matrices, especialmente las matrices dispersas, a menudo
se almacenan en una tupla de 3 columnas: <code>(i, j, value)</code>.
Esto puede considerarse como un par clave-valor donde <code>i</code> y
<code>j</code> forman una clave de 2 columnas. Si tenemos más de un
valor, tal vez de diferentes tipos, podría verse como
<code>(i, j, val1, val2, val3, ...)</code>. Esto se parece mucho a un
<code>data.frame</code>. Por lo tanto, data.table extiende
<code>data.frame</code> de modo que un <code>data.frame</code>
<code>X</code> puede ser subconjunto de un <code>data.frame</code>
<code>Y</code>, lo que lleva a la sintaxis <code>X[Y]</code>.</p>
</div>
<div id="se-puede-cambiar-r-base-para-hacer-esto-en-lugar-de-un-nuevo-paquete" class="section level2">
<h2>¿Se puede cambiar R base para hacer esto, en lugar de un nuevo
paquete?</h2>
<p><code>data.frame</code> se usa <em>en todas partes</em> y por eso es
muy difícil hacer <em>algun</em> cambio. data.table <em>hereda</em> de
<code>data.frame</code>. También <em>es</em> un <code>data.frame</code>.
Un data.table <em>se puede</em> pasar a cualquier paquete que
<em>solo</em> acepte <code>data.frame</code>. Cuando ese paquete usa la
sintaxis <code>[.data.frame</code> en el data.table, funciona. Funciona
porque <code>[.data.table</code> busca ver desde dónde fue llamado. Si
fue llamado desde un paquete de ese tipo, <code>[.data.table</code>
redirecciona a <code>[.data.frame</code>.</p>
</div>
<div id="he-oído-que-la-sintaxis-de-data.table-es-análoga-a-la-de-sql." class="section level2">
<h2>He oído que la sintaxis de data.table es análoga a la de SQL.</h2>
<p>Sí:</p>
<p>===== - <code>i</code> <span class="math display">\[$\Leftrightarrow\]</span>$ donde - <code>j</code>
<span class="math display">\[$\Leftrightarrow\]</span>$ seleccionar -
<code>:=</code> <span class="math display">\[$\Leftrightarrow\]</span>$
actualizar - <code>by</code> <span class="math display">\[$\Leftrightarrow\]</span>$ agrupar por -
<code>i</code> <span class="math display">\[$\Leftrightarrow\]</span>$
ordenar por (en sintaxis compuesta) - <code>i</code> <span class="math display">\[$\Leftrightarrow\]</span>$ tener (en sintaxis
compuesta) - <code>nomatch = NA</code> <span class="math display">\[$\Leftrightarrow\]</span>$ unión externa -
<code>nomatch = NULL</code> <span class="math display">\[$\Leftrightarrow\]</span>$ unión interna join -
<code>mult = &quot;first&quot;|&quot;last&quot;</code> <span class="math display">\[$\Leftrightarrow\]</span>$ N/A porque SQL es
inherentemente desordenado - <code>roll = TRUE</code> <span class="math display">\[$\Leftrightarrow\]</span>$ N/A porque SQL es
inherentemente desordenado=====</p>
<p>La forma general es:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>DT[where, select<span class="sc">|</span>update, group by][order by][...] ... [...]</span></code></pre></div>
<p>Una ventaja clave de los vectores de columna en R es que están
<em>ordenados</em>, a diferencia de SQL<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. Podemos usar
funciones ordenadas en consultas <code>data.table</code> como
<code>diff()</code> y podemos usar <em>cualquier</em> función R de
cualquier paquete, no solo las funciones que están definidas en SQL. Una
desventaja es que los objetos R deben caber en la memoria, pero con
varios paquetes R como <code>ff</code>, <code>bigmemory</code>,
<code>mmap</code> e <code>indexing</code>, esto está cambiando.</p>
</div>
<div id="SmallerDiffs" class="section level2">
<h2>¿Cuáles son las diferencias de sintaxis más pequeñas entre
<code>data.frame</code> y data.table?</h2>
<p>===== - <code>DT[3]</code> se refiere a la 3ra <em>fila</em>, pero
<code>DF[3]</code> se refiere a la 3ra <em>columna</em> -
<code>DT[3, ] == DT[3]</code>, pero <code>DF[ , 3] == DF[3]</code> (de
manera algo confusa en data.frame, mientras que data.table es
consistente) - Por esta razón decimos que la coma es <em>opcional</em>
en <code>DT</code>, pero no opcional en <code>DF</code> -
<code>DT[[3]] == DF[, 3] == DF[[3]]</code> - <code>DT[i, ]</code>, donde
<code>i</code> es un solo entero, devuelve una sola fila, al igual que
<code>DF[i, ]</code>, pero a diferencia de un subconjunto de una sola
fila de la matriz que devuelve un vector. - <code>DT[ , j]</code> donde
<code>j</code> es un entero único, devuelve un data.table de una
columna, a diferencia de <code>DF[, j]</code> que devuelve un vector de
forma predeterminada -
<code>DT[ , &quot;colA&quot;][[1]] == DF[ , &quot;colA&quot;]</code>.===== ===== -
<code>DT[ , colA] == DF[ , &quot;colA&quot;]</code> (actualmente en data.table
v1.9.8 pero está a punto de cambiar, consulte las notas de la versión) -
<code>DT[ , list(colA)] == DF[ , &quot;colA&quot;, drop = FALSE]</code> -
<code>DT[NA]</code> devuelve 1 fila de <code>NA</code>, pero
<code>DF[NA]</code> devuelve una copia completa de <code>DF</code> que
contiene <code>NA</code> en todas partes. El símbolo <code>NA</code> es
de tipo <code>lógico</code> en R y, por lo tanto,
<code>[.data.frame</code> lo recicla. La intención del usuario
probablemente era <code>DF[NA_integer_]</code>.
<code>[.data.table</code> desvía a esta intención probable
automáticamente, para mayor comodidad. -
<code>DT[c(TRUE, NA, FALSE)]</code> trata a <code>NA</code> como
<code>FALSE</code>, pero <code>DF[c(TRUE, NA, FALSE)]</code>
devuelve===== <code>NA</code> filas para cada <code>NA</code> ===== -
<code>DT[ColA == ColB]</code> es más simple que
<code>DF[!is.na(ColA) &amp; !is.na(ColB) &amp; ColA == ColB, ]</code> -
<code>data.frame(list(1:2, &quot;k&quot;, 1:4))</code> crea 3 columnas, data.table
crea una columna <code>list</code>. - <code>check.names</code> es por
defecto <code>TRUE</code> en <code>data.frame</code> pero
<code>FALSE</code> en data.table, para mayor comodidad. -
<code>data.table</code> siempre ha establecido
<code>stringsAsFactors=FALSE</code> de forma predeterminada. En R 4.0.0
(abril de 2020), el valor predeterminado de <code>data.frame</code> se
cambió de <code>TRUE</code> a <code>FALSE</code> y ya no hay ninguna
diferencia en este sentido; Consulte <a href="https://developer.r-project.org/Blog/public/2020/02/16/stringsasfactors/">stringsAsFactors,
Kurt Hornik, febrero de 2020</a>.===== ===== - Los vectores atómicos en
las columnas de <code>list</code> se contraen cuando se imprimen usando
<code>&quot;, &quot;</code> en <code>data.frame</code>, pero <code>&quot;,&quot;</code> en
data.table con una coma final después del sexto elemento para evitar la
impresión accidental de objetos incrustados grandes. - A diferencia de
data.frames, un data.table no puede almacenar filas sin columnas, ya que
las filas se consideran hijos de las columnas:
<code>nrow(DF[, 0])</code> devuelve la cantidad de filas, mientras que
<code>nrow(DT[, 0])</code> siempre devuelve 0; pero consulte el problema
<a href="https://github.com/Rdatatable/data.table/issues/2422">#2422</a>.=====</p>
<p>En <code>[.data.frame</code>, muy a menudo establecemos
<code>drop = FALSE</code>. Cuando nos olvidamos, pueden surgir errores
en casos extremos en los que se seleccionan columnas individuales y, de
repente, se devuelve un vector en lugar de una sola columna
<code>data.frame</code>. En <code>[.data.table</code> aprovechamos la
oportunidad para hacerlo coherente y eliminamos <code>drop</code>.</p>
<p>Cuando se pasa un data.table a un paquete que no es compatible con
data.table, ese paquete no se preocupa por ninguna de estas diferencias;
simplemente funciona.</p>
</div>
<div id="estoy-usando-j-solo-por-su-efecto-secundario-pero-sigo-obteniendo-datos-devueltos.-cómo-puedo-detener-eso" class="section level2">
<h2>Estoy usando <code>j</code> solo por su efecto secundario, pero sigo
obteniendo datos devueltos. ¿Cómo puedo detener eso?</h2>
<p>En este caso, <code>j</code> se puede encapsular con
<code>invisible()</code>; por ejemplo,
<code>DT[ , invisible(hist(colB)), by = colA]</code><a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
</div>
<div id="por-qué-.data.table-ahora-tiene-un-argumento-drop-de-la-v1.5" class="section level2">
<h2>¿Por qué <code>[.data.table</code> ahora tiene un argumento
<code>drop</code> de la v1.5?</h2>
<p>Para que data.table pueda heredar de <code>data.frame</code> sin usar
<code>...</code>. Si usáramos <code>...</code>, no se detectarían los
nombres de argumentos no válidos.</p>
<p>El argumento <code>drop</code> nunca lo usa
<code>[.data.table</code>. Es un marcador de posición para paquetes que
no son compatibles con data.table cuando usan la sintaxis
<code>[.data.frame</code> directamente en un data.table.</p>
</div>
<div id="las-uniones-continuas-son-geniales-y-muy-rápidas-fue-difícil-de-programar" class="section level2">
<h2>¡Las uniones continuas son geniales y muy rápidas! ¿Fue difícil de
programar?</h2>
<p>La fila que prevalece en o antes de la fila <code>i</code> es la fila
final que prueba la búsqueda binaria de todos modos. Entonces
<code>roll = TRUE</code> es esencialmente solo un cambio en el código C
de búsqueda binaria para devolver esa fila.</p>
</div>
<div id="por-qué-dti-col-value-devuelve-todo-el-dt-esperaba-o-bien-un-valor-no-visible-coherente-con---o-bien-un-mensaje-o-valor-de-retorno-que-contenga-cuántas-filas-se-actualizaron.-no-es-obvio-que-los-datos-se-hayan-actualizado-por-referencia." class="section level2">
<h2>¿Por qué <code>DT[i, col := value]</code> devuelve todo el
<code>DT</code>? Esperaba o bien un valor no visible (coherente con
<code>&lt;-</code>), o bien un mensaje o valor de retorno que contenga
cuántas filas se actualizaron. No es obvio que los datos se hayan
actualizado por referencia.</h2>
<p>Esto ha cambiado en v1.8.3 para cumplir con sus expectativas.
Actualice.</p>
<p>Se devuelve todo el <code>DT</code> (ahora de forma invisible) para
que la sintaxis compuesta pueda funcionar; <em>p. ej.</em>,
<code>DT[i, done := TRUE][ , sum(done)]</code>. La cantidad de filas
actualizadas se devuelve cuando <code>verbose</code> es
<code>TRUE</code>, ya sea por consulta o de forma global utilizando
<code>options(datatable.verbose = TRUE)</code>.</p>
</div>
<div id="bien-gracias.-qué-tenía-de-difícil-que-el-resultado-de-dti-col-value-se-devolviera-de-forma-invisible" class="section level2">
<h2>Bien, gracias. ¿Qué tenía de difícil que el resultado de
<code>DT[i, col := value]</code> se devolviera de forma invisible?</h2>
<p>R fuerza internamente la visibilidad para <code>[</code>. El valor de
la columna “eval” en FunTab (ver <a href="https://github.com/wch/r-source/blob/trunk/src/main/names.c">src/main/names.c</a>)
para <code>[</code> es <code>0</code>, lo que significa que se fueza
<code>R_Visible</code> (ver <a href="https://cran.r-project.org/doc/manuals/r-release/R-ints.html#Autoprinting">R-Internals
sección 1.6</a>). Por lo tanto, cuando intentábamos usar
<code>invisible()</code> o configurar <code>R_Visible</code> en
<code>0</code> directamente nosotros mismos, <code>eval</code> en <a href="https://github.com/wch/r-source/blob/trunk/src/main/eval.c">src/main/eval.c</a>
lo activaba nuevamente.</p>
<p>Para resolver este problema, la clave era dejar de intentar detener
la ejecución del método de impresión después de un <code>:=</code>. En
cambio, dentro de <code>:=</code> ahora (desde v1.8.3) configuramos un
indicador global que el método de impresión usa para saber si imprimir o
no.</p>
</div>
<div id="por-qué-a-veces-tengo-que-escribir-dt-dos-veces-después-de-usar-para-imprimir-el-resultado-en-la-consola" class="section level2">
<h2>¿Por qué a veces tengo que escribir <code>DT</code> dos veces
después de usar <code>:=</code> para imprimir el resultado en la
consola?</h2>
<p>Este es un inconveniente desafortunado para que funcione <a href="https://github.com/Rdatatable/data.table/issues/869">#869</a>. Si
se usa un <code>:=</code> dentro de una función sin <code>DT[]</code>
antes del final de la función, entonces la próxima vez que se escriba
<code>DT</code> en la consola interactiva de R, no se imprimirá nada.
Pero al repetir <code>DT</code>, se imprimirá. Para evitar esto: incluya
un <code>DT[]</code> después del último <code>:=</code> en su función.
Si eso no es posible (por ejemplo, no es una función que puede cambiar),
entonces se garantiza que <code>print(DT)</code> y <code>DT[]</code> en
la consola se imprimirán. Como antes, agregar un <code>[]</code>
adicional al final de la consulta <code>:=</code> es un estilo
recomendado para actualizar y luego imprimir; por ejemplo,
<code>DT[,foo:=3L][]</code>.</p>
</div>
<div id="he-notado-que-basecbind.data.frame-y-baserbind.data.frame-parecen-ser-modificados-por-data.table.-cómo-es-esto-posible-por-qué" class="section level2">
<h2>He notado que <code>base::cbind.data.frame</code> (y
<code>base::rbind.data.frame</code>) parecen ser modificados por
data.table. ¿Cómo es esto posible? ¿Por qué?</h2>
<p>Fue una solución temporal, de último recurso, antes de que se
solucionara la resolución de métodos S3 de rbind y cbind en R &gt;=
4.0.0. Básicamente, el problema era que <code>data.table</code> hereda
de <code>data.frame</code>, <em>y</em> <code>base::cbind</code> y
<code>base::rbind</code> (de manera única) realizan su propio envío S3
internamente, como lo documenta <code>?cbind</code>. La solución
alternativa de <code>data.table</code> fue agregar un bucle
<code>for</code> al comienzo de cada función directamente en
<code>base</code>. Esa modificación se realizaba de manera dinámica,
<em>es decir</em>, se obtenía la definición <code>base</code> de
<code>cbind.data.frame</code>, se agregaba el bucle <code>for</code> al
comienzo y luego se asignaba nuevamente a <code>base</code>. Esta
solución fue diseñada para ser robusta ante diferentes definiciones de
<code>base::cbind.data.frame</code> en diferentes versiones de R,
incluidos cambios futuros desconocidos. Funcionó bien. Los requisitos en
competencia fueron:</p>
<p>===== - <code>cbind(DT, DF)</code> debe funcionar. La definición de
<code>cbind.data.table</code> no funcionaba porque
<code>base::cbind</code> realiza su propio envío S3 y requería (antes de
R 4.0.0) que el <em>primer</em> método <code>cbind</code> para cada
objeto que se le pasa sea <em>idéntico</em>. Esto no es cierto en
<code>cbind(DT, DF)</code> porque el primer método para <code>DT</code>
es <code>cbind.data.table</code> pero el primer método para
<code>DF</code> es <code>cbind.data.frame</code>.
<code>base::cbind</code> luego pasaba a su código <code>bind</code>
interno que al parecer trata a <code>DT</code> como una lista regular, y
devuelve una salida <code>matrix</code> de aspecto muy extraño e
inutilizable. Consulte <a href="#cbinderror">a continuación</a>. No
podemos simplemente recomendar a los usuarios que no llamen a
<code>cbind(DT, DF)</code> porque los paquetes como <code>ggplot2</code>
hacen tal llamada (<a href="https://github.com/Rdatatable/data.table/blob/master/inst/tests/tests.Rraw#L444-L447">prueba
167.2</a>).=====</p>
<p>===== - Naturalmente, esto nos llevó a intentar enmascarar
<code>cbind.data.frame</code>. Dado que un data.table es un
<code>data.frame</code>, <code>cbind</code> encontraría el mismo método
tanto para <code>DT</code> como para <code>DF</code>. Sin embargo, esto
tampoco funcionó porque <code>base::cbind</code> parece encontrar los
métodos en <code>base</code> primero; <em>es decir</em>,
<code>base::cbind.data.frame</code> no se puede enmascarar.=====</p>
<p>===== - Finalmente, intentamos enmascarar <code>cbind</code> en sí
(v1.6.5 y v1.6.6). Esto permitió que <code>cbind(DT, DF)</code>
funcionara, pero introdujo problemas de compatibilidad con el paquete
<code>IRanges</code>, ya que <code>IRanges</code> también enmascara
<code>cbind</code>. Funcionó si <code>IRanges</code> estaba más abajo en
la ruta <code>search()</code> que data.table, pero si
<code>IRanges</code> estaba más arriba que data.table,
<code>cbind</code> nunca se llamaba, y la salida <code>matrix</code> de
aspecto extraño se produciría nuevamente (ver <a href="#cbinderror">a
continuación</a>).=====</p>
<p>Muchas gracias al equipo central de R por solucionar el problema en
septiembre de 2019. data.table v1.12.6+ ya no aplica la solución
alternativa en R &gt;= 4.0.0.</p>
</div>
<div id="r-dispatch" class="section level2">
<h2>He leído sobre la resolución de métodos (por ejemplo,
<code>merge</code> puede o no despacharse a
<code>merge.data.table</code>) pero ¿cómo sabe R cómo despachar? ¿Son
los ‘dots’ (puntos) significativos o especiales? ¿Cómo diantres sabe R
qué función despachar y cuándo?</h2>
<p>Esta pregunta surge bastante seguido, pero en realidad es
increíblemente simple. Una función como <code>merge</code> es
<em>genérica</em> si consiste en una llamada a <code>UseMethod</code>.
Cuando ve a gente hablando sobre si las funciones son o no funciones
<em>genéricas</em>, simplemente están escribiendo la función sin
<code>()</code> después, mirando el código del programa dentro de ella y
si ven una llamada a <code>UseMethod</code> entonces es
<em>genérica</em>. ¿Qué hace <code>UseMethod</code>? Literalmente pega
el nombre de la función junto con la clase del primer argumento,
separados por un punto (<code>.</code>) y luego llama a esa función,
pasando los mismos argumentos. Es así de simple. Por ejemplo,
<code>merge(X, Y)</code> contiene una llamada a <code>UseMethod</code>,
lo que significa que luego <em>despacha</em> (es decir, llama) a
<code>paste(&quot;merge&quot;, class(X), sep = &quot;.&quot;)</code>. Las funciones con
puntos en su nombre pueden ser métodos o no. El punto es irrelevante en
realidad, más allá de que el punto es el separador que usa
<code>UseMethod</code>. Conociendo este antecedente debería ahora quedar
más claro por qué, por ejemplo, es obvio para la gente de R que
<code>as.data.table.data.frame</code> es el método
<code>data.frame</code> para la función genérica
<code>as.data.table</code>. Además, puede ayudar a aclarar que sí, tiene
usted razón, no es obvio solo por su nombre que <code>ls.fit</code> no
sea el método fit de la función genérica <code>ls</code>. Solo puedes
saberlo escribiendo <code>ls</code> (no <code>ls()</code>) y observando
que no es una simple llamada a <code>UseMethod</code>.</p>
<p>Ahora puede que se pregunte: ¿dónde está documentado esto en R?
Respuesta: es bastante claro, pero primero debe saber buscar en
<code>?UseMethod</code> y <em>ese</em> archivo de ayuda contiene:</p>
<blockquote>
<p>Cuando se aplica una función que llama a
<code>UseMethod(&#39;fun&#39;)</code> a un objeto con el atributo de clase
<code>c(&#39;first&#39;, &#39;second&#39;)</code>, el sistema busca una función llamada
<code>fun.first</code> y, si la encuentra, la aplica al objeto. Si no se
encuentra dicha función, se prueba una función llamada
<code>fun.second</code>. Si ningún nombre de clase produce una función
adecuada, se utiliza la función <code>fun.default</code>, si existe, o
se produce un error.</p>
</blockquote>
<p>Afortunadamente, una búsqueda en Internet de “How does R method
dispatch work” (al momento de escribir esto) muestra la página de ayuda
<code>?UseMethod</code> en los primeros enlaces. Es cierto que otros
enlaces descienden rápidamente a las complejidades de S3 vs S4,
genéricos internos, etc.</p>
<p>Sin embargo, características como la resolución básica de métodos de
S3 (pegar el nombre de la función junto con el nombre de la clase) es la
razón por la que a algunas personas de R les encanta R. Es muy simple.
No se requiere ningún registro o firma complicados. No hay mucho que
aprender. Para crear el método <code>merge</code> para data.table, todo
lo que se requirió, literalmente, fue simplemente crear una función
llamada <code>merge.data.table</code>.</p>
</div>
<div id="por-qué-t-y-f-se-comportan-de-manera-diferente-a-true-y-false-en-algunas-consultas-data.table" class="section level2">
<h2>¿Por qué <code>T</code> y <code>F</code> se comportan de manera
diferente a <code>TRUE</code> y <code>FALSE</code> en algunas consultas
<code>data.table</code>?</h2>
<p>El uso de <code>T</code> y <code>F</code> como abreviaturas de
<code>TRUE</code> y <code>FALSE</code> en <code>data.table</code> puede
generar un comportamiento inesperado. Esto se debe a que <code>T</code>
y <code>F</code> son variables globales que se pueden redefinir, lo que
hace que se las trate como nombres de variables en lugar de constantes
lógicas. Este problema no ocurre con <code>TRUE</code> y
<code>FALSE</code>. Evitar <code>T</code> y <code>F</code> es un consejo
para usar R en general, pero aparece en <code>data.table</code> de
algunas maneras quizás sorprendentes, por ejemplo:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>DT <span class="ot">&lt;-</span> <span class="fu">data.table</span>(<span class="at">x=</span><span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>), <span class="at">each =</span> <span class="dv">3</span>), <span class="at">y=</span><span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">6</span>), <span class="at">v=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">9</span>)</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="co"># Using TRUE/FALSE works as expected in cases like the ones below:</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>DT[, .SD, .SDcols<span class="ot">=</span><span class="fu">c</span>(<span class="cn">TRUE</span>, <span class="cn">TRUE</span>, <span class="cn">FALSE</span>)]</span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="co"># A) This selects the first two columns (x and y) and excludes the third one (v). Output:</span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="co">#&gt;    x y</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co">#&gt; 1: a 1</span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="co">#&gt; 2: a 3</span></span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a><span class="co">#&gt; 3: a 6</span></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="co">#&gt; 4: b 1</span></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a><span class="co">#&gt; 5: b 3</span></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a><span class="co">#&gt; 6: b 6</span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a><span class="co">#&gt; 7: c 1</span></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a><span class="co">#&gt; 8: c 3</span></span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a><span class="co">#&gt; 9: c 6</span></span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a>DT[, .SD, .SDcols<span class="ot">=</span><span class="fu">c</span>(T, T, F), with<span class="ot">=</span><span class="cn">FALSE</span>]</span>
<span id="cb18-19"><a href="#cb18-19" tabindex="-1"></a><span class="co"># B) This forces data.table to treat T/F as logical constants.</span></span>
<span id="cb18-20"><a href="#cb18-20" tabindex="-1"></a><span class="co"># Same output as DT[, .SD, .SDcols=c(TRUE, TRUE, FALSE)]</span></span>
<span id="cb18-21"><a href="#cb18-21" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" tabindex="-1"></a><span class="co"># But, using T/F may lead to unexpected behavior in cases like:</span></span>
<span id="cb18-23"><a href="#cb18-23" tabindex="-1"></a></span>
<span id="cb18-24"><a href="#cb18-24" tabindex="-1"></a>DT[, .SD, .SDcols<span class="ot">=</span><span class="fu">c</span>(T, T, F)]</span>
<span id="cb18-25"><a href="#cb18-25" tabindex="-1"></a><span class="co"># data.table treats T and F as variable names here, not logical constants. Output:</span></span>
<span id="cb18-26"><a href="#cb18-26" tabindex="-1"></a><span class="co">#&gt; Detected that j uses these columns: &lt;none&gt;</span></span>
<span id="cb18-27"><a href="#cb18-27" tabindex="-1"></a><span class="co">#&gt; [1]  TRUE  TRUE FALSE</span></span></code></pre></div>
<p>Como consejo general, <code>lintr::T_and_F_symbol_linter()</code>
detecta el uso de <code>T</code> y <code>F</code> y sugiere
reemplazarlos con <code>TRUE</code> y <code>FALSE</code> para evitar
tales problemas.</p>
</div>
</div>
<div id="preguntas-relacionadas-con-el-tiempo-de-cómputo" class="section level1">
<h1>Preguntas relacionadas con el tiempo de cómputo</h1>
<div id="tengo-20-columnas-y-una-gran-cantidad-de-filas.-por-qué-una-expresión-de-una-columna-es-tan-rápida" class="section level2">
<h2>Tengo 20 columnas y una gran cantidad de filas. ¿Por qué una
expresión de una columna es tan rápida?</h2>
<p>Varias razones:</p>
<p>===== - Solo esa columna está agrupada, las otras 19 se ignoran
porque data.table inspecciona la expresión <code>j</code> y se da cuenta
de que no usa las otras columnas. - Se realiza una asignación de memoria
solo para el grupo más grande, luego esa memoria se reutiliza para los
otros grupos. Hay muy poca basura para recolectar. - R es un almacén de
columnas en memoria; es decir, las columnas son contiguas en la RAM. Se
minimizan las recuperaciones de páginas desde la RAM a la caché
L2.=====</p>
</div>
<div id="no-tengo-una-key-en-una-tabla-grande-pero-la-agrupación-es-realmente-rápida.-por-qué" class="section level2">
<h2>No tengo una <code>key</code> en una tabla grande, pero la
agrupación es realmente rápida. ¿Por qué?</h2>
<p>data.table usa ordenación por radix. Esto es significativamente más
rápido que otros algoritmos de ordenación. Vea <a href="https://github.com/Rdatatable/data.table/wiki/Presentations">nuestras
presentaciones</a> para obtener más información, en particular de
useR!2015 Dinamarca.</p>
<p>Esta es también una de las razones por las que <code>setkey()</code>
es rápido.</p>
<p>Cuando no se establece ninguna <code>key</code>, o agrupamos en un
orden diferente al de la clave, lo llamamos un <code>by</code> <em>ad
hoc</em>.</p>
</div>
<div id="por-qué-la-agrupación-por-columnas-en-la-clave-es-más-rápida-que-un-by-ad-hoc" class="section level2">
<h2>¿Por qué la agrupación por columnas en la clave es más rápida que un
<code>by</code> <em>ad hoc</em>?</h2>
<p>Porque cada grupo es contiguo en la RAM, lo que minimiza las
recuperaciones de páginas y la memoria se puede copiar en masa
(<code>memcpy</code> en C) en lugar de hacer un bucle en C.</p>
</div>
<div id="qué-son-los-índices-primarios-y-secundarios-en-data.table" class="section level2">
<h2>¿Qué son los índices primarios y secundarios en data.table?</h2>
<p>Manual: <a href="https://www.rdocumentation.org/packages/data.table/functions/setkey"><code>?setkey</code></a>
S.O.: <a href="https://stackoverflow.com/questions/20039335/what-is-the-purpose-of-setting-a-key-in-data-table/20057411#20057411">¿Cuál
es el propósito de establecer una clave en data.table?</a></p>
<p><code>setkey(DT, col1, col2)</code> ordena las filas por la columna
<code>col1</code> y luego, dentro de cada grupo de <code>col1</code>,
ordena por <code>col2</code>. Este es un <em>índice primario</em>. El
orden de las filas se cambia <em>por referencia</em> en la RAM. Las
uniones y grupos subsiguientes en esas columnas clave aprovechan el
orden de clasificación para lograr eficiencia. (Imagínese lo difícil que
sería buscar un número de teléfono en una guía telefónica impresa si no
estuviera ordenado por apellido y luego por nombre. Eso es literalmente
todo lo que hace <code>setkey</code>. Ordena las filas por las columnas
que usted especifica). El índice no utiliza ninguna RAM. Simplemente
cambia el orden de las filas en la RAM y marca las columnas clave.
Análogo a un <em>índice “clustered”</em> en SQL.</p>
<p>Sin embargo, solo puede tener una clave principal porque los datos
solo se pueden ordenar físicamente en RAM de una manera a la vez. Elija
el índice principal para que sea el que use con más frecuencia (por
ejemplo, <code>[id, fecha]</code>). A veces no hay una opción obvia para
la clave principal, o necesita unir y agrupar muchas columnas diferentes
en diferentes órdenes. Ingrese un índice secundario. Esto usa memoria
(<code>4*nrow</code> bytes independientemente del número de columnas en
el índice) para almacenar el orden de las filas por las columnas que
especifique, pero en realidad no reordena las filas en RAM. Las uniones
y grupos posteriores aprovechan el orden de la clave secundaria, pero
necesitan <em>saltar</em> a través de ese índice, por lo que no son tan
eficientes como los índices primarios. Pero aún así, es mucho más rápido
que un escaneo vectorial completo. No hay límite para la cantidad de
índices secundarios, ya que cada uno es solo un vector de ordenamiento
diferente. Por lo general, no necesita crear índices secundarios. Se
crean automáticamente y se usan automáticamente con el uso normal de
data.table. <em>Por ejemplo</em>,<code>DT[someCol == someVal, ]</code> y
<code>DT[someCol %in% someVals, ]</code> crearán el índice secundario,
lo adjuntarán, y luego lo usarán. Esto es más rápido en data.table que
un escaneo vectorial, por lo que la indexación automática está activada
de manera predeterminada, ya que no hay una penalización inicial. Existe
una opción para desactivar la indexación automática; <em>p. ej.</em>, si
de alguna manera se están creando muchos índices, e incluso la cantidad
relativamente pequeña de memoria adicional se vuelve demasiado
grande.</p>
<p>Usamos las palabras <em>index</em> y <em>key</em>
indistintamente.</p>
</div>
</div>
<div id="mensajes-de-error" class="section level1">
<h1>Mensajes de error</h1>
<div id="could-not-find-function-dt-no-se-pudo-encontrar-la-función-dt" class="section level2">
<h2>“Could not find function <code>DT</code>” [“No se pudo encontrar la
función <code>DT</code>”]</h2>
<p>Vea arriba <a href="#DTremove1">aquí</a> y <a href="#DTremove2">aquí</a>.</p>
</div>
<div id="unused-arguments-mysum-sumv-argumentos-no-utilizados-mysum-sumv" class="section level2">
<h2>“unused argument(s) (<code>MySum = sum(v)</code>)” [“argumento(s) no
utilizado(s) (<code>MySum = sum(v)</code>)”]</h2>
<p>Este error es generado por <code>DT[ , MySum = sum(v)]</code>.
<code>DT[ , .(MySum = sum(v))]</code> era lo que se pretendía, o
<code>DT[ , j = .(MySum = sum(v))]</code>.</p>
</div>
<div id="translatecharutf8-must-be-called-on-a-charsxp-translatecharutf8-debe-ser-llamado-en-un-charsxp" class="section level2">
<h2>“<code>translateCharUTF8</code> must be called on a
<code>CHARSXP</code>” [“<code>translateCharUTF8</code> debe ser llamado
en un <code>CHARSXP</code>”]</h2>
<p>Este error (y otros similares, <em>p. ej.</em>,
“<code>getCharCE</code> debe ser llamado en un <code>CHARSXP</code>”)
puede no tener nada que ver con los datos de caracteres o la
configuración regional. En cambio, puede ser un síntoma de una
corrupción de memoria anterior. Hasta la fecha, estos errores se han
podido reproducir y solucionar (rápidamente). Por favor, repórtelo a
nuestro <a href="https://github.com/Rdatatable/data.table/issues">rastreador de
problemas</a>.</p>
</div>
<div id="cbinderror" class="section level2">
<h2><code>cbind(DT, DF)</code> devuelve un formato extraño,
<em>p. ej.</em> <code>Integer,5</code></h2>
<p>Esto ocurre antes de la v1.6.5, también para
<code>rbind(DT, DF)</code>. Actualice a la v1.6.7 o posterior.</p>
</div>
<div id="cannot-change-value-of-locked-binding-for-.sd-no-se-puede-cambiar-el-valor-del-enlace-bloqueado-para-.sd" class="section level2">
<h2>“cannot change value of locked binding for <code>.SD</code>” [“no se
puede cambiar el valor del enlace bloqueado para <code>.SD</code>”]</h2>
<p><code>.SD</code> está bloqueado por diseño. Consulte
<code>?data.table</code>. Si desea manipular <code>.SD</code> antes de
usarlo o devolverlo y no desea modificar <code>DT</code> utilizando
<code>:=</code>, primero haga una copia (consulte <code>?copy</code>),
<em>p. ej.</em>,</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">data.table</span>(<span class="at">a =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>), <span class="at">b =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">c =</span> <span class="dv">7</span><span class="sc">:</span><span class="dv">12</span>)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>DT</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="co">#        a     b     c</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a><span class="co"># 1:     1     1     7</span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a><span class="co"># 2:     2     2     8</span></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="co"># 3:     2     3     9</span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a><span class="co"># 4:     3     4    10</span></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a><span class="co"># 5:     3     5    11</span></span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a><span class="co"># 6:     3     6    12</span></span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a>DT[ , { mySD <span class="ot">=</span> <span class="fu">copy</span>(.SD)</span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a>      mySD[<span class="dv">1</span>, b <span class="sc">:=</span> <span class="dv">99</span><span class="dt">L</span>]</span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a>      mySD},</span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a>    by <span class="ot">=</span> a]</span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a><span class="co">#        a     b     c</span></span>
<span id="cb19-16"><a href="#cb19-16" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb19-17"><a href="#cb19-17" tabindex="-1"></a><span class="co"># 1:     1    99     7</span></span>
<span id="cb19-18"><a href="#cb19-18" tabindex="-1"></a><span class="co"># 2:     2    99     8</span></span>
<span id="cb19-19"><a href="#cb19-19" tabindex="-1"></a><span class="co"># 3:     2     3     9</span></span>
<span id="cb19-20"><a href="#cb19-20" tabindex="-1"></a><span class="co"># 4:     3    99    10</span></span>
<span id="cb19-21"><a href="#cb19-21" tabindex="-1"></a><span class="co"># 5:     3     5    11</span></span>
<span id="cb19-22"><a href="#cb19-22" tabindex="-1"></a><span class="co"># 6:     3     6    12</span></span></code></pre></div>
</div>
<div id="cannot-change-value-of-locked-binding-for-.n-no-se-puede-cambiar-el-valor-del-enlace-bloqueado-para-.n" class="section level2">
<h2>“cannot change value of locked binding for <code>.N</code>” [“no se
puede cambiar el valor del enlace bloqueado para <code>.N</code>”]</h2>
<p>Actualice a v1.8.1 o posterior. A partir de esta versión, si
<code>.N</code> es devuelto por <code>j</code>, se le cambia el nombre a
<code>N</code> para evitar cualquier ambigüedad en cualquier agrupación
posterior entre la variable especial <code>.N</code> y una columna
llamada <code>&quot;.N&quot;</code>.</p>
<p>El comportamiento anterior se puede reproducir forzando a
<code>.N</code> a llamarse <code>.N</code>, de esta manera:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">data.table</span>(<span class="at">a =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>), <span class="at">b =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>))</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>DT</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="co">#        a     b</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a><span class="co">#    &lt;num&gt; &lt;num&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a><span class="co"># 1:     1     1</span></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a><span class="co"># 2:     1     2</span></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a><span class="co"># 3:     2     2</span></span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a><span class="co"># 4:     2     2</span></span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a><span class="co"># 5:     2     1</span></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a>DT[ , <span class="fu">list</span>(<span class="at">.N =</span> .N), <span class="fu">list</span>(a, b)]   <span class="co"># show intermediate result for exposition</span></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a><span class="co">#        a     b    .N</span></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a><span class="co">#    &lt;num&gt; &lt;num&gt; &lt;int&gt;</span></span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a><span class="co"># 1:     1     1     1</span></span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a><span class="co"># 2:     1     2     1</span></span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a><span class="co"># 3:     2     2     2</span></span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a><span class="co"># 4:     2     1     1</span></span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a><span class="fu">cat</span>(<span class="fu">try</span>(</span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a>    DT[ , <span class="fu">list</span>(<span class="at">.N =</span> .N), <span class="at">by =</span> <span class="fu">list</span>(a, b)][ , <span class="fu">unique</span>(.N), <span class="at">by =</span> a]   <span class="co"># compound query more typical</span></span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a>, <span class="at">silent =</span> <span class="cn">TRUE</span>))</span>
<span id="cb20-20"><a href="#cb20-20" tabindex="-1"></a><span class="co"># Error in `[.data.table`(DT[, list(.N = .N), by = list(a, b)], , unique(.N),  : </span></span>
<span id="cb20-21"><a href="#cb20-21" tabindex="-1"></a><span class="co">#   La columna &#39;.N&#39; no se puede agrupar porque entra en conflicto con la variable especial .N. Pruebe setnames(DT,&#39;.N&#39;,&#39;N&#39;) primero.</span></span></code></pre></div>
<p>Si ya está ejecutando v1.8.1 o posterior, el mensaje de error ahora
es más útil que el error “no se puede cambiar el valor del enlace
bloqueado”, como puede ver arriba, ya que esta viñeta se generó
utilizando v1.8.1 o posterior.</p>
<p>La sintaxis más natural ahora funciona:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">packageVersion</span>(<span class="st">&quot;data.table&quot;</span>) <span class="sc">&gt;=</span> <span class="st">&quot;1.8.1&quot;</span>) {</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>    DT[ , .N, by <span class="ot">=</span> <span class="fu">list</span>(a, b)][ , <span class="fu">unique</span>(N), by <span class="ot">=</span> a]</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>  }</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="co">#        a    V1</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a><span class="co">#    &lt;num&gt; &lt;int&gt;</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a><span class="co"># 1:     1     1</span></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a><span class="co"># 2:     2     2</span></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a><span class="co"># 3:     2     1</span></span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">packageVersion</span>(<span class="st">&quot;data.table&quot;</span>) <span class="sc">&gt;=</span> <span class="st">&quot;1.9.3&quot;</span>) {</span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a>    DT[ , .N, by <span class="ot">=</span> .(a, b)][ , <span class="fu">unique</span>(N), by <span class="ot">=</span> a]   <span class="co"># same</span></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a>}</span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a><span class="co">#        a    V1</span></span>
<span id="cb21-13"><a href="#cb21-13" tabindex="-1"></a><span class="co">#    &lt;num&gt; &lt;int&gt;</span></span>
<span id="cb21-14"><a href="#cb21-14" tabindex="-1"></a><span class="co"># 1:     1     1</span></span>
<span id="cb21-15"><a href="#cb21-15" tabindex="-1"></a><span class="co"># 2:     2     2</span></span>
<span id="cb21-16"><a href="#cb21-16" tabindex="-1"></a><span class="co"># 3:     2     1</span></span></code></pre></div>
</div>
</div>
<div id="mensajes-de-advertencia" class="section level1">
<h1>Mensajes de advertencia</h1>
<div id="the-following-objects-are-masked-from-packagebase-cbind-rbind-los-siguientes-objetos-están-enmascarados-de-packagebase-cbind-rbind" class="section level2">
<h2>“The following object(s) are masked from <code>package:base</code>:
<code>cbind</code>, <code>rbind</code>” [“Los siguientes objetos están
enmascarados de <code>package:base</code>: <code>cbind</code>,
<code>rbind</code>”]</h2>
<p>Esta advertencia estaba presente solo en v1.6.5 y v.1.6.6, al cargar
el paquete. La motivación era permitir que <code>cbind(DT, DF)</code>
funcionara, pero como se vio, esto rompió la compatibilidad (total) con
el paquete <code>IRanges</code>. Actualice a v1.6.7 o posterior.</p>
</div>
<div id="coerced-numeric-rhs-to-integer-to-match-the-columns-type-conversión-forzada-del-rhs-numérico-a-entero-para-que-coincida-con-el-tipo-de-la-columna" class="section level2">
<h2>“Coerced numeric RHS to integer to match the column’s type”
[“Conversión forzada del RHS numérico a entero para que coincida con el
tipo de la columna”]</h2>
<p>Espero que esto se explique por sí solo. El mensaje completo es:</p>
<p>Conversión forzada del RHS numérico a entero para que coincida con el
tipo de la columna; puede tener precisión truncada. Cambie la columna a
numérica primero creando usted mismo un nuevo vector numérico de
longitud 5 (nfilas de la tabla completa) y asígnelo (es decir,
“reemplazar” la columna), o convierta usted mismo el RHS a entero (por
ejemplo, 1L o as.integer) para dejar clara su intención (y para mayor
velocidad). O bien, configure el tipo de columna correctamente desde el
principio cuando cree la tabla y manténgalo, por favor.</p>
<p>Para generarlo, intente:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">data.table</span>(<span class="at">a =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>, <span class="at">b =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="fu">suppressWarnings</span>(</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>DT[<span class="dv">2</span>, <span class="at">b :=</span> <span class="dv">6</span>]         <span class="co"># works (slower) with warning</span></span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>)</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a><span class="fu">class</span>(<span class="dv">6</span>)              <span class="co"># numeric not integer</span></span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a><span class="co"># [1] &quot;numeric&quot;</span></span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a>DT[<span class="dv">2</span>, b <span class="sc">:=</span> <span class="dv">7</span><span class="dt">L</span>]        <span class="co"># works (faster) without warning</span></span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a><span class="fu">class</span>(<span class="dv">7</span><span class="dt">L</span>)             <span class="co"># L makes it an integer</span></span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a><span class="co"># [1] &quot;integer&quot;</span></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>DT[ , b <span class="sc">:=</span> <span class="fu">rnorm</span>(<span class="dv">5</span>)]  <span class="co"># &#39;replace&#39; integer column with a numeric column</span></span></code></pre></div>
</div>
<div id="lectura-de-data.table-desde-un-archivo-rds-o-rdata" class="section level2">
<h2>Lectura de data.table desde un archivo RDS o RData</h2>
<p><code>*.RDS</code> y <code>*.RData</code> son tipos de archivo que
pueden almacenar objetos R en memoria en el disco de manera eficiente.
Sin embargo, almacenar data.table en el archivo binario pierde su
sobreasignación de columnas. Esto no es un gran problema: su data.table
se copiará en la memoria en la siguiente operación <em>por
referencia</em> y arrojará una advertencia. Por lo tanto, se recomienda
llamar a <code>setalloccol()</code> en cada data.table cargado con
llamadas <code>readRDS()</code> o <code>load()</code>.</p>
</div>
</div>
<div id="preguntas-generales-sobre-el-paquete" class="section level1">
<h1>Preguntas generales sobre el paquete</h1>
<div id="parece-que-la-v1.3-no-está-en-el-archivo-cran" class="section level2">
<h2>¿Parece que la v1.3 no está en el archivo CRAN?</h2>
<p>Eso es correcto. La v1.3 solo estaba disponible en R-Forge. Hubo
varios cambios importantes internamente y llevó algún tiempo probarlos
en el desarrollo.</p>
</div>
<div id="es-data.table-compatible-con-s-plus" class="section level2">
<h2>¿Es data.table compatible con S-plus?</h2>
<p>Actualmente no.</p>
<p>===== - Algunas partes principales del paquete están escritas en C y
usan funciones y estructuras R internas. - El paquete usa ámbito léxico,
que es una de las diferencias entre R y <strong>S-plus</strong>
explicado en <a href="https://cran.r-project.org/doc/FAQ/R-FAQ.html#Lexical-scoping">R
FAQ 3.3.1</a>=====</p>
</div>
<div id="está-disponible-para-linux-mac-y-windows" class="section level2">
<h2>¿Está disponible para Linux, Mac y Windows?</h2>
<p>Sí, tanto para 32 bits como para 64 bits en todas las plataformas.
Gracias a CRAN. No se utilizan bibliotecas especiales o específicas del
sistema operativo.</p>
</div>
<div id="creo-que-es-esto-genial.-qué-puedo-hacer" class="section level2">
<h2>Creo que es esto genial. ¿Qué puedo hacer?</h2>
<p>Envíe sugerencias, informes de errores y solicitudes de mejora en
nuestro <a href="https://github.com/Rdatatable/data.table/issues">seguimiento de
problemas</a>. Esto ayuda a mejorar el paquete.</p>
<p>Marque el paquete con una estrella en <a href="https://github.com/Rdatatable/data.table/wiki">GitHub</a>. Esto
ayuda a alentar a los desarrolladores y ayuda a otros usuarios de R a
encontrar el paquete.</p>
<p>Puede enviar solicitudes de incorporación de cambios para cambiar el
código o la documentación usted mismo; consulte nuestras <a href="https://github.com/Rdatatable/data.table/blob/master/.github/CONTRIBUTING.md">Pautas
de contribución</a>.</p>
</div>
<div id="creo-que-esto-no-es-genial.-cómo-advierto-a-otros-sobre-mi-experiencia" class="section level2">
<h2>Creo que esto no es genial. ¿Cómo advierto a otros sobre mi
experiencia?</h2>
<p>Agregamos todos los artículos que conocemos (ya sean positivos o
negativos) a la página <a href="https://github.com/Rdatatable/data.table/wiki/Articles">Artículos</a>.
Todas las páginas del wiki del proyecto en GitHub son de acceso abierto
sin restricciones de modificación. No dude en escribir un artículo,
vincular a uno negativo que haya escrito otra persona y que haya
encontrado, o agregar una nueva página a nuestro wiki para recopilar sus
críticas. Haga que sea constructivo para que tengamos la oportunidad de
mejorar.</p>
</div>
<div id="tengo-una-pregunta.-sé-que-la-guía-de-publicación-de-r-help-me-dice-que-me-comunique-con-el-mantenedor-no-con-r-help-pero-hay-un-grupo-más-grande-de-personas-a-las-que-pueda-preguntar" class="section level2">
<h2>Tengo una pregunta. Sé que la guía de publicación de r-help me dice
que me comunique con el mantenedor (no con r-help), pero ¿hay un grupo
más grande de personas a las que pueda preguntar?</h2>
<p>Consulte la <a href="https://github.com/Rdatatable/data.table/wiki/Support">guía de
soporte</a> en la página de inicio del proyecto, que contiene enlaces
actualizados.</p>
</div>
<div id="dónde-están-los-archivos-de-datatable-help" class="section level2">
<h2>¿Dónde están los archivos de datatable-help?</h2>
<p>La <a href="https://github.com/Rdatatable/data.table/wiki">página de
inicio</a> contiene enlaces a los archivos en varios formatos.</p>
</div>
<div id="preferiría-no-publicar-en-la-página-de-problemas-puedo-enviar-un-correo-electrónico-privado-a-una-o-dos-personas" class="section level2">
<h2>Preferiría no publicar en la página de Problemas, ¿puedo enviar un
correo electrónico privado a una o dos personas?</h2>
<p>Por supuesto. Sin embargo, es más probable que obtengas una respuesta
más rápida en la página de Problemas o en Stack Overflow. Además,
preguntar públicamente en esos lugares ayuda a construir la base de
conocimiento general.</p>
</div>
<div id="he-creado-un-paquete-que-utiliza-data.table.-cómo-puedo-asegurarme-de-que-mi-paquete-sea-compatible-con-data.table-para-que-funcione-la-herencia-de-data.frame" class="section level2">
<h2>He creado un paquete que utiliza data.table. ¿Cómo puedo asegurarme
de que mi paquete sea compatible con data.table para que funcione la
herencia de <code>data.frame</code>?</h2>
<p>Por favor, consulte <a href="https://stackoverflow.com/a/10529888/403310">esta
respuesta</a>.</p>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>Aquí nos referimos al <em>método</em> <code>merge</code>
para data.table o al método <code>merge</code> para
<code>data.frame</code> ya que ambos métodos funcionan de la misma
manera en este sentido. Vea <code>?merge.data.table</code> y <a href="#r-dispatch">a continuación</a> para obtener más información sobre
la resolución de métodos.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Puede resultar sorprendente saber que
<code>select top 10 * from ...</code> <em>no</em> devuelve de manera
confiable las mismas filas a lo largo del tiempo en SQL. Debe incluir
una cláusula <code>order by</code> o usar un índice agrupado para
garantizar el orden de las filas; <em>es decir</em>, SQL es
inherentemente desordenado.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p><em>por ejemplo</em>, <code>hist()</code> devuelve los
puntos de interrupción además de trazar en el dispositivo gráfico.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
