<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />


<meta name="date" content="2024-09-21" />

<title>Keys and fast binary search based subset</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Keys and fast binary search based
subset</h1>
<h4 class="date">2024-09-21</h4>



<p>Esta viñeta está dirigida a aquellos que ya están familiarizados con
la sintaxis de <em>data.table</em>, su forma general, cómo crear
subconjuntos de filas en <code>i</code>, seleccionar y calcular
columnas, agregar/modificar/eliminar columnas <em>por referencia</em> en
<code>j</code> y agrupar utilizando <code>by</code>. Si no está
familiarizado con estos conceptos, lea primero las viñetas
<em>“Introducción a data.table”</em> y <em>“Semántica de
referencia”</em>.</p>
<hr />
<div id="data" class="section level2">
<h2>Datos</h2>
<p>Utilizaremos los mismos datos de <code>flights</code> que en la
viñeta <em>“Introducción a data.table”</em>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>flights <span class="ot">&lt;-</span> <span class="fu">fread</span>(<span class="st">&quot;flights14.csv&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">head</span>(flights)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">#     year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="co"># 1:  2014     1     1        14        13      AA    JFK    LAX      359     2475     9</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co"># 2:  2014     1     1        -3        13      AA    JFK    LAX      363     2475    11</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co"># 3:  2014     1     1         2         9      AA    JFK    LAX      351     2475    19</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="co"># 4:  2014     1     1        -8       -26      AA    LGA    PBI      157     1035     7</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co"># 5:  2014     1     1         2         1      AA    JFK    LAX      350     2475    13</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co"># 6:  2014     1     1         4         0      AA    EWR    LAX      339     2454    18</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="fu">dim</span>(flights)</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co"># [1] 253316     11</span></span></code></pre></div>
</div>
<div id="introducción" class="section level2">
<h2>Introducción</h2>
<p>En esta viñeta, vamos a</p>
<p>=====* primero, introducir el concepto de <code>key</code> en
<em>data.table</em>, y establecer y usar claves para realizar
<em>búsquedas binarias rápidas</em> basadas en subconjuntos en
<code>i</code>,=====</p>
<p>=====* observar que podemos combinar subconjuntos basados en clave
junto con <code>j</code> y <code>by</code> exactamente de la misma
manera que antes,=====</p>
<ul>
<li>mirar otros argumentos útiles adicionales - <code>mult</code> y
<code>nomatch</code>,</li>
</ul>
<p>=====* y finalmente concluir observando las ventajas de establecer
claves - realizar <em>búsquedas binarias rápidas basadas en
subconjuntos</em> y compararlas con el enfoque de escaneo vectorial
tradicional.=====</p>
</div>
<div id="claves" class="section level2">
<h2>1. Claves</h2>
<div id="a-qué-es-una-clave" class="section level3">
<h3>a) ¿Qué es una <em>clave</em>?</h3>
<p>En la viñeta <em>“Introducción a data.table”</em>, vimos cómo crear
subconjuntos de filas en <code>i</code> utilizando expresiones lógicas,
números de fila y el uso de <code>order()</code>. En esta sección,
veremos otra forma de seleccionar subconjuntos de manera increíblemente
rápida - utilizando <em>claves</em>.</p>
<p>Pero primero, comencemos por analizar los <em>data.frames</em>. Todos
los <em>data.frames</em> tienen un atributo de nombre de fila. Considere
el <em>data.frame</em> <code>DF</code> a continuación.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span><span class="dt">L</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>DF <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">ID1 =</span> <span class="fu">sample</span>(letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>], <span class="dv">10</span>, <span class="cn">TRUE</span>),</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>                <span class="at">ID2 =</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">10</span>, <span class="cn">TRUE</span>),</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>                <span class="at">val =</span> <span class="fu">sample</span>(<span class="dv">10</span>),</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>                <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span>,</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>                <span class="at">row.names =</span> <span class="fu">sample</span>(LETTERS[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]))</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>DF</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co">#   ID1 ID2 val</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co"># I   a   1  10</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co"># D   a   3   9</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="co"># G   a   1   4</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="co"># A   a   1   7</span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a><span class="co"># B   a   1   1</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="co"># E   b   1   8</span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="co"># C   b   2   3</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a><span class="co"># J   b   1   2</span></span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a><span class="co"># F   b   1   5</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a><span class="co"># H   a   2   6</span></span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a><span class="fu">rownames</span>(DF)</span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a><span class="co">#  [1] &quot;I&quot; &quot;D&quot; &quot;G&quot; &quot;A&quot; &quot;B&quot; &quot;E&quot; &quot;C&quot; &quot;J&quot; &quot;F&quot; &quot;H&quot;</span></span></code></pre></div>
<p>Podemos crear un <em>subconjunto</em> de una fila particular usando
su nombre de fila como se muestra a continuación:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>DF[<span class="st">&quot;C&quot;</span>, ]</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="co">#   ID1 ID2 val</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co"># C   b   2   3</span></span></code></pre></div>
<p>Es decir, los nombres de fila son más o menos <em>un índice</em> de
las filas de un <em>data.frame</em>. Sin embargo,</p>
<ol style="list-style-type: decimal">
<li><p>Cada fila está limitada a <em>exactamente un</em> nombre de
fila.</p>
<p>But, a person (for example) has at least two names - a <em>first</em>
and a <em>second</em> name. It is useful to organise a telephone
directory by <em>surname</em> then <em>first name</em>.</p></li>
<li><p>Y los nombres de las filas deben ser <em>únicos</em>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">rownames</span>(DF) <span class="ot">=</span> <span class="fu">sample</span>(LETTERS[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>], <span class="dv">10</span>, <span class="cn">TRUE</span>)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="co"># Warning: non-unique values when setting &#39;row.names&#39;: &#39;C&#39;, &#39;D&#39;</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># Error in `.rowNamesDF&lt;-`(x, value = value): duplicate &#39;row.names&#39; are not allowed</span></span></code></pre></div></li>
</ol>
<p>Ahora vamos a convertirlo en una <em>data.table</em>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">as.data.table</span>(DF)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>DT</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co">#        ID1   ID2   val</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">#     &lt;char&gt; &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#  1:      a     1    10</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#  2:      a     3     9</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#  3:      a     1     4</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#  4:      a     1     7</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#  5:      a     1     1</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">#  6:      b     1     8</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="co">#  7:      b     2     3</span></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="co">#  8:      b     1     2</span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a><span class="co">#  9:      b     1     5</span></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a><span class="co"># 10:      a     2     6</span></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a><span class="fu">rownames</span>(DT)</span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a><span class="co">#  [1] &quot;1&quot;  &quot;2&quot;  &quot;3&quot;  &quot;4&quot;  &quot;5&quot;  &quot;6&quot;  &quot;7&quot;  &quot;8&quot;  &quot;9&quot;  &quot;10&quot;</span></span></code></pre></div>
<ul>
<li>Tenga en cuenta que los nombres de las filas se han
restablecido.</li>
</ul>
<p>=====* <em>data.tables</em> nunca utiliza nombres de fila. Dado que
las <em>data.tables</em> <strong>heredan</strong> de
<em>data.frames</em>, mantienen el atributo de nombres de fila, pero
nunca se utiliza. En un momento veremos el porqué.=====</p>
<pre><code>If you would like to preserve the row names, use `keep.rownames = TRUE` in `as.data.table()` - this will create a new column called `rn` and assign row names to this column.</code></pre>
<p>En cambio, en <em>data.tables</em>, establecemos y usamos
<code>keys</code> (claves). Piense en una <code>key</code> como si fuera
un conjunto de <strong>nombres de fila recargados</strong>.</p>
<div id="key-properties" class="section level4">
<h4>Claves y sus propiedades</h4>
<p>=====1. Podemos establecer claves en <em>varias columnas</em> y la
columna puede ser de <em>diferentes tipos</em> – <em>integer</em>,
<em>numeric</em>, <em>character</em>, <em>factor</em>,
<em>integer64</em>, etc. Los tipos <em>list</em> y <em>complex</em> aún
no son compatibles.=====</p>
<p>=====2. No se exigen valores únicos, es decir, se permiten valores de
clave duplicados. Dado que las filas se ordenan por clave, los
duplicados en las columnas de clave aparecerán de forma
consecutiva.=====</p>
<ol start="3" style="list-style-type: decimal">
<li><p>Establecer una <code>key</code> hace <em>dos</em> cosas:</p>
<ol style="list-style-type: lower-alpha">
<li><p>physically reorders the rows of the <em>data.table</em> by the
column(s) provided <em>by reference</em>, always in <em>increasing</em>
order.</p></li>
<li><p>marks those columns as <em>key</em> columns by setting an
attribute called <code>sorted</code> to the
<em>data.table</em>.</p></li>
</ol>
<p>Since the rows are reordered, a <em>data.table</em> can have at most
one key because it can not be sorted in more than one way.</p></li>
</ol>
<p>Para el resto de la viñeta, trabajaremos con el conjunto de datos
<code>flights</code>.</p>
</div>
</div>
<div id="b-establecer-obtener-y-utilizar-claves-en-una-data.table" class="section level3">
<h3>b) Establecer, obtener y utilizar claves en una
<em>data.table</em></h3>
<div id="cómo-podemos-establecer-la-columna-origin-como-clave-en-la-data.table-flights" class="section level4">
<h4>– ¿Cómo podemos establecer la columna <code>origin</code> como clave
en la <em>data.table</em> <code>flights</code>?</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">setkey</span>(flights, origin)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="fu">head</span>(flights)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co"># Key: &lt;origin&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">#     year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co"># 1:  2014     1     1         4         0      AA    EWR    LAX      339     2454    18</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co"># 2:  2014     1     1        -5       -17      AA    EWR    MIA      161     1085    16</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co"># 3:  2014     1     1       191       185      AA    EWR    DFW      214     1372    16</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co"># 4:  2014     1     1        -1        -2      AA    EWR    DFW      214     1372    14</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co"># 5:  2014     1     1        -3       -10      AA    EWR    MIA      154     1085     6</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co"># 6:  2014     1     1         4       -17      AA    EWR    DFW      215     1372     9</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="do">## alternatively we can provide character vectors to the function &#39;setkeyv()&#39;</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a><span class="co"># setkeyv(flights, &quot;origin&quot;) # useful to program with</span></span></code></pre></div>
<p>=====* Puede utilizar la función <code>setkey()</code> y proporcionar
los nombres de las columnas (sin comillas). Esto resulta útil durante el
uso interactivo.=====</p>
<p>=====* Alternativamente, puede suministrar un vector de caracteres de
nombres de columnas a la función <code>setkeyv()</code>. Esto es
particularmente útil al diseñar funciones para pasar columnas a las que
se les asignará una clave como argumentos de función.=====</p>
<p>=====* Tenga en cuenta que no tuvimos que asignar el resultado a una
variable. Esto se debe a que, al igual que la función <code>:=</code>
que vimos en la viñeta <em>“Semántica de referencia”</em>,
<code>setkey()</code> y <code>setkeyv()</code> modifican la entrada
<em>data.table</em> <em>por referencia</em>. Devuelven el resultado de
forma invisible.=====</p>
<p>=====* La <em>data.table</em> ahora está reordenada por la columna
que proporcionamos - <code>origin</code>. Como reordenamos por
referencia, solo necesitamos memoria adicional de una columna de
longitud igual a la cantidad de filas en la <em>data.table</em> y, por
lo tanto, es muy eficiente en el uso de la memoria.=====</p>
<p>=====* También puede establecer claves directamente al crear
<em>data.tables</em> utilizando la función <code>data.table()</code> con
el argumento <code>key</code>, que acepta un vector de caracteres de
nombres de columnas.=====</p>
</div>
<div id="set-y" class="section level4">
<h4>set* y <code>:=</code>:</h4>
<p>En <em>data.table</em>, el operador <code>:=</code> y todas las
funciones <code>set*</code> (por ejemplo, <code>setkey</code>,
<code>setorder</code>, <code>setnames</code> etc.) son las únicas que
modifican el objeto de entrada <em>por referencia</em>.</p>
<p>Una vez que se <em>indexa</em> una <em>data.table</em> por
determinadas columnas, se puede crear un subconjunto consultando esas
columnas clave utilizando la notación <code>.()</code> en
<code>i</code>. Recuerde que <code>.()</code> es un <em>alias</em> de
<code>list()</code>.</p>
</div>
<div id="utilice-la-columna-clave-origin-para-crear-un-subconjunto-de-todas-las-filas-donde-el-aeropuerto-de-origen-coincida-con-jfk" class="section level4">
<h4>– Utilice la columna clave <code>origin</code> para crear un
subconjunto de todas las filas donde el aeropuerto de origen coincida
con <em>“JFK”</em></h4>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>flights[.(<span class="st">&quot;JFK&quot;</span>)]</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co"># Key: &lt;origin&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co">#         year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#        &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co">#     1:  2014     1     1        14        13      AA    JFK    LAX      359     2475     9</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="co">#     2:  2014     1     1        -3        13      AA    JFK    LAX      363     2475    11</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co">#     3:  2014     1     1         2         9      AA    JFK    LAX      351     2475    19</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co">#     4:  2014     1     1         2         1      AA    JFK    LAX      350     2475    13</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="co">#     5:  2014     1     1        -2       -18      AA    JFK    LAX      338     2475    21</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a><span class="co">#    ---                                                                                    </span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="co"># 81479:  2014    10    31        -4       -21      UA    JFK    SFO      337     2586    17</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="co"># 81480:  2014    10    31        -2       -37      UA    JFK    SFO      344     2586    18</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="co"># 81481:  2014    10    31         0       -33      UA    JFK    LAX      320     2475    17</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a><span class="co"># 81482:  2014    10    31        -6       -38      UA    JFK    SFO      343     2586     9</span></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a><span class="co"># 81483:  2014    10    31        -6       -38      UA    JFK    LAX      323     2475    11</span></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a><span class="do">## alternatively</span></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a><span class="co"># flights[J(&quot;JFK&quot;)] (or)</span></span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a><span class="co"># flights[list(&quot;JFK&quot;)]</span></span></code></pre></div>
<p>=====* La columna de <em>clave</em> ya se ha establecido en
<code>origin</code>. Por lo tanto, es suficiente proporcionar el valor,
en este caso <em>“JFK”</em>, directamente. La sintaxis <code>.()</code>
ayuda a identificar que la tarea requiere buscar el valor <em>“JFK”</em>
en la columna de clave de <em>data.table</em> (aquí, la columna
<code>origin</code> de <em>data.table</em>
<code>flights</code>).=====</p>
<p>=====* Primero se obtienen los <em>índices de fila</em>
correspondientes al valor <em>“JFK”</em> en <code>origin</code>. Y como
no hay expresión en <code>j</code>, se devuelven todas las columnas
correspondientes a esos índices de fila.=====</p>
<p>=====* En una clave de columna única de tipo <em>carácter</em>, puede
eliminar la notación <code>.()</code> y usar los valores directamente al
crear subconjuntos, como un subconjunto que usa nombres de fila en
<em>data.frames</em>.=====</p>
<pre><code>``` r
flights[&quot;JFK&quot;]              ## same as flights[.(&quot;JFK&quot;)]
```</code></pre>
<p>=====* Podemos crear subconjuntos de cualquier cantidad de valores
según sea necesario=====</p>
<pre><code>``` r
flights[c(&quot;JFK&quot;, &quot;LGA&quot;)]    ## same as flights[.(c(&quot;JFK&quot;, &quot;LGA&quot;))]
```

This returns all columns corresponding to those rows where `origin` column matches either *&quot;JFK&quot;* or *&quot;LGA&quot;*.</code></pre>
</div>
<div id="cómo-podemos-obtener-las-columnas-por-las-que-se-codifica-una-data.table" class="section level4">
<h4>– ¿Cómo podemos obtener las columnas por las que se codifica una
<em>data.table</em>?</h4>
<p>Usando la función <code>key()</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">key</span>(flights)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="co"># [1] &quot;origin&quot;</span></span></code></pre></div>
<ul>
<li><p>Devuelve un vector de caracteres de todas las columnas
clave.</p></li>
<li><p>Si no se establece ninguna clave, devuelve
<code>NULL</code>.</p></li>
</ul>
</div>
</div>
<div id="c-claves-y-columnas-múltiples" class="section level3">
<h3>c) Claves y columnas múltiples</h3>
<p>Para refrescar, las <em>claves</em> son como nombres de fila
<em>supercargados</em>. Podemos establecer claves en varias columnas y
pueden ser de varios tipos.</p>
<div id="cómo-puedo-configurar-claves-en-las-columnas-origin-y-dest" class="section level4">
<h4>– ¿Cómo puedo configurar claves en las columnas <code>origin</code>
<em>y</em> <code>dest</code>?</h4>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">setkey</span>(flights, origin, dest)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="fu">head</span>(flights)</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co"># Key: &lt;origin, dest&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">#     year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co"># 1:  2014     1     2        -2       -25      EV    EWR    ALB       30      143     7</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="co"># 2:  2014     1     3        88        79      EV    EWR    ALB       29      143    23</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co"># 3:  2014     1     4       220       211      EV    EWR    ALB       32      143    15</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a><span class="co"># 4:  2014     1     4        35        19      EV    EWR    ALB       32      143     7</span></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a><span class="co"># 5:  2014     1     5        47        42      EV    EWR    ALB       26      143     8</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a><span class="co"># 6:  2014     1     5        66        62      EV    EWR    ALB       31      143    23</span></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a><span class="do">## or alternatively</span></span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a><span class="co"># setkeyv(flights, c(&quot;origin&quot;, &quot;dest&quot;)) # provide a character vector of column names</span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a><span class="fu">key</span>(flights)</span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a><span class="co"># [1] &quot;origin&quot; &quot;dest&quot;</span></span></code></pre></div>
<p>=====* Esto ordena la <em>data.table</em> primero por la columna
<code>origin</code> y luego por <code>dest</code> <em>por
referencia</em>.=====</p>
</div>
<div id="seleccionar-un-subconjunto-de-todas-las-filas-utilizando-columnas-clave-donde-la-primera-columna-clave-origin-coincide-con-jfk-y-la-segunda-columna-clave-dest-coincide-con-mia" class="section level4">
<h4>– Seleccionar un subconjunto de todas las filas utilizando columnas
clave donde la primera columna clave <code>origin</code> coincide con
<em>“JFK”</em> y la segunda columna clave <code>dest</code> coincide con
<em>“MIA”</em></h4>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>flights[.(<span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;MIA&quot;</span>)]</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="co"># Key: &lt;origin, dest&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co">#        year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co">#       &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co">#    1:  2014     1     1        -1       -17      AA    JFK    MIA      161     1089    15</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a><span class="co">#    2:  2014     1     1         7        -8      AA    JFK    MIA      166     1089     9</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co">#    3:  2014     1     1         2        -1      AA    JFK    MIA      164     1089    12</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a><span class="co">#    4:  2014     1     1         6         3      AA    JFK    MIA      157     1089     5</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="co">#    5:  2014     1     1         6       -12      AA    JFK    MIA      154     1089    17</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co">#   ---                                                                                    </span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a><span class="co"># 2746:  2014    10    31        -1       -22      AA    JFK    MIA      148     1089    16</span></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a><span class="co"># 2747:  2014    10    31        -3       -20      AA    JFK    MIA      146     1089     8</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="co"># 2748:  2014    10    31         2       -17      AA    JFK    MIA      150     1089     6</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a><span class="co"># 2749:  2014    10    31        -3       -12      AA    JFK    MIA      150     1089     5</span></span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a><span class="co"># 2750:  2014    10    31        29         4      AA    JFK    MIA      146     1089    19</span></span></code></pre></div>
</div>
<div id="multiple-key-point" class="section level4">
<h4>¿Cómo funciona seleccionar un subconjunto aquí?</h4>
<p>=====* Es importante entender cómo funciona esto internamente.
<em>“JFK”</em> primero se compara con la primera columna de clave
<code>origin</code>. Y <em>dentro de esas filas coincidentes</em>,
<em>“MIA”</em> se compara con la segunda columna de clave
<code>dest</code> para obtener <em>índices de fila</em> donde tanto
<code>origin</code> como <code>dest</code> coinciden con los valores
dados.=====</p>
<p>=====* Dado que no se proporciona ninguna <code>j</code>, simplemente
devolvemos <em>todas las columnas</em> correspondientes a esos índices
de fila.=====</p>
</div>
<div id="seleccionar-el-subconjunto-de-todas-las-filas-donde-solo-la-primera-columna-de-clave-origin-coincide-con-jfk" class="section level4">
<h4>– Seleccionar el subconjunto de todas las filas donde solo la
primera columna de clave <code>origin</code> coincide con
<em>“JFK”</em></h4>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">key</span>(flights)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="co"># [1] &quot;origin&quot; &quot;dest&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>flights[.(<span class="st">&quot;JFK&quot;</span>)] <span class="do">## or in this case simply flights[&quot;JFK&quot;], for convenience</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="co"># Key: &lt;origin, dest&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="co">#         year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="co">#        &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a><span class="co">#     1:  2014     1     1        10         4      B6    JFK    ABQ      280     1826    20</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a><span class="co">#     2:  2014     1     2       134       161      B6    JFK    ABQ      252     1826    22</span></span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a><span class="co">#     3:  2014     1     7         6         6      B6    JFK    ABQ      269     1826    20</span></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a><span class="co">#     4:  2014     1     8        15       -15      B6    JFK    ABQ      259     1826    20</span></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a><span class="co">#     5:  2014     1     9        45        32      B6    JFK    ABQ      267     1826    20</span></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a><span class="co">#    ---                                                                                    </span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a><span class="co"># 81479:  2014    10    31         0       -18      DL    JFK    TPA      142     1005     8</span></span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a><span class="co"># 81480:  2014    10    31         1        -8      B6    JFK    TPA      149     1005    19</span></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a><span class="co"># 81481:  2014    10    31        -2       -22      B6    JFK    TPA      145     1005    14</span></span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a><span class="co"># 81482:  2014    10    31        -8        -5      B6    JFK    TPA      149     1005     9</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a><span class="co"># 81483:  2014    10    31        -4       -18      B6    JFK    TPA      145     1005     8</span></span></code></pre></div>
<p>=====* Dado que no proporcionamos ningún valor para la segunda
columna clave <code>dest</code>, simplemente compara <em>“JFK”</em> con
la primera columna clave <code>origin</code> y devuelve todas las filas
coincidentes.=====</p>
</div>
<div id="seleccionar-el-subconjunto-de-todas-las-filas-donde-solo-la-segunda-columna-clave-dest-coincide-con-mia" class="section level4">
<h4>– Seleccionar el subconjunto de todas las filas donde solo la
segunda columna clave <code>dest</code> coincide con <em>“MIA”</em></h4>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>flights[.(<span class="fu">unique</span>(origin), <span class="st">&quot;MIA&quot;</span>)]</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="co"># Key: &lt;origin, dest&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="co">#        year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">#       &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co">#    1:  2014     1     1        -5       -17      AA    EWR    MIA      161     1085    16</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co">#    2:  2014     1     1        -3       -10      AA    EWR    MIA      154     1085     6</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co">#    3:  2014     1     1        -5        -8      AA    EWR    MIA      157     1085    11</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="co">#    4:  2014     1     1        43        42      UA    EWR    MIA      155     1085    15</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co">#    5:  2014     1     1        60        49      UA    EWR    MIA      162     1085    21</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="co">#   ---                                                                                    </span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a><span class="co"># 9924:  2014    10    31       -11        -8      AA    LGA    MIA      157     1096    13</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="co"># 9925:  2014    10    31        -5       -11      AA    LGA    MIA      150     1096     9</span></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a><span class="co"># 9926:  2014    10    31        -2        10      AA    LGA    MIA      156     1096     6</span></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a><span class="co"># 9927:  2014    10    31        -2       -16      AA    LGA    MIA      156     1096    19</span></span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a><span class="co"># 9928:  2014    10    31         1       -11      US    LGA    MIA      164     1096    15</span></span></code></pre></div>
</div>
<div id="que-está-pasando-aquí" class="section level4">
<h4>¿Que está pasando aquí?</h4>
<p>=====* Lea <a href="#multiple-key-point">esto</a> nuevamente. El
valor provisto para la segunda columna de clave <em>“MIA”</em> tiene que
encontrar los valores coincidentes en la columna de clave
<code>dest</code> <em>en las filas coincidentes provistas por la primera
columna de clave <code>origin</code></em>. No podemos omitir los valores
de las columnas de clave <em>anteriores</em>. Por lo tanto,
proporcionamos <em>todos</em> los valores únicos de la columna de clave
<code>origin</code>.=====</p>
<p>=====* <em>“MIA”</em> se recicla automáticamente para ajustarse a la
longitud de <code>unique(origin)</code> que es <em>3</em>.=====</p>
</div>
</div>
</div>
<div id="combinando-claves-con-j-y-by" class="section level2">
<h2>2. Combinando claves con <code>j</code> y <code>by</code></h2>
<p>Hasta ahora, todo lo que hemos visto es el mismo concepto – obtener
<em>índices de fila</em> en <code>i</code>, pero utilizando un método
diferente – utilizando claves. No debería sorprender que podamos hacer
exactamente lo mismo en <code>j</code> y <code>by</code>, como se vio en
los ejemplos anteriores. Lo destacaremos con algunos ejemplos.</p>
<div id="a-seleccionar-en-j" class="section level3">
<h3>a) Seleccionar en <code>j</code></h3>
<div id="devuelve-la-columna-arr_delay-como-una-data.table-correspondiente-a-origin-lga-y-dest-tpa." class="section level4">
<h4>– Devuelve la columna <code>arr_delay</code> como una
<em>data.table</em> correspondiente a <code>origin = &quot;LGA&quot;</code> y
<code>dest = &quot;TPA&quot;</code>.</h4>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">key</span>(flights)</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="co"># [1] &quot;origin&quot; &quot;dest&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), .(arr_delay)]</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="co">#       arr_delay</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="co">#           &lt;int&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">#    1:         1</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="co">#    2:        14</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co">#    3:       -17</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="co">#    4:        -4</span></span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a><span class="co">#    5:       -12</span></span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a><span class="co">#   ---          </span></span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a><span class="co"># 1848:        39</span></span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a><span class="co"># 1849:       -24</span></span>
<span id="cb16-14"><a href="#cb16-14" tabindex="-1"></a><span class="co"># 1850:       -12</span></span>
<span id="cb16-15"><a href="#cb16-15" tabindex="-1"></a><span class="co"># 1851:        21</span></span>
<span id="cb16-16"><a href="#cb16-16" tabindex="-1"></a><span class="co"># 1852:       -11</span></span></code></pre></div>
<p>=====* Los <em>índices de fila</em> correspondientes a
<code>origin == &quot;LGA&quot;</code> y <code>dest == &quot;TPA&quot;</code> se obtienen
utilizando un <em>subconjunto basado en clave</em>.=====</p>
<p>=====* Una vez que tenemos los índices de fila, observamos
<code>j</code>, que requiere solo la columna <code>arr_delay</code>. Por
lo tanto, simplemente seleccionamos la columna <code>arr_delay</code>
para esos <em>índices de fila</em> de la misma manera que hemos visto en
la viñeta <em>Introducción a data.table</em>.=====</p>
<ul>
<li><p>Podríamos haber devuelto el resultado usando
<code>with = FALSE</code> también.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), <span class="st">&quot;arr_delay&quot;</span>, with <span class="ot">=</span> <span class="cn">FALSE</span>]</span></code></pre></div></li>
</ul>
</div>
</div>
<div id="b-encadenamiento" class="section level3">
<h3>b) Encadenamiento</h3>
<div id="sobre-el-resultado-obtenido-anteriormente-utilice-el-encadenamiento-para-ordenar-la-columna-en-orden-decreciente." class="section level4">
<h4>– Sobre el resultado obtenido anteriormente, utilice el
encadenamiento para ordenar la columna en orden decreciente.</h4>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), .(arr_delay)][<span class="fu">order</span>(<span class="sc">-</span>arr_delay)]</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="co">#       arr_delay</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="co">#           &lt;int&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="co">#    1:       486</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="co">#    2:       380</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="co">#    3:       351</span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="co">#    4:       318</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co">#    5:       300</span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="co">#   ---          </span></span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a><span class="co"># 1848:       -40</span></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="co"># 1849:       -43</span></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a><span class="co"># 1850:       -46</span></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a><span class="co"># 1851:       -48</span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a><span class="co"># 1852:       -49</span></span></code></pre></div>
</div>
</div>
<div id="c-calcular-o-hacer-en-j" class="section level3">
<h3>c) Calcular o <em>hacer</em> en <code>j</code></h3>
<div id="encuentra-el-retraso-máximo-de-llegada-correspondiente-a-origin-lga-y-dest-tpa." class="section level4">
<h4>– Encuentra el retraso máximo de llegada correspondiente a
<code>origin = &quot;LGA&quot;</code> y <code>dest = &quot;TPA&quot;</code>.</h4>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), <span class="fu">max</span>(arr_delay)]</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="co"># [1] 486</span></span></code></pre></div>
<p>=====*Podemos verificar que el resultado es idéntico al primer valor
(486) del ejemplo anterior.=====</p>
</div>
</div>
<div id="d-sub-asignar-por-referencia-usando-en-j" class="section level3">
<h3>d) <em>sub-asignar</em> por referencia usando <code>:=</code> en
<code>j</code></h3>
<p>Ya hemos visto este ejemplo en la viñeta <em>Semántica de
referencia</em>. Echemos un vistazo a todas las <code>hours</code>
disponibles en la <em>data.table</em> <code>flights</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="co"># get all &#39;hours&#39; in flights</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>flights[, <span class="fu">sort</span>(<span class="fu">unique</span>(hour))]</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="co">#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</span></span></code></pre></div>
<p>Vemos que hay un total de <code>25</code> valores únicos en los
datos. Parece que están presentes tanto la hora <code>0</code> como la
hora <code>24</code>. Reemplacemos <code>24</code> por <code>0</code>,
pero esta vez usando la <em>clave</em>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="fu">setkey</span>(flights, hour)</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="fu">key</span>(flights)</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a><span class="co"># [1] &quot;hour&quot;</span></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>flights[.(<span class="dv">24</span>), hour <span class="sc">:=</span> <span class="dv">0</span><span class="dt">L</span>]</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a><span class="fu">key</span>(flights)</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a><span class="co"># NULL</span></span></code></pre></div>
<p>=====* Primero establecemos la clave en <code>hour</code>. Esto
reordena <code>flights</code> por la columna <code>hour</code> y marca
esa columna como la columna de <em>clave</em>
(<code>key()</code>).=====</p>
<p>=====* Ahora podemos obtener un subconjunto de <code>hour</code>
usando la notación <code>.()</code>. Seleccionamos el subconjunto para
el valor <em>24</em> y obtenemos los <em>índices de fila</em>
correspondientes.=====</p>
<p>=====* Y en esos índices de fila, reemplazamos la columna de
<em>clave</em> con el valor <code>0</code>.=====</p>
<p>=====* Dado que hemos reemplazado los valores en la columna de
<em>clave</em>, la <em>data.table</em> <code>flights</code> ya no está
ordenada por <code>hour</code>. Por lo tanto, la clave se ha eliminado
automáticamente, estableciéndose en NULL.=====</p>
<p>Ahora, no debería haber ningún <code>24</code> en la columna
<code>hour</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>flights[, <span class="fu">sort</span>(<span class="fu">unique</span>(hour))]</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="co">#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23</span></span></code></pre></div>
</div>
<div id="e-agregación-utilizando-by" class="section level3">
<h3>e) Agregación utilizando <code>by</code></h3>
<p>Primero, establezcamos nuevamente la clave en
<code>origin, dest</code>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="fu">setkey</span>(flights, origin, dest)</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a><span class="fu">key</span>(flights)</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="co"># [1] &quot;origin&quot; &quot;dest&quot;</span></span></code></pre></div>
<div id="obtener-el-retraso-máximo-de-salida-para-cada-mes-month-correspondiente-a-origin-jfk.-ordenar-el-resultado-por-month" class="section level4">
<h4>– Obtener el retraso máximo de salida para cada mes
(<code>month</code>) correspondiente a <code>origin = &quot;JFK&quot;</code>.
Ordenar el resultado por <code>month</code></h4>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>ans <span class="ot">&lt;-</span> flights[<span class="st">&quot;JFK&quot;</span>, <span class="fu">max</span>(dep_delay), keyby <span class="ot">=</span> month]</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="fu">head</span>(ans)</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a><span class="co"># Key: &lt;month&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a><span class="co">#    month    V1</span></span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a><span class="co"># 1:     1   881</span></span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a><span class="co"># 2:     2  1014</span></span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a><span class="co"># 3:     3   920</span></span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a><span class="co"># 4:     4  1241</span></span>
<span id="cb24-10"><a href="#cb24-10" tabindex="-1"></a><span class="co"># 5:     5   853</span></span>
<span id="cb24-11"><a href="#cb24-11" tabindex="-1"></a><span class="co"># 6:     6   798</span></span>
<span id="cb24-12"><a href="#cb24-12" tabindex="-1"></a><span class="fu">key</span>(ans)</span>
<span id="cb24-13"><a href="#cb24-13" tabindex="-1"></a><span class="co"># [1] &quot;month&quot;</span></span></code></pre></div>
<p>=====* Seleccionamos un subconjunto sobre la columna de clave
<code>origin</code> para obtener los <em>índices de fila</em>
correspondientes a <em>“JFK”</em>.=====</p>
<p>=====* Una vez que obtenemos los índices de fila, solo necesitamos
dos columnas - <code>month</code> para agrupar y <code>dep_delay</code>
para obtener el <code>max()</code> para cada grupo. Por lo tanto, la
optimización de consultas de <em>data.table</em> selecciona solo el
subconjunto de aquellas dos columnas correspondientes a los <em>índices
de fila</em> obtenidos en <code>i</code>, para mayor velocidad y
eficiencia de memoria.=====</p>
<p>=====* Y en ese subconjunto, agrupamos por <code>month</code> y
calculamos <code>max(dep_delay)</code>.=====</p>
<p>=====* Usamos <code>keyby</code> para clasificar automáticamente ese
resultado por <code>month</code>. Ahora entendemos lo que eso significa.
Además de ordenar, también establece <code>month</code> como la columna
de <em>clave</em>.=====</p>
</div>
</div>
</div>
<div id="argumentos-adicionales---mult-y-nomatch" class="section level2">
<h2>3. Argumentos adicionales - <code>mult</code> y
<code>nomatch</code></h2>
<div id="a-el-argumento-mult" class="section level3">
<h3>a) El argumento <em>mult</em></h3>
<p>Podemos elegir, para cada consulta, si se deben devolver <em>todas
(“all”)</em> las filas coincidentes, o solo la <em>primera
(“first”)</em> o la <em>última (“last”)</em> utilizando el argumento
<code>mult</code>. El valor predeterminado es <em>“all”</em>, que es lo
que hemos visto hasta ahora.</p>
<div id="seleccionar-el-subconjunto-solo-de-la-primera-fila-coincidente-de-todas-las-filas-donde-origin-coincide-con-jfk-y-dest-coincide-con-mia" class="section level4">
<h4>– Seleccionar el subconjunto solo de la primera fila coincidente de
todas las filas donde <code>origin</code> coincide con <em>“JFK”</em> y
<code>dest</code> coincide con <em>“MIA”</em></h4>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>flights[.(<span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;MIA&quot;</span>), mult <span class="ot">=</span> <span class="st">&quot;first&quot;</span>]</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="co"># Key: &lt;origin, dest&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="co">#     year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a><span class="co"># 1:  2014     1     1         6         3      AA    JFK    MIA      157     1089     5</span></span></code></pre></div>
</div>
<div id="seleccionar-el-subconjunto-solo-de-la-última-fila-coincidente-de-todas-las-filas-donde-origin-coincide-con-lga-jfk-ewr-y-dest-coincide-con-xna" class="section level4">
<h4>– Seleccionar el subconjunto solo de la última fila coincidente de
todas las filas donde <code>origin</code> coincide con <em>“LGA”, “JFK”,
“EWR”</em> y <code>dest</code> coincide con <em>“XNA”</em></h4>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>flights[.(<span class="fu">c</span>(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;EWR&quot;</span>), <span class="st">&quot;XNA&quot;</span>), mult <span class="ot">=</span> <span class="st">&quot;last&quot;</span>]</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="co">#     year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a><span class="co"># 1:  2014     5    23       163       148      MQ    LGA    XNA      158     1147    18</span></span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a><span class="co"># 2:    NA    NA    NA        NA        NA    &lt;NA&gt;    JFK    XNA       NA       NA    NA</span></span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a><span class="co"># 3:  2014     2     3       231       268      EV    EWR    XNA      184     1131    12</span></span></code></pre></div>
<p>=====* La consulta <em>“JFK”, “XNA”</em> no coincide con ninguna fila
en <code>flights</code> y, por lo tanto, devuelve
<code>NA</code>.=====</p>
<p>=====* Una vez más, la consulta para la segunda columna de clave
<code>dest</code>, <em>“XNA”</em>, se recicla para ajustarse a la
longitud de la consulta para la primera columna de clave
<code>origin</code>, que tiene una longitud 3.=====</p>
</div>
</div>
<div id="b-el-argumento-nomatch" class="section level3">
<h3>b) El argumento <em>nomatch</em></h3>
<p>Podemos elegir si las consultas que no coinciden deben devolver “NA”
o ignorarse por completo utilizando el argumento “nomatch”.</p>
<div id="del-ejemplo-anterior-seleccionar-un-subconjunto-de-todas-las-filas-solo-si-hay-una-coincidencia" class="section level4">
<h4>– Del ejemplo anterior, seleccionar un subconjunto de todas las
filas solo si hay una coincidencia</h4>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>flights[.(<span class="fu">c</span>(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;EWR&quot;</span>), <span class="st">&quot;XNA&quot;</span>), mult <span class="ot">=</span> <span class="st">&quot;last&quot;</span>, nomatch <span class="ot">=</span> <span class="cn">NULL</span>]</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="co">#     year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour</span></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a><span class="co">#    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a><span class="co"># 1:  2014     5    23       163       148      MQ    LGA    XNA      158     1147    18</span></span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a><span class="co"># 2:  2014     2     3       231       268      EV    EWR    XNA      184     1131    12</span></span></code></pre></div>
<p>=====* El valor predeterminado para <code>nomatch</code> es
<code>NA</code>. Si se establece <code>nomatch = NULL</code>, se omiten
las consultas sin coincidencias.=====</p>
<p>=====* La consulta “JFK”, “XNA” no coincide con ninguna fila en los
vuelos y, por lo tanto, se omite.=====</p>
</div>
</div>
</div>
<div id="búsqueda-binaria-vs-escaneo-de-vector" class="section level2">
<h2>4. Búsqueda binaria vs escaneo de vector</h2>
<p>Hemos visto hasta ahora cómo podemos establecer y utilizar claves
para seleccionar subconjuntos. Pero, ¿cuál es la ventaja? Por ejemplo,
en lugar de hacer:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="co"># key by origin,dest columns</span></span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>flights[.(<span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;MIA&quot;</span>)]</span></code></pre></div>
<p>Podríamos haber hecho:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>flights[origin <span class="sc">==</span> <span class="st">&quot;JFK&quot;</span> <span class="sc">&amp;</span> dest <span class="sc">==</span> <span class="st">&quot;MIA&quot;</span>]</span></code></pre></div>
<p>Una de las ventajas más probables es que la sintaxis es más corta.
Pero, más aún, los <em>subconjuntos basados en búsqueda binaria</em> son
<strong>increíblemente rápidos</strong>.</p>
<p>A medida que el tiempo avanza, <code>data.table</code> obtiene nuevas
optimizaciones. Actualmente la última llamada es optimizada
automáticamente para usar <em>búsqueda binaria</em>.<br />
Si quiere usar <em>escaneo de vector</em>, más lento, debe eliminar las
claves.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="fu">setkey</span>(flights, <span class="cn">NULL</span>)</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>flights[origin <span class="sc">==</span> <span class="st">&quot;JFK&quot;</span> <span class="sc">&amp;</span> dest <span class="sc">==</span> <span class="st">&quot;MIA&quot;</span>]</span></code></pre></div>
<div id="a-rendimiento-del-enfoque-de-búsqueda-binaria" class="section level3">
<h3>a) Rendimiento del enfoque de búsqueda binaria</h3>
<p>Para ilustrarlo, creemos una data.table de muestra con 20 millones de
filas y tres columnas y clasifiquémosla por las columnas «x» e «y».</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2</span><span class="dt">L</span>)</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>N <span class="ot">=</span> <span class="fl">2e7</span>L</span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>DT <span class="ot">=</span> <span class="fu">data.table</span>(<span class="at">x =</span> <span class="fu">sample</span>(letters, N, <span class="cn">TRUE</span>),</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>                <span class="at">y =</span> <span class="fu">sample</span>(<span class="dv">1000</span><span class="dt">L</span>, N, <span class="cn">TRUE</span>),</span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>                <span class="at">val =</span> <span class="fu">runif</span>(N))</span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">object.size</span>(DT), <span class="at">units =</span> <span class="st">&quot;Mb&quot;</span>)</span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a><span class="co"># 381.5 Mb</span></span></code></pre></div>
<p><code>DT</code> ocupa aproximadamente 380 MB. No es realmente una
cantidad enorme, pero esto servirá para ilustrar el punto.</p>
<p>De lo que hemos visto en la sección Introducción a data.table,
podemos crear subconjuntos de aquellas filas donde las columnas
<code>x = &quot;g&quot;</code> e <code>y = 877</code> de la siguiente manera:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">key</span>(DT)</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="co"># NULL</span></span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a><span class="do">## (1) Usual way of subsetting - vector scan approach</span></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a>t1 <span class="ot">&lt;-</span> <span class="fu">system.time</span>(ans1 <span class="ot">&lt;-</span> DT[x <span class="sc">==</span> <span class="st">&quot;g&quot;</span> <span class="sc">&amp;</span> y <span class="sc">==</span> <span class="dv">877</span><span class="dt">L</span>])</span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a>t1</span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a><span class="co">#    user  system elapsed </span></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a><span class="co">#    0.36    0.10    0.47</span></span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a><span class="fu">head</span>(ans1)</span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a><span class="co">#         x     y        val</span></span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;int&gt;      &lt;num&gt;</span></span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a><span class="co"># 1:      g   877 0.57059767</span></span>
<span id="cb32-12"><a href="#cb32-12" tabindex="-1"></a><span class="co"># 2:      g   877 0.74859806</span></span>
<span id="cb32-13"><a href="#cb32-13" tabindex="-1"></a><span class="co"># 3:      g   877 0.03616756</span></span>
<span id="cb32-14"><a href="#cb32-14" tabindex="-1"></a><span class="co"># 4:      g   877 0.28087868</span></span>
<span id="cb32-15"><a href="#cb32-15" tabindex="-1"></a><span class="co"># 5:      g   877 0.83727299</span></span>
<span id="cb32-16"><a href="#cb32-16" tabindex="-1"></a><span class="co"># 6:      g   877 0.43867189</span></span>
<span id="cb32-17"><a href="#cb32-17" tabindex="-1"></a><span class="fu">dim</span>(ans1)</span>
<span id="cb32-18"><a href="#cb32-18" tabindex="-1"></a><span class="co"># [1] 762   3</span></span></code></pre></div>
<p>Ahora vamos a intentar crear subconjuntos mediante el uso de
claves.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="fu">setkeyv</span>(DT, <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>))</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a><span class="fu">key</span>(DT)</span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a><span class="co"># [1] &quot;x&quot; &quot;y&quot;</span></span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a><span class="do">## (2) Subsetting using keys</span></span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>t2 <span class="ot">&lt;-</span> <span class="fu">system.time</span>(ans2 <span class="ot">&lt;-</span> DT[.(<span class="st">&quot;g&quot;</span>, <span class="dv">877</span><span class="dt">L</span>)])</span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a>t2</span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a><span class="co">#    user  system elapsed </span></span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a><span class="co">#       0       0       0</span></span>
<span id="cb33-9"><a href="#cb33-9" tabindex="-1"></a><span class="fu">head</span>(ans2)</span>
<span id="cb33-10"><a href="#cb33-10" tabindex="-1"></a><span class="co"># Key: &lt;x, y&gt;</span></span>
<span id="cb33-11"><a href="#cb33-11" tabindex="-1"></a><span class="co">#         x     y        val</span></span>
<span id="cb33-12"><a href="#cb33-12" tabindex="-1"></a><span class="co">#    &lt;char&gt; &lt;int&gt;      &lt;num&gt;</span></span>
<span id="cb33-13"><a href="#cb33-13" tabindex="-1"></a><span class="co"># 1:      g   877 0.57059767</span></span>
<span id="cb33-14"><a href="#cb33-14" tabindex="-1"></a><span class="co"># 2:      g   877 0.74859806</span></span>
<span id="cb33-15"><a href="#cb33-15" tabindex="-1"></a><span class="co"># 3:      g   877 0.03616756</span></span>
<span id="cb33-16"><a href="#cb33-16" tabindex="-1"></a><span class="co"># 4:      g   877 0.28087868</span></span>
<span id="cb33-17"><a href="#cb33-17" tabindex="-1"></a><span class="co"># 5:      g   877 0.83727299</span></span>
<span id="cb33-18"><a href="#cb33-18" tabindex="-1"></a><span class="co"># 6:      g   877 0.43867189</span></span>
<span id="cb33-19"><a href="#cb33-19" tabindex="-1"></a><span class="fu">dim</span>(ans2)</span>
<span id="cb33-20"><a href="#cb33-20" tabindex="-1"></a><span class="co"># [1] 762   3</span></span>
<span id="cb33-21"><a href="#cb33-21" tabindex="-1"></a></span>
<span id="cb33-22"><a href="#cb33-22" tabindex="-1"></a><span class="fu">identical</span>(ans1<span class="sc">$</span>val, ans2<span class="sc">$</span>val)</span>
<span id="cb33-23"><a href="#cb33-23" tabindex="-1"></a><span class="co"># [1] TRUE</span></span></code></pre></div>
<ul>
<li>La mejora en velocidad es <strong>~470x</strong>!</li>
</ul>
</div>
<div id="b-por-qué-al-introducir-datos-en-una-data.table-se-obtienen-subconjuntos-increíblemente-rápidos" class="section level3">
<h3>b) ¿Por qué al introducir datos en una <em>data.table</em> se
obtienen subconjuntos increíblemente rápidos?</h3>
<p>Para entender esto, veamos primero qué hace el <em>enfoque de escaneo
de vector</em> (método 1).</p>
<div id="enfoque-de-escaneo-de-vector" class="section level4">
<h4>Enfoque de escaneo de vector</h4>
<p>=====* Se busca el valor <em>“g”</em> en la columna <code>x</code>
fila por fila, en los 20 millones de filas. Esto da como resultado un
<em>vector lógico</em> de tamaño 20 millones, con valores
<code>TRUE, FALSE o NA</code> correspondientes al valor de
<code>x</code>.=====</p>
<p>=====* De manera similar, se busca la columna <code>y</code> en busca
de <code>877</code> en las 20 millones de filas una por una, y se
almacena en otro vector lógico.=====</p>
<p>=====* Las operaciones <code>&amp;</code> elemento por elemento se
realizan en los vectores lógicos intermedios y se devuelven todas las
filas donde la expresión se evalúa como <code>VERDADERO</code>.=====</p>
<p>Esto es lo que llamamos un “enfoque de escaneo de vector”, y es
bastante ineficiente, especialmente en tablas más grandes y cuando se
necesita seleccionar subconjuntos repetidamente, porque se deben
escanear todas las filas cada vez.</p>
<p>Ahora veamos el enfoque de búsqueda binaria (método 2). Recordemos de
<a href="#key-properties">Propiedades de la clave</a> - <em>establecer
claves reordena la data.table por las columnas de la clave</em>. Dado
que los datos están ordenados, no tenemos que <em>escanear a lo largo de
toda la longitud de la columna</em>. En cambio, podemos utilizar la
<em>búsqueda binaria</em> para buscar un valor en <code>O(log n)</code>
en lugar de <code>O(n)</code> en el caso del <em>enfoque de escaneo de
vector</em>, donde <code>n</code> es el número de filas en la
<em>data.table</em>.</p>
</div>
<div id="enfoque-de-búsqueda-binaria" class="section level4">
<h4>Enfoque de búsqueda binaria</h4>
<p>He aquí una ilustración muy sencilla. Consideremos los números
(ordenados) que se muestran a continuación:</p>
<pre><code>1, 5, 10, 19, 22, 23, 30</code></pre>
<p>Supongamos que queremos encontrar la posición coincidente del valor
<em>1</em>, usando la búsqueda binaria, así es como procederíamos,
porque sabemos que los datos están <em>ordenados</em>.</p>
<ul>
<li>Comienza con el valor del medio = 19. ¿1 = 19? No. 1 &lt; 19.</li>
</ul>
<p>=====* Dado que el valor que buscamos es menor que 19, debería estar
en algún lugar anterior a 19. Por lo tanto, podemos descartar el resto
de la mitad que sea &gt;= 19.=====</p>
<p>=====* Nuestro conjunto ahora se reduce a <em>1, 5, 10</em>. Tomamos
el valor medio una vez más = 5. ¿1 == 5? No. 1 &lt; 5.=====</p>
<p>=====* Nuestro conjunto se reduce a <em>1</em>. ¿1 == 1? Sí. El
índice correspondiente también es 1. Y esa es la única
coincidencia.=====</p>
<p>Por otro lado, un enfoque de escaneo vectorial tendría que escanear
todos los valores (aquí, 7).</p>
<p>Se puede observar que con cada búsqueda reducimos el número de
búsquedas a la mitad. Es por esto que los subconjuntos basados en
<em>búsquedas binarias</em> son <strong>increíblemente rápidos</strong>.
Dado que las filas de cada columna de <em>data.tables</em> tienen
ubicaciones contiguas en la memoria, las operaciones se realizan de una
manera muy eficiente en el uso de la memoria caché (lo que también
contribuye a la <em>velocidad</em>).</p>
<p>Además, dado que obtenemos los índices de fila correspondientes
directamente sin tener que crear esos enormes vectores lógicos (iguales
al número de filas en una <em>data.table</em>), también es bastante
<strong>eficiente en términos de memoria</strong>.</p>
</div>
</div>
</div>
<div id="resumen" class="section level2">
<h2>Resumen</h2>
<p>En esta viñeta, hemos aprendido otro método para crear subconjuntos
de filas en <code>i</code> mediante la introducción de claves en una
<em>data.table</em>. La introducción de claves nos permite realizar
subconjuntos increíblemente rápidos mediante la <em>búsqueda
binaria</em>. En particular, hemos visto cómo</p>
<ul>
<li>establecer clave y subconjunto usando la clave en una
<em>data.table</em>.</li>
</ul>
<p>=====* subconjunto que utiliza claves que obtienen <em>índices de
fila</em> en <code>i</code>, pero mucho más rápido.=====</p>
<p>=====* combinar subconjuntos basados en claves con <code>j</code> y
<code>by</code>. Tenga en cuenta que las operaciones <code>j</code> y
<code>by</code> son exactamente las mismas que antes.=====</p>
<p>Los subconjuntos basados en claves son <strong>increíblemente
rápidos</strong> y son particularmente útiles cuando la tarea implica
<em>subconjuntos repetidos</em>. Pero puede que no siempre sea deseable
establecer la clave y reordenar físicamente la <em>data.table</em>. En
la viñeta siguiente, abordaremos este tema utilizando una <em>nueva</em>
característica – <em>índices secundarios</em>.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
